// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "enum.pb.h"
#include "trade.pb.h"
// @@protoc_insertion_point(includes)

namespace entity {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class StringParam;
class IntParam;
class LegItem;
class PortfolioItem;
class ConnectParam;
class OperationReturn;
class LoginParam;
class RegQuoteParam;
class PorfOpenPosiParam;
class ClosePositionParam;
class LegOrderUpdateParam;
class ArbitrageStrategySettings;
class ChangePosiStrategySettings;
class ModifyStrategyParam;
class ModifyPortfolioSwitchParam;
class ModifyRunningStatusParam;
class ModifyPortfolioPreferredLegParam;

// ===================================================================

class StringParam : public ::google::protobuf::Message {
 public:
  StringParam();
  virtual ~StringParam();
  
  StringParam(const StringParam& from);
  
  inline StringParam& operator=(const StringParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringParam& default_instance();
  
  void Swap(StringParam* other);
  
  // implements Message ----------------------------------------------
  
  StringParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringParam& from);
  void MergeFrom(const StringParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:entity.StringParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static StringParam* default_instance_;
};
// -------------------------------------------------------------------

class IntParam : public ::google::protobuf::Message {
 public:
  IntParam();
  virtual ~IntParam();
  
  IntParam(const IntParam& from);
  
  inline IntParam& operator=(const IntParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntParam& default_instance();
  
  void Swap(IntParam* other);
  
  // implements Message ----------------------------------------------
  
  IntParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntParam& from);
  void MergeFrom(const IntParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.IntParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static IntParam* default_instance_;
};
// -------------------------------------------------------------------

class LegItem : public ::google::protobuf::Message {
 public:
  LegItem();
  virtual ~LegItem();
  
  LegItem(const LegItem& from);
  
  inline LegItem& operator=(const LegItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegItem& default_instance();
  
  void Swap(LegItem* other);
  
  // implements Message ----------------------------------------------
  
  LegItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegItem& from);
  void MergeFrom(const LegItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required int32 Ratio = 2;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 2;
  inline ::google::protobuf::int32 ratio() const;
  inline void set_ratio(::google::protobuf::int32 value);
  
  // required .entity.PosiDirectionType Side = 3;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 3;
  inline entity::PosiDirectionType side() const;
  inline void set_side(entity::PosiDirectionType value);
  
  // required .entity.LegStatus Status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline entity::LegStatus status() const;
  inline void set_status(entity::LegStatus value);
  
  // required double Last = 5;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 5;
  inline double last() const;
  inline void set_last(double value);
  
  // required double Ask = 6;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 6;
  inline double ask() const;
  inline void set_ask(double value);
  
  // required double Bid = 7;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 7;
  inline double bid() const;
  inline void set_bid(double value);
  
  // required bool IsPreferred = 8;
  inline bool has_ispreferred() const;
  inline void clear_ispreferred();
  static const int kIsPreferredFieldNumber = 8;
  inline bool ispreferred() const;
  inline void set_ispreferred(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.LegItem)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_ratio();
  inline void clear_has_ratio();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_ispreferred();
  inline void clear_has_ispreferred();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  ::google::protobuf::int32 ratio_;
  int side_;
  double last_;
  double ask_;
  int status_;
  bool ispreferred_;
  double bid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegItem* default_instance_;
};
// -------------------------------------------------------------------

class PortfolioItem : public ::google::protobuf::Message {
 public:
  PortfolioItem();
  virtual ~PortfolioItem();
  
  PortfolioItem(const PortfolioItem& from);
  
  inline PortfolioItem& operator=(const PortfolioItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortfolioItem& default_instance();
  
  void Swap(PortfolioItem* other);
  
  // implements Message ----------------------------------------------
  
  PortfolioItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortfolioItem& from);
  void MergeFrom(const PortfolioItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // required double Diff = 3;
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 3;
  inline double diff() const;
  inline void set_diff(double value);
  
  // required double LongDiff = 4;
  inline bool has_longdiff() const;
  inline void clear_longdiff();
  static const int kLongDiffFieldNumber = 4;
  inline double longdiff() const;
  inline void set_longdiff(double value);
  
  // required double ShortDiff = 5;
  inline bool has_shortdiff() const;
  inline void clear_shortdiff();
  static const int kShortDiffFieldNumber = 5;
  inline double shortdiff() const;
  inline void set_shortdiff(double value);
  
  // required bool AutoOpen = 6;
  inline bool has_autoopen() const;
  inline void clear_autoopen();
  static const int kAutoOpenFieldNumber = 6;
  inline bool autoopen() const;
  inline void set_autoopen(bool value);
  
  // required bool AutoStopGain = 7;
  inline bool has_autostopgain() const;
  inline void clear_autostopgain();
  static const int kAutoStopGainFieldNumber = 7;
  inline bool autostopgain() const;
  inline void set_autostopgain(bool value);
  
  // required bool AutoStopLoss = 8;
  inline bool has_autostoploss() const;
  inline void clear_autostoploss();
  static const int kAutoStopLossFieldNumber = 8;
  inline bool autostoploss() const;
  inline void set_autostoploss(bool value);
  
  // repeated .entity.LegItem Legs = 9;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 9;
  inline const ::entity::LegItem& legs(int index) const;
  inline ::entity::LegItem* mutable_legs(int index);
  inline ::entity::LegItem* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
      mutable_legs();
  
  // required string StrategyName = 10;
  inline bool has_strategyname() const;
  inline void clear_strategyname();
  static const int kStrategyNameFieldNumber = 10;
  inline const ::std::string& strategyname() const;
  inline void set_strategyname(const ::std::string& value);
  inline void set_strategyname(const char* value);
  inline void set_strategyname(const char* value, size_t size);
  inline ::std::string* mutable_strategyname();
  inline ::std::string* release_strategyname();
  
  // required bytes StrategyData = 11;
  inline bool has_strategydata() const;
  inline void clear_strategydata();
  static const int kStrategyDataFieldNumber = 11;
  inline const ::std::string& strategydata() const;
  inline void set_strategydata(const ::std::string& value);
  inline void set_strategydata(const char* value);
  inline void set_strategydata(const void* value, size_t size);
  inline ::std::string* mutable_strategydata();
  inline ::std::string* release_strategydata();
  
  // required bool StrategyRunning = 12;
  inline bool has_strategyrunning() const;
  inline void clear_strategyrunning();
  static const int kStrategyRunningFieldNumber = 12;
  inline bool strategyrunning() const;
  inline void set_strategyrunning(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.PortfolioItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_diff();
  inline void clear_has_diff();
  inline void set_has_longdiff();
  inline void clear_has_longdiff();
  inline void set_has_shortdiff();
  inline void clear_has_shortdiff();
  inline void set_has_autoopen();
  inline void clear_has_autoopen();
  inline void set_has_autostopgain();
  inline void clear_has_autostopgain();
  inline void set_has_autostoploss();
  inline void clear_has_autostoploss();
  inline void set_has_strategyname();
  inline void clear_has_strategyname();
  inline void set_has_strategydata();
  inline void clear_has_strategydata();
  inline void set_has_strategyrunning();
  inline void clear_has_strategyrunning();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  double diff_;
  double longdiff_;
  double shortdiff_;
  ::google::protobuf::int32 quantity_;
  bool autoopen_;
  bool autostopgain_;
  bool autostoploss_;
  bool strategyrunning_;
  ::google::protobuf::RepeatedPtrField< ::entity::LegItem > legs_;
  ::std::string* strategyname_;
  ::std::string* strategydata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PortfolioItem* default_instance_;
};
// -------------------------------------------------------------------

class ConnectParam : public ::google::protobuf::Message {
 public:
  ConnectParam();
  virtual ~ConnectParam();
  
  ConnectParam(const ConnectParam& from);
  
  inline ConnectParam& operator=(const ConnectParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectParam& default_instance();
  
  void Swap(ConnectParam* other);
  
  // implements Message ----------------------------------------------
  
  ConnectParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectParam& from);
  void MergeFrom(const ConnectParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string QuoteAddress = 1;
  inline bool has_quoteaddress() const;
  inline void clear_quoteaddress();
  static const int kQuoteAddressFieldNumber = 1;
  inline const ::std::string& quoteaddress() const;
  inline void set_quoteaddress(const ::std::string& value);
  inline void set_quoteaddress(const char* value);
  inline void set_quoteaddress(const char* value, size_t size);
  inline ::std::string* mutable_quoteaddress();
  inline ::std::string* release_quoteaddress();
  
  // required string StreamFolder = 2;
  inline bool has_streamfolder() const;
  inline void clear_streamfolder();
  static const int kStreamFolderFieldNumber = 2;
  inline const ::std::string& streamfolder() const;
  inline void set_streamfolder(const ::std::string& value);
  inline void set_streamfolder(const char* value);
  inline void set_streamfolder(const char* value, size_t size);
  inline ::std::string* mutable_streamfolder();
  inline ::std::string* release_streamfolder();
  
  // @@protoc_insertion_point(class_scope:entity.ConnectParam)
 private:
  inline void set_has_quoteaddress();
  inline void clear_has_quoteaddress();
  inline void set_has_streamfolder();
  inline void clear_has_streamfolder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* quoteaddress_;
  ::std::string* streamfolder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ConnectParam* default_instance_;
};
// -------------------------------------------------------------------

class OperationReturn : public ::google::protobuf::Message {
 public:
  OperationReturn();
  virtual ~OperationReturn();
  
  OperationReturn(const OperationReturn& from);
  
  inline OperationReturn& operator=(const OperationReturn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationReturn& default_instance();
  
  void Swap(OperationReturn* other);
  
  // implements Message ----------------------------------------------
  
  OperationReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationReturn& from);
  void MergeFrom(const OperationReturn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool Success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string ErrorMessage = 2;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:entity.OperationReturn)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormessage_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static OperationReturn* default_instance_;
};
// -------------------------------------------------------------------

class LoginParam : public ::google::protobuf::Message {
 public:
  LoginParam();
  virtual ~LoginParam();
  
  LoginParam(const LoginParam& from);
  
  inline LoginParam& operator=(const LoginParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginParam& default_instance();
  
  void Swap(LoginParam* other);
  
  // implements Message ----------------------------------------------
  
  LoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginParam& from);
  void MergeFrom(const LoginParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerId = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIdFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string UserId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:entity.LoginParam)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* userid_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginParam* default_instance_;
};
// -------------------------------------------------------------------

class RegQuoteParam : public ::google::protobuf::Message {
 public:
  RegQuoteParam();
  virtual ~RegQuoteParam();
  
  RegQuoteParam(const RegQuoteParam& from);
  
  inline RegQuoteParam& operator=(const RegQuoteParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegQuoteParam& default_instance();
  
  void Swap(RegQuoteParam* other);
  
  // implements Message ----------------------------------------------
  
  RegQuoteParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegQuoteParam& from);
  void MergeFrom(const RegQuoteParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string Symbols = 1;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 1;
  inline const ::std::string& symbols(int index) const;
  inline ::std::string* mutable_symbols(int index);
  inline void set_symbols(int index, const ::std::string& value);
  inline void set_symbols(int index, const char* value);
  inline void set_symbols(int index, const char* value, size_t size);
  inline ::std::string* add_symbols();
  inline void add_symbols(const ::std::string& value);
  inline void add_symbols(const char* value);
  inline void add_symbols(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_symbols();
  
  // @@protoc_insertion_point(class_scope:entity.RegQuoteParam)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> symbols_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static RegQuoteParam* default_instance_;
};
// -------------------------------------------------------------------

class PorfOpenPosiParam : public ::google::protobuf::Message {
 public:
  PorfOpenPosiParam();
  virtual ~PorfOpenPosiParam();
  
  PorfOpenPosiParam(const PorfOpenPosiParam& from);
  
  inline PorfOpenPosiParam& operator=(const PorfOpenPosiParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PorfOpenPosiParam& default_instance();
  
  void Swap(PorfOpenPosiParam* other);
  
  // implements Message ----------------------------------------------
  
  PorfOpenPosiParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PorfOpenPosiParam& from);
  void MergeFrom(const PorfOpenPosiParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.PorfOpenPosiParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::google::protobuf::int32 quantity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PorfOpenPosiParam* default_instance_;
};
// -------------------------------------------------------------------

class ClosePositionParam : public ::google::protobuf::Message {
 public:
  ClosePositionParam();
  virtual ~ClosePositionParam();
  
  ClosePositionParam(const ClosePositionParam& from);
  
  inline ClosePositionParam& operator=(const ClosePositionParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClosePositionParam& default_instance();
  
  void Swap(ClosePositionParam* other);
  
  // implements Message ----------------------------------------------
  
  ClosePositionParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClosePositionParam& from);
  void MergeFrom(const ClosePositionParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .trade.MultiLegOrder MultiLegOrder = 1;
  inline bool has_multilegorder() const;
  inline void clear_multilegorder();
  static const int kMultiLegOrderFieldNumber = 1;
  inline const ::trade::MultiLegOrder& multilegorder() const;
  inline ::trade::MultiLegOrder* mutable_multilegorder();
  inline ::trade::MultiLegOrder* release_multilegorder();
  
  // optional string LegOrdRef = 2;
  inline bool has_legordref() const;
  inline void clear_legordref();
  static const int kLegOrdRefFieldNumber = 2;
  inline const ::std::string& legordref() const;
  inline void set_legordref(const ::std::string& value);
  inline void set_legordref(const char* value);
  inline void set_legordref(const char* value, size_t size);
  inline ::std::string* mutable_legordref();
  inline ::std::string* release_legordref();
  
  // @@protoc_insertion_point(class_scope:entity.ClosePositionParam)
 private:
  inline void set_has_multilegorder();
  inline void clear_has_multilegorder();
  inline void set_has_legordref();
  inline void clear_has_legordref();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::trade::MultiLegOrder* multilegorder_;
  ::std::string* legordref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ClosePositionParam* default_instance_;
};
// -------------------------------------------------------------------

class LegOrderUpdateParam : public ::google::protobuf::Message {
 public:
  LegOrderUpdateParam();
  virtual ~LegOrderUpdateParam();
  
  LegOrderUpdateParam(const LegOrderUpdateParam& from);
  
  inline LegOrderUpdateParam& operator=(const LegOrderUpdateParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegOrderUpdateParam& default_instance();
  
  void Swap(LegOrderUpdateParam* other);
  
  // implements Message ----------------------------------------------
  
  LegOrderUpdateParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegOrderUpdateParam& from);
  void MergeFrom(const LegOrderUpdateParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string MultiLegOrderId = 2;
  inline bool has_multilegorderid() const;
  inline void clear_multilegorderid();
  static const int kMultiLegOrderIdFieldNumber = 2;
  inline const ::std::string& multilegorderid() const;
  inline void set_multilegorderid(const ::std::string& value);
  inline void set_multilegorderid(const char* value);
  inline void set_multilegorderid(const char* value, size_t size);
  inline ::std::string* mutable_multilegorderid();
  inline ::std::string* release_multilegorderid();
  
  // required string LegOrderRef = 3;
  inline bool has_legorderref() const;
  inline void clear_legorderref();
  static const int kLegOrderRefFieldNumber = 3;
  inline const ::std::string& legorderref() const;
  inline void set_legorderref(const ::std::string& value);
  inline void set_legorderref(const char* value);
  inline void set_legorderref(const char* value, size_t size);
  inline ::std::string* mutable_legorderref();
  inline ::std::string* release_legorderref();
  
  // required .trade.Order LegOrder = 4;
  inline bool has_legorder() const;
  inline void clear_legorder();
  static const int kLegOrderFieldNumber = 4;
  inline const ::trade::Order& legorder() const;
  inline ::trade::Order* mutable_legorder();
  inline ::trade::Order* release_legorder();
  
  // @@protoc_insertion_point(class_scope:entity.LegOrderUpdateParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_multilegorderid();
  inline void clear_has_multilegorderid();
  inline void set_has_legorderref();
  inline void clear_has_legorderref();
  inline void set_has_legorder();
  inline void clear_has_legorder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* multilegorderid_;
  ::std::string* legorderref_;
  ::trade::Order* legorder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegOrderUpdateParam* default_instance_;
};
// -------------------------------------------------------------------

class ArbitrageStrategySettings : public ::google::protobuf::Message {
 public:
  ArbitrageStrategySettings();
  virtual ~ArbitrageStrategySettings();
  
  ArbitrageStrategySettings(const ArbitrageStrategySettings& from);
  
  inline ArbitrageStrategySettings& operator=(const ArbitrageStrategySettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArbitrageStrategySettings& default_instance();
  
  void Swap(ArbitrageStrategySettings* other);
  
  // implements Message ----------------------------------------------
  
  ArbitrageStrategySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArbitrageStrategySettings& from);
  void MergeFrom(const ArbitrageStrategySettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.PosiDirectionType Side = 1;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 1;
  inline entity::PosiDirectionType side() const;
  inline void set_side(entity::PosiDirectionType value);
  
  // required .entity.CompareCondition OpenCondition = 2;
  inline bool has_opencondition() const;
  inline void clear_opencondition();
  static const int kOpenConditionFieldNumber = 2;
  inline entity::CompareCondition opencondition() const;
  inline void set_opencondition(entity::CompareCondition value);
  
  // required double OpenPosiThreshold = 3;
  inline bool has_openposithreshold() const;
  inline void clear_openposithreshold();
  static const int kOpenPosiThresholdFieldNumber = 3;
  inline double openposithreshold() const;
  inline void set_openposithreshold(double value);
  
  // required .entity.CompareCondition StopGainCondition = 4;
  inline bool has_stopgaincondition() const;
  inline void clear_stopgaincondition();
  static const int kStopGainConditionFieldNumber = 4;
  inline entity::CompareCondition stopgaincondition() const;
  inline void set_stopgaincondition(entity::CompareCondition value);
  
  // required double StopGainThreshold = 5;
  inline bool has_stopgainthreshold() const;
  inline void clear_stopgainthreshold();
  static const int kStopGainThresholdFieldNumber = 5;
  inline double stopgainthreshold() const;
  inline void set_stopgainthreshold(double value);
  
  // required .entity.CompareCondition StopLossCondition = 6;
  inline bool has_stoplosscondition() const;
  inline void clear_stoplosscondition();
  static const int kStopLossConditionFieldNumber = 6;
  inline entity::CompareCondition stoplosscondition() const;
  inline void set_stoplosscondition(entity::CompareCondition value);
  
  // required double StopLossThreshold = 7;
  inline bool has_stoplossthreshold() const;
  inline void clear_stoplossthreshold();
  static const int kStopLossThresholdFieldNumber = 7;
  inline double stoplossthreshold() const;
  inline void set_stoplossthreshold(double value);
  
  // @@protoc_insertion_point(class_scope:entity.ArbitrageStrategySettings)
 private:
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_opencondition();
  inline void clear_has_opencondition();
  inline void set_has_openposithreshold();
  inline void clear_has_openposithreshold();
  inline void set_has_stopgaincondition();
  inline void clear_has_stopgaincondition();
  inline void set_has_stopgainthreshold();
  inline void clear_has_stopgainthreshold();
  inline void set_has_stoplosscondition();
  inline void clear_has_stoplosscondition();
  inline void set_has_stoplossthreshold();
  inline void clear_has_stoplossthreshold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int side_;
  int opencondition_;
  double openposithreshold_;
  double stopgainthreshold_;
  int stopgaincondition_;
  int stoplosscondition_;
  double stoplossthreshold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ArbitrageStrategySettings* default_instance_;
};
// -------------------------------------------------------------------

class ChangePosiStrategySettings : public ::google::protobuf::Message {
 public:
  ChangePosiStrategySettings();
  virtual ~ChangePosiStrategySettings();
  
  ChangePosiStrategySettings(const ChangePosiStrategySettings& from);
  
  inline ChangePosiStrategySettings& operator=(const ChangePosiStrategySettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePosiStrategySettings& default_instance();
  
  void Swap(ChangePosiStrategySettings* other);
  
  // implements Message ----------------------------------------------
  
  ChangePosiStrategySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePosiStrategySettings& from);
  void MergeFrom(const ChangePosiStrategySettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string CloseLeg = 1;
  inline bool has_closeleg() const;
  inline void clear_closeleg();
  static const int kCloseLegFieldNumber = 1;
  inline const ::std::string& closeleg() const;
  inline void set_closeleg(const ::std::string& value);
  inline void set_closeleg(const char* value);
  inline void set_closeleg(const char* value, size_t size);
  inline ::std::string* mutable_closeleg();
  inline ::std::string* release_closeleg();
  
  // required .entity.CompareCondition TriggerCondition = 2;
  inline bool has_triggercondition() const;
  inline void clear_triggercondition();
  static const int kTriggerConditionFieldNumber = 2;
  inline entity::CompareCondition triggercondition() const;
  inline void set_triggercondition(entity::CompareCondition value);
  
  // required double Threshold = 3;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 3;
  inline double threshold() const;
  inline void set_threshold(double value);
  
  // @@protoc_insertion_point(class_scope:entity.ChangePosiStrategySettings)
 private:
  inline void set_has_closeleg();
  inline void clear_has_closeleg();
  inline void set_has_triggercondition();
  inline void clear_has_triggercondition();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* closeleg_;
  double threshold_;
  int triggercondition_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ChangePosiStrategySettings* default_instance_;
};
// -------------------------------------------------------------------

class ModifyStrategyParam : public ::google::protobuf::Message {
 public:
  ModifyStrategyParam();
  virtual ~ModifyStrategyParam();
  
  ModifyStrategyParam(const ModifyStrategyParam& from);
  
  inline ModifyStrategyParam& operator=(const ModifyStrategyParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyStrategyParam& default_instance();
  
  void Swap(ModifyStrategyParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyStrategyParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyStrategyParam& from);
  void MergeFrom(const ModifyStrategyParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string StrategyName = 2;
  inline bool has_strategyname() const;
  inline void clear_strategyname();
  static const int kStrategyNameFieldNumber = 2;
  inline const ::std::string& strategyname() const;
  inline void set_strategyname(const ::std::string& value);
  inline void set_strategyname(const char* value);
  inline void set_strategyname(const char* value, size_t size);
  inline ::std::string* mutable_strategyname();
  inline ::std::string* release_strategyname();
  
  // required bytes StrategyData = 3;
  inline bool has_strategydata() const;
  inline void clear_strategydata();
  static const int kStrategyDataFieldNumber = 3;
  inline const ::std::string& strategydata() const;
  inline void set_strategydata(const ::std::string& value);
  inline void set_strategydata(const char* value);
  inline void set_strategydata(const void* value, size_t size);
  inline ::std::string* mutable_strategydata();
  inline ::std::string* release_strategydata();
  
  // @@protoc_insertion_point(class_scope:entity.ModifyStrategyParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_strategyname();
  inline void clear_has_strategyname();
  inline void set_has_strategydata();
  inline void clear_has_strategydata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* strategyname_;
  ::std::string* strategydata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyStrategyParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyPortfolioSwitchParam : public ::google::protobuf::Message {
 public:
  ModifyPortfolioSwitchParam();
  virtual ~ModifyPortfolioSwitchParam();
  
  ModifyPortfolioSwitchParam(const ModifyPortfolioSwitchParam& from);
  
  inline ModifyPortfolioSwitchParam& operator=(const ModifyPortfolioSwitchParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyPortfolioSwitchParam& default_instance();
  
  void Swap(ModifyPortfolioSwitchParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyPortfolioSwitchParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyPortfolioSwitchParam& from);
  void MergeFrom(const ModifyPortfolioSwitchParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required bool AutoOpen = 2;
  inline bool has_autoopen() const;
  inline void clear_autoopen();
  static const int kAutoOpenFieldNumber = 2;
  inline bool autoopen() const;
  inline void set_autoopen(bool value);
  
  // required bool AutoStopGain = 3;
  inline bool has_autostopgain() const;
  inline void clear_autostopgain();
  static const int kAutoStopGainFieldNumber = 3;
  inline bool autostopgain() const;
  inline void set_autostopgain(bool value);
  
  // required bool AutoStopLoss = 4;
  inline bool has_autostoploss() const;
  inline void clear_autostoploss();
  static const int kAutoStopLossFieldNumber = 4;
  inline bool autostoploss() const;
  inline void set_autostoploss(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.ModifyPortfolioSwitchParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_autoopen();
  inline void clear_has_autoopen();
  inline void set_has_autostopgain();
  inline void clear_has_autostopgain();
  inline void set_has_autostoploss();
  inline void clear_has_autostoploss();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  bool autoopen_;
  bool autostopgain_;
  bool autostoploss_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyPortfolioSwitchParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRunningStatusParam : public ::google::protobuf::Message {
 public:
  ModifyRunningStatusParam();
  virtual ~ModifyRunningStatusParam();
  
  ModifyRunningStatusParam(const ModifyRunningStatusParam& from);
  
  inline ModifyRunningStatusParam& operator=(const ModifyRunningStatusParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRunningStatusParam& default_instance();
  
  void Swap(ModifyRunningStatusParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyRunningStatusParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRunningStatusParam& from);
  void MergeFrom(const ModifyRunningStatusParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required bool Enabled = 2;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.ModifyRunningStatusParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  bool enabled_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyRunningStatusParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyPortfolioPreferredLegParam : public ::google::protobuf::Message {
 public:
  ModifyPortfolioPreferredLegParam();
  virtual ~ModifyPortfolioPreferredLegParam();
  
  ModifyPortfolioPreferredLegParam(const ModifyPortfolioPreferredLegParam& from);
  
  inline ModifyPortfolioPreferredLegParam& operator=(const ModifyPortfolioPreferredLegParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyPortfolioPreferredLegParam& default_instance();
  
  void Swap(ModifyPortfolioPreferredLegParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyPortfolioPreferredLegParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyPortfolioPreferredLegParam& from);
  void MergeFrom(const ModifyPortfolioPreferredLegParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string LegSymbol = 2;
  inline bool has_legsymbol() const;
  inline void clear_legsymbol();
  static const int kLegSymbolFieldNumber = 2;
  inline const ::std::string& legsymbol() const;
  inline void set_legsymbol(const ::std::string& value);
  inline void set_legsymbol(const char* value);
  inline void set_legsymbol(const char* value, size_t size);
  inline ::std::string* mutable_legsymbol();
  inline ::std::string* release_legsymbol();
  
  // @@protoc_insertion_point(class_scope:entity.ModifyPortfolioPreferredLegParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_legsymbol();
  inline void clear_has_legsymbol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* legsymbol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyPortfolioPreferredLegParam* default_instance_;
};
// ===================================================================


// ===================================================================

// StringParam

// required string Data = 1;
inline bool StringParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringParam::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& StringParam::data() const {
  return *data_;
}
inline void StringParam::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringParam::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* StringParam::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IntParam

// required int32 Data = 2;
inline bool IntParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntParam::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 IntParam::data() const {
  return data_;
}
inline void IntParam::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// -------------------------------------------------------------------

// LegItem

// required string Symbol = 1;
inline bool LegItem::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegItem::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegItem::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegItem::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& LegItem::symbol() const {
  return *symbol_;
}
inline void LegItem::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegItem::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* LegItem::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Ratio = 2;
inline bool LegItem::has_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegItem::set_has_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegItem::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegItem::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline ::google::protobuf::int32 LegItem::ratio() const {
  return ratio_;
}
inline void LegItem::set_ratio(::google::protobuf::int32 value) {
  set_has_ratio();
  ratio_ = value;
}

// required .entity.PosiDirectionType Side = 3;
inline bool LegItem::has_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegItem::set_has_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegItem::clear_has_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegItem::clear_side() {
  side_ = 49;
  clear_has_side();
}
inline entity::PosiDirectionType LegItem::side() const {
  return static_cast< entity::PosiDirectionType >(side_);
}
inline void LegItem::set_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_side();
  side_ = value;
}

// required .entity.LegStatus Status = 4;
inline bool LegItem::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegItem::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegItem::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline entity::LegStatus LegItem::status() const {
  return static_cast< entity::LegStatus >(status_);
}
inline void LegItem::set_status(entity::LegStatus value) {
  GOOGLE_DCHECK(entity::LegStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required double Last = 5;
inline bool LegItem::has_last() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegItem::set_has_last() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegItem::clear_has_last() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegItem::clear_last() {
  last_ = 0;
  clear_has_last();
}
inline double LegItem::last() const {
  return last_;
}
inline void LegItem::set_last(double value) {
  set_has_last();
  last_ = value;
}

// required double Ask = 6;
inline bool LegItem::has_ask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LegItem::set_has_ask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LegItem::clear_has_ask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LegItem::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline double LegItem::ask() const {
  return ask_;
}
inline void LegItem::set_ask(double value) {
  set_has_ask();
  ask_ = value;
}

// required double Bid = 7;
inline bool LegItem::has_bid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LegItem::set_has_bid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LegItem::clear_has_bid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LegItem::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline double LegItem::bid() const {
  return bid_;
}
inline void LegItem::set_bid(double value) {
  set_has_bid();
  bid_ = value;
}

// required bool IsPreferred = 8;
inline bool LegItem::has_ispreferred() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LegItem::set_has_ispreferred() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LegItem::clear_has_ispreferred() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LegItem::clear_ispreferred() {
  ispreferred_ = false;
  clear_has_ispreferred();
}
inline bool LegItem::ispreferred() const {
  return ispreferred_;
}
inline void LegItem::set_ispreferred(bool value) {
  set_has_ispreferred();
  ispreferred_ = value;
}

// -------------------------------------------------------------------

// PortfolioItem

// required string ID = 1;
inline bool PortfolioItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortfolioItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortfolioItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortfolioItem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PortfolioItem::id() const {
  return *id_;
}
inline void PortfolioItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PortfolioItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PortfolioItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortfolioItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortfolioItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortfolioItem::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PortfolioItem::quantity() const {
  return quantity_;
}
inline void PortfolioItem::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required double Diff = 3;
inline bool PortfolioItem::has_diff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortfolioItem::set_has_diff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortfolioItem::clear_has_diff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortfolioItem::clear_diff() {
  diff_ = 0;
  clear_has_diff();
}
inline double PortfolioItem::diff() const {
  return diff_;
}
inline void PortfolioItem::set_diff(double value) {
  set_has_diff();
  diff_ = value;
}

// required double LongDiff = 4;
inline bool PortfolioItem::has_longdiff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortfolioItem::set_has_longdiff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortfolioItem::clear_has_longdiff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortfolioItem::clear_longdiff() {
  longdiff_ = 0;
  clear_has_longdiff();
}
inline double PortfolioItem::longdiff() const {
  return longdiff_;
}
inline void PortfolioItem::set_longdiff(double value) {
  set_has_longdiff();
  longdiff_ = value;
}

// required double ShortDiff = 5;
inline bool PortfolioItem::has_shortdiff() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PortfolioItem::set_has_shortdiff() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PortfolioItem::clear_has_shortdiff() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PortfolioItem::clear_shortdiff() {
  shortdiff_ = 0;
  clear_has_shortdiff();
}
inline double PortfolioItem::shortdiff() const {
  return shortdiff_;
}
inline void PortfolioItem::set_shortdiff(double value) {
  set_has_shortdiff();
  shortdiff_ = value;
}

// required bool AutoOpen = 6;
inline bool PortfolioItem::has_autoopen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PortfolioItem::set_has_autoopen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PortfolioItem::clear_has_autoopen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PortfolioItem::clear_autoopen() {
  autoopen_ = false;
  clear_has_autoopen();
}
inline bool PortfolioItem::autoopen() const {
  return autoopen_;
}
inline void PortfolioItem::set_autoopen(bool value) {
  set_has_autoopen();
  autoopen_ = value;
}

// required bool AutoStopGain = 7;
inline bool PortfolioItem::has_autostopgain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PortfolioItem::set_has_autostopgain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PortfolioItem::clear_has_autostopgain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PortfolioItem::clear_autostopgain() {
  autostopgain_ = false;
  clear_has_autostopgain();
}
inline bool PortfolioItem::autostopgain() const {
  return autostopgain_;
}
inline void PortfolioItem::set_autostopgain(bool value) {
  set_has_autostopgain();
  autostopgain_ = value;
}

// required bool AutoStopLoss = 8;
inline bool PortfolioItem::has_autostoploss() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PortfolioItem::set_has_autostoploss() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PortfolioItem::clear_has_autostoploss() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PortfolioItem::clear_autostoploss() {
  autostoploss_ = false;
  clear_has_autostoploss();
}
inline bool PortfolioItem::autostoploss() const {
  return autostoploss_;
}
inline void PortfolioItem::set_autostoploss(bool value) {
  set_has_autostoploss();
  autostoploss_ = value;
}

// repeated .entity.LegItem Legs = 9;
inline int PortfolioItem::legs_size() const {
  return legs_.size();
}
inline void PortfolioItem::clear_legs() {
  legs_.Clear();
}
inline const ::entity::LegItem& PortfolioItem::legs(int index) const {
  return legs_.Get(index);
}
inline ::entity::LegItem* PortfolioItem::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::entity::LegItem* PortfolioItem::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
PortfolioItem::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
PortfolioItem::mutable_legs() {
  return &legs_;
}

// required string StrategyName = 10;
inline bool PortfolioItem::has_strategyname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PortfolioItem::set_has_strategyname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PortfolioItem::clear_has_strategyname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PortfolioItem::clear_strategyname() {
  if (strategyname_ != &::google::protobuf::internal::kEmptyString) {
    strategyname_->clear();
  }
  clear_has_strategyname();
}
inline const ::std::string& PortfolioItem::strategyname() const {
  return *strategyname_;
}
inline void PortfolioItem::set_strategyname(const ::std::string& value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void PortfolioItem::set_strategyname(const char* value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void PortfolioItem::set_strategyname(const char* value, size_t size) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::mutable_strategyname() {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  return strategyname_;
}
inline ::std::string* PortfolioItem::release_strategyname() {
  clear_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategyname_;
    strategyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes StrategyData = 11;
inline bool PortfolioItem::has_strategydata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PortfolioItem::set_has_strategydata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PortfolioItem::clear_has_strategydata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PortfolioItem::clear_strategydata() {
  if (strategydata_ != &::google::protobuf::internal::kEmptyString) {
    strategydata_->clear();
  }
  clear_has_strategydata();
}
inline const ::std::string& PortfolioItem::strategydata() const {
  return *strategydata_;
}
inline void PortfolioItem::set_strategydata(const ::std::string& value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void PortfolioItem::set_strategydata(const char* value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void PortfolioItem::set_strategydata(const void* value, size_t size) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::mutable_strategydata() {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  return strategydata_;
}
inline ::std::string* PortfolioItem::release_strategydata() {
  clear_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategydata_;
    strategydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool StrategyRunning = 12;
inline bool PortfolioItem::has_strategyrunning() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PortfolioItem::set_has_strategyrunning() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PortfolioItem::clear_has_strategyrunning() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PortfolioItem::clear_strategyrunning() {
  strategyrunning_ = false;
  clear_has_strategyrunning();
}
inline bool PortfolioItem::strategyrunning() const {
  return strategyrunning_;
}
inline void PortfolioItem::set_strategyrunning(bool value) {
  set_has_strategyrunning();
  strategyrunning_ = value;
}

// -------------------------------------------------------------------

// ConnectParam

// required string QuoteAddress = 1;
inline bool ConnectParam::has_quoteaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectParam::set_has_quoteaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectParam::clear_has_quoteaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectParam::clear_quoteaddress() {
  if (quoteaddress_ != &::google::protobuf::internal::kEmptyString) {
    quoteaddress_->clear();
  }
  clear_has_quoteaddress();
}
inline const ::std::string& ConnectParam::quoteaddress() const {
  return *quoteaddress_;
}
inline void ConnectParam::set_quoteaddress(const ::std::string& value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value, size_t size) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_quoteaddress() {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  return quoteaddress_;
}
inline ::std::string* ConnectParam::release_quoteaddress() {
  clear_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quoteaddress_;
    quoteaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StreamFolder = 2;
inline bool ConnectParam::has_streamfolder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectParam::set_has_streamfolder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectParam::clear_has_streamfolder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectParam::clear_streamfolder() {
  if (streamfolder_ != &::google::protobuf::internal::kEmptyString) {
    streamfolder_->clear();
  }
  clear_has_streamfolder();
}
inline const ::std::string& ConnectParam::streamfolder() const {
  return *streamfolder_;
}
inline void ConnectParam::set_streamfolder(const ::std::string& value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value, size_t size) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_streamfolder() {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  return streamfolder_;
}
inline ::std::string* ConnectParam::release_streamfolder() {
  clear_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamfolder_;
    streamfolder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OperationReturn

// required bool Success = 1;
inline bool OperationReturn::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationReturn::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationReturn::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationReturn::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool OperationReturn::success() const {
  return success_;
}
inline void OperationReturn::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string ErrorMessage = 2;
inline bool OperationReturn::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationReturn::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationReturn::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationReturn::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& OperationReturn::errormessage() const {
  return *errormessage_;
}
inline void OperationReturn::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationReturn::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* OperationReturn::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginParam

// required string BrokerId = 1;
inline bool LoginParam::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginParam::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginParam::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginParam::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& LoginParam::brokerid() const {
  return *brokerid_;
}
inline void LoginParam::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* LoginParam::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 2;
inline bool LoginParam::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginParam::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginParam::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginParam::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LoginParam::userid() const {
  return *userid_;
}
inline void LoginParam::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LoginParam::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 3;
inline bool LoginParam::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginParam::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginParam::password() const {
  return *password_;
}
inline void LoginParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RegQuoteParam

// repeated string Symbols = 1;
inline int RegQuoteParam::symbols_size() const {
  return symbols_.size();
}
inline void RegQuoteParam::clear_symbols() {
  symbols_.Clear();
}
inline const ::std::string& RegQuoteParam::symbols(int index) const {
  return symbols_.Get(index);
}
inline ::std::string* RegQuoteParam::mutable_symbols(int index) {
  return symbols_.Mutable(index);
}
inline void RegQuoteParam::set_symbols(int index, const ::std::string& value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value, size_t size) {
  symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegQuoteParam::add_symbols() {
  return symbols_.Add();
}
inline void RegQuoteParam::add_symbols(const ::std::string& value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value, size_t size) {
  symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegQuoteParam::symbols() const {
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegQuoteParam::mutable_symbols() {
  return &symbols_;
}

// -------------------------------------------------------------------

// PorfOpenPosiParam

// required string PortfId = 1;
inline bool PorfOpenPosiParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PorfOpenPosiParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PorfOpenPosiParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PorfOpenPosiParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& PorfOpenPosiParam::portfid() const {
  return *portfid_;
}
inline void PorfOpenPosiParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PorfOpenPosiParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* PorfOpenPosiParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PorfOpenPosiParam::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PorfOpenPosiParam::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PorfOpenPosiParam::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PorfOpenPosiParam::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PorfOpenPosiParam::quantity() const {
  return quantity_;
}
inline void PorfOpenPosiParam::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// ClosePositionParam

// required .trade.MultiLegOrder MultiLegOrder = 1;
inline bool ClosePositionParam::has_multilegorder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClosePositionParam::set_has_multilegorder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClosePositionParam::clear_has_multilegorder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClosePositionParam::clear_multilegorder() {
  if (multilegorder_ != NULL) multilegorder_->::trade::MultiLegOrder::Clear();
  clear_has_multilegorder();
}
inline const ::trade::MultiLegOrder& ClosePositionParam::multilegorder() const {
  return multilegorder_ != NULL ? *multilegorder_ : *default_instance_->multilegorder_;
}
inline ::trade::MultiLegOrder* ClosePositionParam::mutable_multilegorder() {
  set_has_multilegorder();
  if (multilegorder_ == NULL) multilegorder_ = new ::trade::MultiLegOrder;
  return multilegorder_;
}
inline ::trade::MultiLegOrder* ClosePositionParam::release_multilegorder() {
  clear_has_multilegorder();
  ::trade::MultiLegOrder* temp = multilegorder_;
  multilegorder_ = NULL;
  return temp;
}

// optional string LegOrdRef = 2;
inline bool ClosePositionParam::has_legordref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClosePositionParam::set_has_legordref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClosePositionParam::clear_has_legordref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClosePositionParam::clear_legordref() {
  if (legordref_ != &::google::protobuf::internal::kEmptyString) {
    legordref_->clear();
  }
  clear_has_legordref();
}
inline const ::std::string& ClosePositionParam::legordref() const {
  return *legordref_;
}
inline void ClosePositionParam::set_legordref(const ::std::string& value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value, size_t size) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClosePositionParam::mutable_legordref() {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  return legordref_;
}
inline ::std::string* ClosePositionParam::release_legordref() {
  clear_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legordref_;
    legordref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LegOrderUpdateParam

// required string PortfId = 1;
inline bool LegOrderUpdateParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegOrderUpdateParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegOrderUpdateParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegOrderUpdateParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& LegOrderUpdateParam::portfid() const {
  return *portfid_;
}
inline void LegOrderUpdateParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void LegOrderUpdateParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void LegOrderUpdateParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* LegOrderUpdateParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string MultiLegOrderId = 2;
inline bool LegOrderUpdateParam::has_multilegorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegOrderUpdateParam::set_has_multilegorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegOrderUpdateParam::clear_has_multilegorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegOrderUpdateParam::clear_multilegorderid() {
  if (multilegorderid_ != &::google::protobuf::internal::kEmptyString) {
    multilegorderid_->clear();
  }
  clear_has_multilegorderid();
}
inline const ::std::string& LegOrderUpdateParam::multilegorderid() const {
  return *multilegorderid_;
}
inline void LegOrderUpdateParam::set_multilegorderid(const ::std::string& value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void LegOrderUpdateParam::set_multilegorderid(const char* value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void LegOrderUpdateParam::set_multilegorderid(const char* value, size_t size) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_multilegorderid() {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  return multilegorderid_;
}
inline ::std::string* LegOrderUpdateParam::release_multilegorderid() {
  clear_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multilegorderid_;
    multilegorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string LegOrderRef = 3;
inline bool LegOrderUpdateParam::has_legorderref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegOrderUpdateParam::set_has_legorderref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegOrderUpdateParam::clear_has_legorderref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegOrderUpdateParam::clear_legorderref() {
  if (legorderref_ != &::google::protobuf::internal::kEmptyString) {
    legorderref_->clear();
  }
  clear_has_legorderref();
}
inline const ::std::string& LegOrderUpdateParam::legorderref() const {
  return *legorderref_;
}
inline void LegOrderUpdateParam::set_legorderref(const ::std::string& value) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(value);
}
inline void LegOrderUpdateParam::set_legorderref(const char* value) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(value);
}
inline void LegOrderUpdateParam::set_legorderref(const char* value, size_t size) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_legorderref() {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  return legorderref_;
}
inline ::std::string* LegOrderUpdateParam::release_legorderref() {
  clear_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legorderref_;
    legorderref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .trade.Order LegOrder = 4;
inline bool LegOrderUpdateParam::has_legorder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegOrderUpdateParam::set_has_legorder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegOrderUpdateParam::clear_has_legorder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegOrderUpdateParam::clear_legorder() {
  if (legorder_ != NULL) legorder_->::trade::Order::Clear();
  clear_has_legorder();
}
inline const ::trade::Order& LegOrderUpdateParam::legorder() const {
  return legorder_ != NULL ? *legorder_ : *default_instance_->legorder_;
}
inline ::trade::Order* LegOrderUpdateParam::mutable_legorder() {
  set_has_legorder();
  if (legorder_ == NULL) legorder_ = new ::trade::Order;
  return legorder_;
}
inline ::trade::Order* LegOrderUpdateParam::release_legorder() {
  clear_has_legorder();
  ::trade::Order* temp = legorder_;
  legorder_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ArbitrageStrategySettings

// required .entity.PosiDirectionType Side = 1;
inline bool ArbitrageStrategySettings::has_side() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArbitrageStrategySettings::set_has_side() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArbitrageStrategySettings::clear_has_side() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArbitrageStrategySettings::clear_side() {
  side_ = 49;
  clear_has_side();
}
inline entity::PosiDirectionType ArbitrageStrategySettings::side() const {
  return static_cast< entity::PosiDirectionType >(side_);
}
inline void ArbitrageStrategySettings::set_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_side();
  side_ = value;
}

// required .entity.CompareCondition OpenCondition = 2;
inline bool ArbitrageStrategySettings::has_opencondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArbitrageStrategySettings::set_has_opencondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArbitrageStrategySettings::clear_has_opencondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArbitrageStrategySettings::clear_opencondition() {
  opencondition_ = 0;
  clear_has_opencondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::opencondition() const {
  return static_cast< entity::CompareCondition >(opencondition_);
}
inline void ArbitrageStrategySettings::set_opencondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_opencondition();
  opencondition_ = value;
}

// required double OpenPosiThreshold = 3;
inline bool ArbitrageStrategySettings::has_openposithreshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArbitrageStrategySettings::set_has_openposithreshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArbitrageStrategySettings::clear_has_openposithreshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArbitrageStrategySettings::clear_openposithreshold() {
  openposithreshold_ = 0;
  clear_has_openposithreshold();
}
inline double ArbitrageStrategySettings::openposithreshold() const {
  return openposithreshold_;
}
inline void ArbitrageStrategySettings::set_openposithreshold(double value) {
  set_has_openposithreshold();
  openposithreshold_ = value;
}

// required .entity.CompareCondition StopGainCondition = 4;
inline bool ArbitrageStrategySettings::has_stopgaincondition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stopgaincondition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArbitrageStrategySettings::clear_has_stopgaincondition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArbitrageStrategySettings::clear_stopgaincondition() {
  stopgaincondition_ = 0;
  clear_has_stopgaincondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::stopgaincondition() const {
  return static_cast< entity::CompareCondition >(stopgaincondition_);
}
inline void ArbitrageStrategySettings::set_stopgaincondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_stopgaincondition();
  stopgaincondition_ = value;
}

// required double StopGainThreshold = 5;
inline bool ArbitrageStrategySettings::has_stopgainthreshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stopgainthreshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArbitrageStrategySettings::clear_has_stopgainthreshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArbitrageStrategySettings::clear_stopgainthreshold() {
  stopgainthreshold_ = 0;
  clear_has_stopgainthreshold();
}
inline double ArbitrageStrategySettings::stopgainthreshold() const {
  return stopgainthreshold_;
}
inline void ArbitrageStrategySettings::set_stopgainthreshold(double value) {
  set_has_stopgainthreshold();
  stopgainthreshold_ = value;
}

// required .entity.CompareCondition StopLossCondition = 6;
inline bool ArbitrageStrategySettings::has_stoplosscondition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stoplosscondition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArbitrageStrategySettings::clear_has_stoplosscondition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArbitrageStrategySettings::clear_stoplosscondition() {
  stoplosscondition_ = 0;
  clear_has_stoplosscondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::stoplosscondition() const {
  return static_cast< entity::CompareCondition >(stoplosscondition_);
}
inline void ArbitrageStrategySettings::set_stoplosscondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_stoplosscondition();
  stoplosscondition_ = value;
}

// required double StopLossThreshold = 7;
inline bool ArbitrageStrategySettings::has_stoplossthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stoplossthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArbitrageStrategySettings::clear_has_stoplossthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArbitrageStrategySettings::clear_stoplossthreshold() {
  stoplossthreshold_ = 0;
  clear_has_stoplossthreshold();
}
inline double ArbitrageStrategySettings::stoplossthreshold() const {
  return stoplossthreshold_;
}
inline void ArbitrageStrategySettings::set_stoplossthreshold(double value) {
  set_has_stoplossthreshold();
  stoplossthreshold_ = value;
}

// -------------------------------------------------------------------

// ChangePosiStrategySettings

// required string CloseLeg = 1;
inline bool ChangePosiStrategySettings::has_closeleg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePosiStrategySettings::set_has_closeleg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePosiStrategySettings::clear_has_closeleg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePosiStrategySettings::clear_closeleg() {
  if (closeleg_ != &::google::protobuf::internal::kEmptyString) {
    closeleg_->clear();
  }
  clear_has_closeleg();
}
inline const ::std::string& ChangePosiStrategySettings::closeleg() const {
  return *closeleg_;
}
inline void ChangePosiStrategySettings::set_closeleg(const ::std::string& value) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(value);
}
inline void ChangePosiStrategySettings::set_closeleg(const char* value) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(value);
}
inline void ChangePosiStrategySettings::set_closeleg(const char* value, size_t size) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePosiStrategySettings::mutable_closeleg() {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  return closeleg_;
}
inline ::std::string* ChangePosiStrategySettings::release_closeleg() {
  clear_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = closeleg_;
    closeleg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.CompareCondition TriggerCondition = 2;
inline bool ChangePosiStrategySettings::has_triggercondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePosiStrategySettings::set_has_triggercondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePosiStrategySettings::clear_has_triggercondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePosiStrategySettings::clear_triggercondition() {
  triggercondition_ = 0;
  clear_has_triggercondition();
}
inline entity::CompareCondition ChangePosiStrategySettings::triggercondition() const {
  return static_cast< entity::CompareCondition >(triggercondition_);
}
inline void ChangePosiStrategySettings::set_triggercondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_triggercondition();
  triggercondition_ = value;
}

// required double Threshold = 3;
inline bool ChangePosiStrategySettings::has_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangePosiStrategySettings::set_has_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangePosiStrategySettings::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangePosiStrategySettings::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline double ChangePosiStrategySettings::threshold() const {
  return threshold_;
}
inline void ChangePosiStrategySettings::set_threshold(double value) {
  set_has_threshold();
  threshold_ = value;
}

// -------------------------------------------------------------------

// ModifyStrategyParam

// required string PortfId = 1;
inline bool ModifyStrategyParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyStrategyParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyStrategyParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyStrategyParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyStrategyParam::portfid() const {
  return *portfid_;
}
inline void ModifyStrategyParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyStrategyParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyStrategyParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyStrategyParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StrategyName = 2;
inline bool ModifyStrategyParam::has_strategyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyStrategyParam::set_has_strategyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyStrategyParam::clear_has_strategyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyStrategyParam::clear_strategyname() {
  if (strategyname_ != &::google::protobuf::internal::kEmptyString) {
    strategyname_->clear();
  }
  clear_has_strategyname();
}
inline const ::std::string& ModifyStrategyParam::strategyname() const {
  return *strategyname_;
}
inline void ModifyStrategyParam::set_strategyname(const ::std::string& value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void ModifyStrategyParam::set_strategyname(const char* value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void ModifyStrategyParam::set_strategyname(const char* value, size_t size) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_strategyname() {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  return strategyname_;
}
inline ::std::string* ModifyStrategyParam::release_strategyname() {
  clear_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategyname_;
    strategyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes StrategyData = 3;
inline bool ModifyStrategyParam::has_strategydata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyStrategyParam::set_has_strategydata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyStrategyParam::clear_has_strategydata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyStrategyParam::clear_strategydata() {
  if (strategydata_ != &::google::protobuf::internal::kEmptyString) {
    strategydata_->clear();
  }
  clear_has_strategydata();
}
inline const ::std::string& ModifyStrategyParam::strategydata() const {
  return *strategydata_;
}
inline void ModifyStrategyParam::set_strategydata(const ::std::string& value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void ModifyStrategyParam::set_strategydata(const char* value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void ModifyStrategyParam::set_strategydata(const void* value, size_t size) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_strategydata() {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  return strategydata_;
}
inline ::std::string* ModifyStrategyParam::release_strategydata() {
  clear_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategydata_;
    strategydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ModifyPortfolioSwitchParam

// required string PortfId = 1;
inline bool ModifyPortfolioSwitchParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyPortfolioSwitchParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyPortfolioSwitchParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyPortfolioSwitchParam::portfid() const {
  return *portfid_;
}
inline void ModifyPortfolioSwitchParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioSwitchParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioSwitchParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioSwitchParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyPortfolioSwitchParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool AutoOpen = 2;
inline bool ModifyPortfolioSwitchParam::has_autoopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autoopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autoopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyPortfolioSwitchParam::clear_autoopen() {
  autoopen_ = false;
  clear_has_autoopen();
}
inline bool ModifyPortfolioSwitchParam::autoopen() const {
  return autoopen_;
}
inline void ModifyPortfolioSwitchParam::set_autoopen(bool value) {
  set_has_autoopen();
  autoopen_ = value;
}

// required bool AutoStopGain = 3;
inline bool ModifyPortfolioSwitchParam::has_autostopgain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autostopgain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autostopgain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyPortfolioSwitchParam::clear_autostopgain() {
  autostopgain_ = false;
  clear_has_autostopgain();
}
inline bool ModifyPortfolioSwitchParam::autostopgain() const {
  return autostopgain_;
}
inline void ModifyPortfolioSwitchParam::set_autostopgain(bool value) {
  set_has_autostopgain();
  autostopgain_ = value;
}

// required bool AutoStopLoss = 4;
inline bool ModifyPortfolioSwitchParam::has_autostoploss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autostoploss() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autostoploss() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyPortfolioSwitchParam::clear_autostoploss() {
  autostoploss_ = false;
  clear_has_autostoploss();
}
inline bool ModifyPortfolioSwitchParam::autostoploss() const {
  return autostoploss_;
}
inline void ModifyPortfolioSwitchParam::set_autostoploss(bool value) {
  set_has_autostoploss();
  autostoploss_ = value;
}

// -------------------------------------------------------------------

// ModifyRunningStatusParam

// required string PortfId = 1;
inline bool ModifyRunningStatusParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyRunningStatusParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyRunningStatusParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyRunningStatusParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyRunningStatusParam::portfid() const {
  return *portfid_;
}
inline void ModifyRunningStatusParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyRunningStatusParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyRunningStatusParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRunningStatusParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyRunningStatusParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool Enabled = 2;
inline bool ModifyRunningStatusParam::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyRunningStatusParam::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyRunningStatusParam::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyRunningStatusParam::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ModifyRunningStatusParam::enabled() const {
  return enabled_;
}
inline void ModifyRunningStatusParam::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// ModifyPortfolioPreferredLegParam

// required string PortfId = 1;
inline bool ModifyPortfolioPreferredLegParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyPortfolioPreferredLegParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyPortfolioPreferredLegParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyPortfolioPreferredLegParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyPortfolioPreferredLegParam::portfid() const {
  return *portfid_;
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioPreferredLegParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyPortfolioPreferredLegParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string LegSymbol = 2;
inline bool ModifyPortfolioPreferredLegParam::has_legsymbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyPortfolioPreferredLegParam::set_has_legsymbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyPortfolioPreferredLegParam::clear_has_legsymbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyPortfolioPreferredLegParam::clear_legsymbol() {
  if (legsymbol_ != &::google::protobuf::internal::kEmptyString) {
    legsymbol_->clear();
  }
  clear_has_legsymbol();
}
inline const ::std::string& ModifyPortfolioPreferredLegParam::legsymbol() const {
  return *legsymbol_;
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const ::std::string& value) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const char* value) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const char* value, size_t size) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioPreferredLegParam::mutable_legsymbol() {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  return legsymbol_;
}
inline ::std::string* ModifyPortfolioPreferredLegParam::release_legsymbol() {
  clear_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legsymbol_;
    legsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace entity

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
