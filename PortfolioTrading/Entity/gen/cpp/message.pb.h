// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "enum.pb.h"
// @@protoc_insertion_point(includes)

namespace entity {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class StringParam;
class IntParam;
class LegItem;
class PortfolioItem;
class ConnectParam;
class OperationReturn;
class LoginParam;
class RegQuoteParam;
class PorfOpenPosiParam;
class ClosePositionParam;

// ===================================================================

class StringParam : public ::google::protobuf::Message {
 public:
  StringParam();
  virtual ~StringParam();
  
  StringParam(const StringParam& from);
  
  inline StringParam& operator=(const StringParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringParam& default_instance();
  
  void Swap(StringParam* other);
  
  // implements Message ----------------------------------------------
  
  StringParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringParam& from);
  void MergeFrom(const StringParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:entity.StringParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static StringParam* default_instance_;
};
// -------------------------------------------------------------------

class IntParam : public ::google::protobuf::Message {
 public:
  IntParam();
  virtual ~IntParam();
  
  IntParam(const IntParam& from);
  
  inline IntParam& operator=(const IntParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntParam& default_instance();
  
  void Swap(IntParam* other);
  
  // implements Message ----------------------------------------------
  
  IntParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntParam& from);
  void MergeFrom(const IntParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.IntParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static IntParam* default_instance_;
};
// -------------------------------------------------------------------

class LegItem : public ::google::protobuf::Message {
 public:
  LegItem();
  virtual ~LegItem();
  
  LegItem(const LegItem& from);
  
  inline LegItem& operator=(const LegItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegItem& default_instance();
  
  void Swap(LegItem* other);
  
  // implements Message ----------------------------------------------
  
  LegItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegItem& from);
  void MergeFrom(const LegItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required int32 Ratio = 2;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 2;
  inline ::google::protobuf::int32 ratio() const;
  inline void set_ratio(::google::protobuf::int32 value);
  
  // required .entity.PosiDirectionType Side = 3;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 3;
  inline entity::PosiDirectionType side() const;
  inline void set_side(entity::PosiDirectionType value);
  
  // required .entity.LegStatus Status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline entity::LegStatus status() const;
  inline void set_status(entity::LegStatus value);
  
  // required double Last = 5;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 5;
  inline double last() const;
  inline void set_last(double value);
  
  // required double Ask = 6;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 6;
  inline double ask() const;
  inline void set_ask(double value);
  
  // required double Bid = 7;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 7;
  inline double bid() const;
  inline void set_bid(double value);
  
  // @@protoc_insertion_point(class_scope:entity.LegItem)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_ratio();
  inline void clear_has_ratio();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_bid();
  inline void clear_has_bid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  ::google::protobuf::int32 ratio_;
  int side_;
  double last_;
  double ask_;
  double bid_;
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegItem* default_instance_;
};
// -------------------------------------------------------------------

class PortfolioItem : public ::google::protobuf::Message {
 public:
  PortfolioItem();
  virtual ~PortfolioItem();
  
  PortfolioItem(const PortfolioItem& from);
  
  inline PortfolioItem& operator=(const PortfolioItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortfolioItem& default_instance();
  
  void Swap(PortfolioItem* other);
  
  // implements Message ----------------------------------------------
  
  PortfolioItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortfolioItem& from);
  void MergeFrom(const PortfolioItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // required double Diff = 3;
  inline bool has_diff() const;
  inline void clear_diff();
  static const int kDiffFieldNumber = 3;
  inline double diff() const;
  inline void set_diff(double value);
  
  // required bool AutoOpen = 4;
  inline bool has_autoopen() const;
  inline void clear_autoopen();
  static const int kAutoOpenFieldNumber = 4;
  inline bool autoopen() const;
  inline void set_autoopen(bool value);
  
  // required bool AutoClose = 5;
  inline bool has_autoclose() const;
  inline void clear_autoclose();
  static const int kAutoCloseFieldNumber = 5;
  inline bool autoclose() const;
  inline void set_autoclose(bool value);
  
  // repeated .entity.LegItem Legs = 6;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 6;
  inline const ::entity::LegItem& legs(int index) const;
  inline ::entity::LegItem* mutable_legs(int index);
  inline ::entity::LegItem* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
      mutable_legs();
  
  // @@protoc_insertion_point(class_scope:entity.PortfolioItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_diff();
  inline void clear_has_diff();
  inline void set_has_autoopen();
  inline void clear_has_autoopen();
  inline void set_has_autoclose();
  inline void clear_has_autoclose();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  double diff_;
  ::google::protobuf::int32 quantity_;
  bool autoopen_;
  bool autoclose_;
  ::google::protobuf::RepeatedPtrField< ::entity::LegItem > legs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PortfolioItem* default_instance_;
};
// -------------------------------------------------------------------

class ConnectParam : public ::google::protobuf::Message {
 public:
  ConnectParam();
  virtual ~ConnectParam();
  
  ConnectParam(const ConnectParam& from);
  
  inline ConnectParam& operator=(const ConnectParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectParam& default_instance();
  
  void Swap(ConnectParam* other);
  
  // implements Message ----------------------------------------------
  
  ConnectParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectParam& from);
  void MergeFrom(const ConnectParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string QuoteAddress = 1;
  inline bool has_quoteaddress() const;
  inline void clear_quoteaddress();
  static const int kQuoteAddressFieldNumber = 1;
  inline const ::std::string& quoteaddress() const;
  inline void set_quoteaddress(const ::std::string& value);
  inline void set_quoteaddress(const char* value);
  inline void set_quoteaddress(const char* value, size_t size);
  inline ::std::string* mutable_quoteaddress();
  inline ::std::string* release_quoteaddress();
  
  // required string StreamFolder = 2;
  inline bool has_streamfolder() const;
  inline void clear_streamfolder();
  static const int kStreamFolderFieldNumber = 2;
  inline const ::std::string& streamfolder() const;
  inline void set_streamfolder(const ::std::string& value);
  inline void set_streamfolder(const char* value);
  inline void set_streamfolder(const char* value, size_t size);
  inline ::std::string* mutable_streamfolder();
  inline ::std::string* release_streamfolder();
  
  // @@protoc_insertion_point(class_scope:entity.ConnectParam)
 private:
  inline void set_has_quoteaddress();
  inline void clear_has_quoteaddress();
  inline void set_has_streamfolder();
  inline void clear_has_streamfolder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* quoteaddress_;
  ::std::string* streamfolder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ConnectParam* default_instance_;
};
// -------------------------------------------------------------------

class OperationReturn : public ::google::protobuf::Message {
 public:
  OperationReturn();
  virtual ~OperationReturn();
  
  OperationReturn(const OperationReturn& from);
  
  inline OperationReturn& operator=(const OperationReturn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationReturn& default_instance();
  
  void Swap(OperationReturn* other);
  
  // implements Message ----------------------------------------------
  
  OperationReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationReturn& from);
  void MergeFrom(const OperationReturn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool Success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string ErrorMessage = 2;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:entity.OperationReturn)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormessage_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static OperationReturn* default_instance_;
};
// -------------------------------------------------------------------

class LoginParam : public ::google::protobuf::Message {
 public:
  LoginParam();
  virtual ~LoginParam();
  
  LoginParam(const LoginParam& from);
  
  inline LoginParam& operator=(const LoginParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginParam& default_instance();
  
  void Swap(LoginParam* other);
  
  // implements Message ----------------------------------------------
  
  LoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginParam& from);
  void MergeFrom(const LoginParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerId = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIdFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string UserId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:entity.LoginParam)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* userid_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginParam* default_instance_;
};
// -------------------------------------------------------------------

class RegQuoteParam : public ::google::protobuf::Message {
 public:
  RegQuoteParam();
  virtual ~RegQuoteParam();
  
  RegQuoteParam(const RegQuoteParam& from);
  
  inline RegQuoteParam& operator=(const RegQuoteParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegQuoteParam& default_instance();
  
  void Swap(RegQuoteParam* other);
  
  // implements Message ----------------------------------------------
  
  RegQuoteParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegQuoteParam& from);
  void MergeFrom(const RegQuoteParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string Symbols = 1;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 1;
  inline const ::std::string& symbols(int index) const;
  inline ::std::string* mutable_symbols(int index);
  inline void set_symbols(int index, const ::std::string& value);
  inline void set_symbols(int index, const char* value);
  inline void set_symbols(int index, const char* value, size_t size);
  inline ::std::string* add_symbols();
  inline void add_symbols(const ::std::string& value);
  inline void add_symbols(const char* value);
  inline void add_symbols(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_symbols();
  
  // @@protoc_insertion_point(class_scope:entity.RegQuoteParam)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> symbols_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static RegQuoteParam* default_instance_;
};
// -------------------------------------------------------------------

class PorfOpenPosiParam : public ::google::protobuf::Message {
 public:
  PorfOpenPosiParam();
  virtual ~PorfOpenPosiParam();
  
  PorfOpenPosiParam(const PorfOpenPosiParam& from);
  
  inline PorfOpenPosiParam& operator=(const PorfOpenPosiParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PorfOpenPosiParam& default_instance();
  
  void Swap(PorfOpenPosiParam* other);
  
  // implements Message ----------------------------------------------
  
  PorfOpenPosiParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PorfOpenPosiParam& from);
  void MergeFrom(const PorfOpenPosiParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.PorfOpenPosiParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::google::protobuf::int32 quantity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PorfOpenPosiParam* default_instance_;
};
// -------------------------------------------------------------------

class ClosePositionParam : public ::google::protobuf::Message {
 public:
  ClosePositionParam();
  virtual ~ClosePositionParam();
  
  ClosePositionParam(const ClosePositionParam& from);
  
  inline ClosePositionParam& operator=(const ClosePositionParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClosePositionParam& default_instance();
  
  void Swap(ClosePositionParam* other);
  
  // implements Message ----------------------------------------------
  
  ClosePositionParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClosePositionParam& from);
  void MergeFrom(const ClosePositionParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string MultiLegOrderId = 1;
  inline bool has_multilegorderid() const;
  inline void clear_multilegorderid();
  static const int kMultiLegOrderIdFieldNumber = 1;
  inline const ::std::string& multilegorderid() const;
  inline void set_multilegorderid(const ::std::string& value);
  inline void set_multilegorderid(const char* value);
  inline void set_multilegorderid(const char* value, size_t size);
  inline ::std::string* mutable_multilegorderid();
  inline ::std::string* release_multilegorderid();
  
  // optional string LegOrdRef = 2;
  inline bool has_legordref() const;
  inline void clear_legordref();
  static const int kLegOrdRefFieldNumber = 2;
  inline const ::std::string& legordref() const;
  inline void set_legordref(const ::std::string& value);
  inline void set_legordref(const char* value);
  inline void set_legordref(const char* value, size_t size);
  inline ::std::string* mutable_legordref();
  inline ::std::string* release_legordref();
  
  // @@protoc_insertion_point(class_scope:entity.ClosePositionParam)
 private:
  inline void set_has_multilegorderid();
  inline void clear_has_multilegorderid();
  inline void set_has_legordref();
  inline void clear_has_legordref();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* multilegorderid_;
  ::std::string* legordref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ClosePositionParam* default_instance_;
};
// ===================================================================


// ===================================================================

// StringParam

// required string Data = 1;
inline bool StringParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringParam::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& StringParam::data() const {
  return *data_;
}
inline void StringParam::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringParam::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* StringParam::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IntParam

// required int32 Data = 2;
inline bool IntParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntParam::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 IntParam::data() const {
  return data_;
}
inline void IntParam::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// -------------------------------------------------------------------

// LegItem

// required string Symbol = 1;
inline bool LegItem::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegItem::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegItem::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegItem::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& LegItem::symbol() const {
  return *symbol_;
}
inline void LegItem::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegItem::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* LegItem::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Ratio = 2;
inline bool LegItem::has_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegItem::set_has_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegItem::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegItem::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline ::google::protobuf::int32 LegItem::ratio() const {
  return ratio_;
}
inline void LegItem::set_ratio(::google::protobuf::int32 value) {
  set_has_ratio();
  ratio_ = value;
}

// required .entity.PosiDirectionType Side = 3;
inline bool LegItem::has_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegItem::set_has_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegItem::clear_has_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegItem::clear_side() {
  side_ = 49;
  clear_has_side();
}
inline entity::PosiDirectionType LegItem::side() const {
  return static_cast< entity::PosiDirectionType >(side_);
}
inline void LegItem::set_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_side();
  side_ = value;
}

// required .entity.LegStatus Status = 4;
inline bool LegItem::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegItem::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegItem::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline entity::LegStatus LegItem::status() const {
  return static_cast< entity::LegStatus >(status_);
}
inline void LegItem::set_status(entity::LegStatus value) {
  GOOGLE_DCHECK(entity::LegStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required double Last = 5;
inline bool LegItem::has_last() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegItem::set_has_last() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegItem::clear_has_last() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegItem::clear_last() {
  last_ = 0;
  clear_has_last();
}
inline double LegItem::last() const {
  return last_;
}
inline void LegItem::set_last(double value) {
  set_has_last();
  last_ = value;
}

// required double Ask = 6;
inline bool LegItem::has_ask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LegItem::set_has_ask() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LegItem::clear_has_ask() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LegItem::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline double LegItem::ask() const {
  return ask_;
}
inline void LegItem::set_ask(double value) {
  set_has_ask();
  ask_ = value;
}

// required double Bid = 7;
inline bool LegItem::has_bid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LegItem::set_has_bid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LegItem::clear_has_bid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LegItem::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline double LegItem::bid() const {
  return bid_;
}
inline void LegItem::set_bid(double value) {
  set_has_bid();
  bid_ = value;
}

// -------------------------------------------------------------------

// PortfolioItem

// required string ID = 1;
inline bool PortfolioItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortfolioItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortfolioItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortfolioItem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PortfolioItem::id() const {
  return *id_;
}
inline void PortfolioItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PortfolioItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PortfolioItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortfolioItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortfolioItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortfolioItem::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PortfolioItem::quantity() const {
  return quantity_;
}
inline void PortfolioItem::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required double Diff = 3;
inline bool PortfolioItem::has_diff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortfolioItem::set_has_diff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortfolioItem::clear_has_diff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortfolioItem::clear_diff() {
  diff_ = 0;
  clear_has_diff();
}
inline double PortfolioItem::diff() const {
  return diff_;
}
inline void PortfolioItem::set_diff(double value) {
  set_has_diff();
  diff_ = value;
}

// required bool AutoOpen = 4;
inline bool PortfolioItem::has_autoopen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortfolioItem::set_has_autoopen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortfolioItem::clear_has_autoopen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortfolioItem::clear_autoopen() {
  autoopen_ = false;
  clear_has_autoopen();
}
inline bool PortfolioItem::autoopen() const {
  return autoopen_;
}
inline void PortfolioItem::set_autoopen(bool value) {
  set_has_autoopen();
  autoopen_ = value;
}

// required bool AutoClose = 5;
inline bool PortfolioItem::has_autoclose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PortfolioItem::set_has_autoclose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PortfolioItem::clear_has_autoclose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PortfolioItem::clear_autoclose() {
  autoclose_ = false;
  clear_has_autoclose();
}
inline bool PortfolioItem::autoclose() const {
  return autoclose_;
}
inline void PortfolioItem::set_autoclose(bool value) {
  set_has_autoclose();
  autoclose_ = value;
}

// repeated .entity.LegItem Legs = 6;
inline int PortfolioItem::legs_size() const {
  return legs_.size();
}
inline void PortfolioItem::clear_legs() {
  legs_.Clear();
}
inline const ::entity::LegItem& PortfolioItem::legs(int index) const {
  return legs_.Get(index);
}
inline ::entity::LegItem* PortfolioItem::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::entity::LegItem* PortfolioItem::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
PortfolioItem::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
PortfolioItem::mutable_legs() {
  return &legs_;
}

// -------------------------------------------------------------------

// ConnectParam

// required string QuoteAddress = 1;
inline bool ConnectParam::has_quoteaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectParam::set_has_quoteaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectParam::clear_has_quoteaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectParam::clear_quoteaddress() {
  if (quoteaddress_ != &::google::protobuf::internal::kEmptyString) {
    quoteaddress_->clear();
  }
  clear_has_quoteaddress();
}
inline const ::std::string& ConnectParam::quoteaddress() const {
  return *quoteaddress_;
}
inline void ConnectParam::set_quoteaddress(const ::std::string& value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value, size_t size) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_quoteaddress() {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  return quoteaddress_;
}
inline ::std::string* ConnectParam::release_quoteaddress() {
  clear_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quoteaddress_;
    quoteaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StreamFolder = 2;
inline bool ConnectParam::has_streamfolder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectParam::set_has_streamfolder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectParam::clear_has_streamfolder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectParam::clear_streamfolder() {
  if (streamfolder_ != &::google::protobuf::internal::kEmptyString) {
    streamfolder_->clear();
  }
  clear_has_streamfolder();
}
inline const ::std::string& ConnectParam::streamfolder() const {
  return *streamfolder_;
}
inline void ConnectParam::set_streamfolder(const ::std::string& value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value, size_t size) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_streamfolder() {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  return streamfolder_;
}
inline ::std::string* ConnectParam::release_streamfolder() {
  clear_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamfolder_;
    streamfolder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OperationReturn

// required bool Success = 1;
inline bool OperationReturn::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationReturn::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationReturn::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationReturn::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool OperationReturn::success() const {
  return success_;
}
inline void OperationReturn::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string ErrorMessage = 2;
inline bool OperationReturn::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationReturn::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationReturn::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationReturn::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& OperationReturn::errormessage() const {
  return *errormessage_;
}
inline void OperationReturn::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationReturn::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* OperationReturn::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginParam

// required string BrokerId = 1;
inline bool LoginParam::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginParam::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginParam::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginParam::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& LoginParam::brokerid() const {
  return *brokerid_;
}
inline void LoginParam::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* LoginParam::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 2;
inline bool LoginParam::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginParam::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginParam::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginParam::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LoginParam::userid() const {
  return *userid_;
}
inline void LoginParam::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LoginParam::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 3;
inline bool LoginParam::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginParam::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginParam::password() const {
  return *password_;
}
inline void LoginParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RegQuoteParam

// repeated string Symbols = 1;
inline int RegQuoteParam::symbols_size() const {
  return symbols_.size();
}
inline void RegQuoteParam::clear_symbols() {
  symbols_.Clear();
}
inline const ::std::string& RegQuoteParam::symbols(int index) const {
  return symbols_.Get(index);
}
inline ::std::string* RegQuoteParam::mutable_symbols(int index) {
  return symbols_.Mutable(index);
}
inline void RegQuoteParam::set_symbols(int index, const ::std::string& value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value, size_t size) {
  symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegQuoteParam::add_symbols() {
  return symbols_.Add();
}
inline void RegQuoteParam::add_symbols(const ::std::string& value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value, size_t size) {
  symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegQuoteParam::symbols() const {
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegQuoteParam::mutable_symbols() {
  return &symbols_;
}

// -------------------------------------------------------------------

// PorfOpenPosiParam

// required string PortfId = 1;
inline bool PorfOpenPosiParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PorfOpenPosiParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PorfOpenPosiParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PorfOpenPosiParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& PorfOpenPosiParam::portfid() const {
  return *portfid_;
}
inline void PorfOpenPosiParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PorfOpenPosiParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* PorfOpenPosiParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PorfOpenPosiParam::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PorfOpenPosiParam::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PorfOpenPosiParam::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PorfOpenPosiParam::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PorfOpenPosiParam::quantity() const {
  return quantity_;
}
inline void PorfOpenPosiParam::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// ClosePositionParam

// required string MultiLegOrderId = 1;
inline bool ClosePositionParam::has_multilegorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClosePositionParam::set_has_multilegorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClosePositionParam::clear_has_multilegorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClosePositionParam::clear_multilegorderid() {
  if (multilegorderid_ != &::google::protobuf::internal::kEmptyString) {
    multilegorderid_->clear();
  }
  clear_has_multilegorderid();
}
inline const ::std::string& ClosePositionParam::multilegorderid() const {
  return *multilegorderid_;
}
inline void ClosePositionParam::set_multilegorderid(const ::std::string& value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void ClosePositionParam::set_multilegorderid(const char* value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void ClosePositionParam::set_multilegorderid(const char* value, size_t size) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClosePositionParam::mutable_multilegorderid() {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  return multilegorderid_;
}
inline ::std::string* ClosePositionParam::release_multilegorderid() {
  clear_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multilegorderid_;
    multilegorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string LegOrdRef = 2;
inline bool ClosePositionParam::has_legordref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClosePositionParam::set_has_legordref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClosePositionParam::clear_has_legordref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClosePositionParam::clear_legordref() {
  if (legordref_ != &::google::protobuf::internal::kEmptyString) {
    legordref_->clear();
  }
  clear_has_legordref();
}
inline const ::std::string& ClosePositionParam::legordref() const {
  return *legordref_;
}
inline void ClosePositionParam::set_legordref(const ::std::string& value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value, size_t size) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClosePositionParam::mutable_legordref() {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  return legordref_;
}
inline ::std::string* ClosePositionParam::release_legordref() {
  clear_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legordref_;
    legordref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace entity

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
