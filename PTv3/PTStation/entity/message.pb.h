// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "enum.pb.h"
#include "trade.pb.h"
// @@protoc_insertion_point(includes)

namespace entity {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class LoginPuzzleResponse;
class LoginRequest;
class LoginResponse;
class HeartbeatRequest;
class HeartbeatResponse;
class ServerLoginRequest;
class ServerLoginResponse;
class ServerLogoutRequest;
class AddPortfolioRequest;
class SwitchPortfolioRequest;
class ApplyStrategySettingsRequest;
class StringParam;
class IntParam;
class LegItem;
class LegUpdateItem;
class HistSourceCfg;
class StrategyItem;
class TriggerItem;
class TriggerStatus;
class PortfolioItem;
class PortfolioUpdateItem;
class ConnectParam;
class OperationReturn;
class AccountSettings;
class LoginParam;
class RegQuoteParam;
class AddPortfolioParam;
class PorfOpenPosiParam;
class ClosePositionParam;
class LegOrderUpdateParam;
class ArbitrageStrategySettings;
class ChangePosiStrategySettings;
class ScalperSettings;
class ModifyStrategyParam;
class ModifyPortfolioSwitchParam;
class ModifyPortfolioQtyParam;
class ModifyRunningStatusParam;
class ModifyPortfolioPreferredLegParam;
class CancelOrderParam;
class ManualCloseOrderParam;
class SymbolInfo;

enum ServerType {
  SERV_QUOTE = 0,
  SERV_TRADE = 1
};
bool ServerType_IsValid(int value);
const ServerType ServerType_MIN = SERV_QUOTE;
const ServerType ServerType_MAX = SERV_TRADE;
const int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServerType_descriptor();
inline const ::std::string& ServerType_Name(ServerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServerType_descriptor(), value);
}
inline bool ServerType_Parse(
    const ::std::string& name, ServerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum PortfolioSwitchType {
  STRATEGY_SWITCH = 0,
  TRIGGER_SWITCH = 1
};
bool PortfolioSwitchType_IsValid(int value);
const PortfolioSwitchType PortfolioSwitchType_MIN = STRATEGY_SWITCH;
const PortfolioSwitchType PortfolioSwitchType_MAX = TRIGGER_SWITCH;
const int PortfolioSwitchType_ARRAYSIZE = PortfolioSwitchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PortfolioSwitchType_descriptor();
inline const ::std::string& PortfolioSwitchType_Name(PortfolioSwitchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PortfolioSwitchType_descriptor(), value);
}
inline bool PortfolioSwitchType_Parse(
    const ::std::string& name, PortfolioSwitchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PortfolioSwitchType>(
    PortfolioSwitchType_descriptor(), name, value);
}
enum StrategyType {
  ARBITRAGE = 0,
  CHANGE_POSITION = 1,
  SCALPER = 2,
  HIST_SLOPE = 3
};
bool StrategyType_IsValid(int value);
const StrategyType StrategyType_MIN = ARBITRAGE;
const StrategyType StrategyType_MAX = HIST_SLOPE;
const int StrategyType_ARRAYSIZE = StrategyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrategyType_descriptor();
inline const ::std::string& StrategyType_Name(StrategyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrategyType_descriptor(), value);
}
inline bool StrategyType_Parse(
    const ::std::string& name, StrategyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrategyType>(
    StrategyType_descriptor(), name, value);
}
enum SlopeDirection {
  NO_DIRECTION = 0,
  GOING_UP = 1,
  GOING_DOWN = 2
};
bool SlopeDirection_IsValid(int value);
const SlopeDirection SlopeDirection_MIN = NO_DIRECTION;
const SlopeDirection SlopeDirection_MAX = GOING_DOWN;
const int SlopeDirection_ARRAYSIZE = SlopeDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* SlopeDirection_descriptor();
inline const ::std::string& SlopeDirection_Name(SlopeDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    SlopeDirection_descriptor(), value);
}
inline bool SlopeDirection_Parse(
    const ::std::string& name, SlopeDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SlopeDirection>(
    SlopeDirection_descriptor(), name, value);
}
enum DirectionDepends {
  IGNORE_THIS = 0,
  ON_SMALL_SIZE = 1,
  ON_BIG_SIZE = 2,
  ON_SMALL_CHANGE = 3,
  ON_BIG_CHANGE = 4
};
bool DirectionDepends_IsValid(int value);
const DirectionDepends DirectionDepends_MIN = IGNORE_THIS;
const DirectionDepends DirectionDepends_MAX = ON_BIG_CHANGE;
const int DirectionDepends_ARRAYSIZE = DirectionDepends_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectionDepends_descriptor();
inline const ::std::string& DirectionDepends_Name(DirectionDepends value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectionDepends_descriptor(), value);
}
inline bool DirectionDepends_Parse(
    const ::std::string& name, DirectionDepends* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectionDepends>(
    DirectionDepends_descriptor(), name, value);
}
enum StopLossCloseMethods {
  BASED_ON_NEXT_QUOTE = 0,
  BASED_ON_INPUT_LIMIT = 1
};
bool StopLossCloseMethods_IsValid(int value);
const StopLossCloseMethods StopLossCloseMethods_MIN = BASED_ON_NEXT_QUOTE;
const StopLossCloseMethods StopLossCloseMethods_MAX = BASED_ON_INPUT_LIMIT;
const int StopLossCloseMethods_ARRAYSIZE = StopLossCloseMethods_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopLossCloseMethods_descriptor();
inline const ::std::string& StopLossCloseMethods_Name(StopLossCloseMethods value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopLossCloseMethods_descriptor(), value);
}
inline bool StopLossCloseMethods_Parse(
    const ::std::string& name, StopLossCloseMethods* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopLossCloseMethods>(
    StopLossCloseMethods_descriptor(), name, value);
}
// ===================================================================

class LoginPuzzleResponse : public ::google::protobuf::Message {
 public:
  LoginPuzzleResponse();
  virtual ~LoginPuzzleResponse();
  
  LoginPuzzleResponse(const LoginPuzzleResponse& from);
  
  inline LoginPuzzleResponse& operator=(const LoginPuzzleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginPuzzleResponse& default_instance();
  
  void Swap(LoginPuzzleResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginPuzzleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginPuzzleResponse& from);
  void MergeFrom(const LoginPuzzleResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // @@protoc_insertion_point(class_scope:entity.LoginPuzzleResponse)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginPuzzleResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool is_new = 1;
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 1;
  inline bool is_new() const;
  inline void set_is_new(bool value);
  
  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // required string previous_session_id = 3;
  inline bool has_previous_session_id() const;
  inline void clear_previous_session_id();
  static const int kPreviousSessionIdFieldNumber = 3;
  inline const ::std::string& previous_session_id() const;
  inline void set_previous_session_id(const ::std::string& value);
  inline void set_previous_session_id(const char* value);
  inline void set_previous_session_id(const char* value, size_t size);
  inline ::std::string* mutable_previous_session_id();
  inline ::std::string* release_previous_session_id();
  
  // optional string pseudo = 4;
  inline bool has_pseudo() const;
  inline void clear_pseudo();
  static const int kPseudoFieldNumber = 4;
  inline const ::std::string& pseudo() const;
  inline void set_pseudo(const ::std::string& value);
  inline void set_pseudo(const char* value);
  inline void set_pseudo(const char* value, size_t size);
  inline ::std::string* mutable_pseudo();
  inline ::std::string* release_pseudo();
  
  // @@protoc_insertion_point(class_scope:entity.LoginRequest)
 private:
  inline void set_has_is_new();
  inline void clear_has_is_new();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_previous_session_id();
  inline void clear_has_previous_session_id();
  inline void set_has_pseudo();
  inline void clear_has_pseudo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::std::string* previous_session_id_;
  ::std::string* pseudo_;
  bool is_new_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool accepted = 1;
  inline bool has_accepted() const;
  inline void clear_accepted();
  static const int kAcceptedFieldNumber = 1;
  inline bool accepted() const;
  inline void set_accepted(bool value);
  
  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // required bool is_new = 3;
  inline bool has_is_new() const;
  inline void clear_is_new();
  static const int kIsNewFieldNumber = 3;
  inline bool is_new() const;
  inline void set_is_new(bool value);
  
  // required string error_msg = 4;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 4;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // @@protoc_insertion_point(class_scope:entity.LoginResponse)
 private:
  inline void set_has_accepted();
  inline void clear_has_accepted();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_is_new();
  inline void clear_has_is_new();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::std::string* error_msg_;
  bool accepted_;
  bool is_new_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();
  
  HeartbeatRequest(const HeartbeatRequest& from);
  
  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();
  
  void Swap(HeartbeatRequest* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:entity.HeartbeatRequest)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static HeartbeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();
  
  HeartbeatResponse(const HeartbeatResponse& from);
  
  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();
  
  void Swap(HeartbeatResponse* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:entity.HeartbeatResponse)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static HeartbeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerLoginRequest : public ::google::protobuf::Message {
 public:
  ServerLoginRequest();
  virtual ~ServerLoginRequest();
  
  ServerLoginRequest(const ServerLoginRequest& from);
  
  inline ServerLoginRequest& operator=(const ServerLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerLoginRequest& default_instance();
  
  void Swap(ServerLoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  ServerLoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerLoginRequest& from);
  void MergeFrom(const ServerLoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.ServerType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline entity::ServerType type() const;
  inline void set_type(entity::ServerType value);
  
  // required string Address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // required string BrokerId = 3;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIdFieldNumber = 3;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string UserId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string Password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:entity.ServerLoginRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* address_;
  ::std::string* brokerid_;
  ::std::string* userid_;
  ::std::string* password_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ServerLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerLoginResponse : public ::google::protobuf::Message {
 public:
  ServerLoginResponse();
  virtual ~ServerLoginResponse();
  
  ServerLoginResponse(const ServerLoginResponse& from);
  
  inline ServerLoginResponse& operator=(const ServerLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerLoginResponse& default_instance();
  
  void Swap(ServerLoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  ServerLoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerLoginResponse& from);
  void MergeFrom(const ServerLoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool Success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string ErrorMessage = 2;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // required .entity.ServerType Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline entity::ServerType type() const;
  inline void set_type(entity::ServerType value);
  
  // required string Address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // required string BrokerId = 5;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIdFieldNumber = 5;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string UserId = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 6;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // @@protoc_insertion_point(class_scope:entity.ServerLoginResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormessage_;
  bool success_;
  int type_;
  ::std::string* address_;
  ::std::string* brokerid_;
  ::std::string* userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ServerLoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerLogoutRequest : public ::google::protobuf::Message {
 public:
  ServerLogoutRequest();
  virtual ~ServerLogoutRequest();
  
  ServerLogoutRequest(const ServerLogoutRequest& from);
  
  inline ServerLogoutRequest& operator=(const ServerLogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerLogoutRequest& default_instance();
  
  void Swap(ServerLogoutRequest* other);
  
  // implements Message ----------------------------------------------
  
  ServerLogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerLogoutRequest& from);
  void MergeFrom(const ServerLogoutRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.ServerType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline entity::ServerType type() const;
  inline void set_type(entity::ServerType value);
  
  // @@protoc_insertion_point(class_scope:entity.ServerLogoutRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ServerLogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddPortfolioRequest : public ::google::protobuf::Message {
 public:
  AddPortfolioRequest();
  virtual ~AddPortfolioRequest();
  
  AddPortfolioRequest(const AddPortfolioRequest& from);
  
  inline AddPortfolioRequest& operator=(const AddPortfolioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddPortfolioRequest& default_instance();
  
  void Swap(AddPortfolioRequest* other);
  
  // implements Message ----------------------------------------------
  
  AddPortfolioRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddPortfolioRequest& from);
  void MergeFrom(const AddPortfolioRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .entity.PortfolioItem Portfolios = 1;
  inline int portfolios_size() const;
  inline void clear_portfolios();
  static const int kPortfoliosFieldNumber = 1;
  inline const ::entity::PortfolioItem& portfolios(int index) const;
  inline ::entity::PortfolioItem* mutable_portfolios(int index);
  inline ::entity::PortfolioItem* add_portfolios();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >&
      portfolios() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >*
      mutable_portfolios();
  
  // @@protoc_insertion_point(class_scope:entity.AddPortfolioRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem > portfolios_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static AddPortfolioRequest* default_instance_;
};
// -------------------------------------------------------------------

class SwitchPortfolioRequest : public ::google::protobuf::Message {
 public:
  SwitchPortfolioRequest();
  virtual ~SwitchPortfolioRequest();
  
  SwitchPortfolioRequest(const SwitchPortfolioRequest& from);
  
  inline SwitchPortfolioRequest& operator=(const SwitchPortfolioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchPortfolioRequest& default_instance();
  
  void Swap(SwitchPortfolioRequest* other);
  
  // implements Message ----------------------------------------------
  
  SwitchPortfolioRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwitchPortfolioRequest& from);
  void MergeFrom(const SwitchPortfolioRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PID = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPIDFieldNumber = 1;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  
  // required .entity.PortfolioSwitchType SwitchType = 2;
  inline bool has_switchtype() const;
  inline void clear_switchtype();
  static const int kSwitchTypeFieldNumber = 2;
  inline entity::PortfolioSwitchType switchtype() const;
  inline void set_switchtype(entity::PortfolioSwitchType value);
  
  // optional bool StartStrategy = 11;
  inline bool has_startstrategy() const;
  inline void clear_startstrategy();
  static const int kStartStrategyFieldNumber = 11;
  inline bool startstrategy() const;
  inline void set_startstrategy(bool value);
  
  // optional int32 LastOrderId = 12;
  inline bool has_lastorderid() const;
  inline void clear_lastorderid();
  static const int kLastOrderIdFieldNumber = 12;
  inline ::google::protobuf::int32 lastorderid() const;
  inline void set_lastorderid(::google::protobuf::int32 value);
  
  // optional int32 TriggerIndex = 21;
  inline bool has_triggerindex() const;
  inline void clear_triggerindex();
  static const int kTriggerIndexFieldNumber = 21;
  inline ::google::protobuf::int32 triggerindex() const;
  inline void set_triggerindex(::google::protobuf::int32 value);
  
  // optional bool EnableTrigger = 22;
  inline bool has_enabletrigger() const;
  inline void clear_enabletrigger();
  static const int kEnableTriggerFieldNumber = 22;
  inline bool enabletrigger() const;
  inline void set_enabletrigger(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.SwitchPortfolioRequest)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_switchtype();
  inline void clear_has_switchtype();
  inline void set_has_startstrategy();
  inline void clear_has_startstrategy();
  inline void set_has_lastorderid();
  inline void clear_has_lastorderid();
  inline void set_has_triggerindex();
  inline void clear_has_triggerindex();
  inline void set_has_enabletrigger();
  inline void clear_has_enabletrigger();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pid_;
  int switchtype_;
  ::google::protobuf::int32 lastorderid_;
  bool startstrategy_;
  bool enabletrigger_;
  ::google::protobuf::int32 triggerindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static SwitchPortfolioRequest* default_instance_;
};
// -------------------------------------------------------------------

class ApplyStrategySettingsRequest : public ::google::protobuf::Message {
 public:
  ApplyStrategySettingsRequest();
  virtual ~ApplyStrategySettingsRequest();
  
  ApplyStrategySettingsRequest(const ApplyStrategySettingsRequest& from);
  
  inline ApplyStrategySettingsRequest& operator=(const ApplyStrategySettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyStrategySettingsRequest& default_instance();
  
  void Swap(ApplyStrategySettingsRequest* other);
  
  // implements Message ----------------------------------------------
  
  ApplyStrategySettingsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplyStrategySettingsRequest& from);
  void MergeFrom(const ApplyStrategySettingsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PID = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPIDFieldNumber = 1;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  
  // required .entity.StrategyItem Strategy = 2;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 2;
  inline const ::entity::StrategyItem& strategy() const;
  inline ::entity::StrategyItem* mutable_strategy();
  inline ::entity::StrategyItem* release_strategy();
  
  // @@protoc_insertion_point(class_scope:entity.ApplyStrategySettingsRequest)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_strategy();
  inline void clear_has_strategy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pid_;
  ::entity::StrategyItem* strategy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ApplyStrategySettingsRequest* default_instance_;
};
// -------------------------------------------------------------------

class StringParam : public ::google::protobuf::Message {
 public:
  StringParam();
  virtual ~StringParam();
  
  StringParam(const StringParam& from);
  
  inline StringParam& operator=(const StringParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringParam& default_instance();
  
  void Swap(StringParam* other);
  
  // implements Message ----------------------------------------------
  
  StringParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringParam& from);
  void MergeFrom(const StringParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:entity.StringParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static StringParam* default_instance_;
};
// -------------------------------------------------------------------

class IntParam : public ::google::protobuf::Message {
 public:
  IntParam();
  virtual ~IntParam();
  
  IntParam(const IntParam& from);
  
  inline IntParam& operator=(const IntParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntParam& default_instance();
  
  void Swap(IntParam* other);
  
  // implements Message ----------------------------------------------
  
  IntParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntParam& from);
  void MergeFrom(const IntParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.IntParam)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static IntParam* default_instance_;
};
// -------------------------------------------------------------------

class LegItem : public ::google::protobuf::Message {
 public:
  LegItem();
  virtual ~LegItem();
  
  LegItem(const LegItem& from);
  
  inline LegItem& operator=(const LegItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegItem& default_instance();
  
  void Swap(LegItem* other);
  
  // implements Message ----------------------------------------------
  
  LegItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegItem& from);
  void MergeFrom(const LegItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 LegId = 1;
  inline bool has_legid() const;
  inline void clear_legid();
  static const int kLegIdFieldNumber = 1;
  inline ::google::protobuf::int32 legid() const;
  inline void set_legid(::google::protobuf::int32 value);
  
  // required string Symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required int32 Ratio = 3;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 3;
  inline ::google::protobuf::int32 ratio() const;
  inline void set_ratio(::google::protobuf::int32 value);
  
  // required .entity.PosiDirectionType Side = 4;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 4;
  inline entity::PosiDirectionType side() const;
  inline void set_side(entity::PosiDirectionType value);
  
  // required bool IsPreferred = 5;
  inline bool has_ispreferred() const;
  inline void clear_ispreferred();
  static const int kIsPreferredFieldNumber = 5;
  inline bool ispreferred() const;
  inline void set_ispreferred(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.LegItem)
 private:
  inline void set_has_legid();
  inline void clear_has_legid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_ratio();
  inline void clear_has_ratio();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_ispreferred();
  inline void clear_has_ispreferred();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  ::google::protobuf::int32 legid_;
  ::google::protobuf::int32 ratio_;
  int side_;
  bool ispreferred_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegItem* default_instance_;
};
// -------------------------------------------------------------------

class LegUpdateItem : public ::google::protobuf::Message {
 public:
  LegUpdateItem();
  virtual ~LegUpdateItem();
  
  LegUpdateItem(const LegUpdateItem& from);
  
  inline LegUpdateItem& operator=(const LegUpdateItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegUpdateItem& default_instance();
  
  void Swap(LegUpdateItem* other);
  
  // implements Message ----------------------------------------------
  
  LegUpdateItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegUpdateItem& from);
  void MergeFrom(const LegUpdateItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required .entity.LegStatus Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline entity::LegStatus status() const;
  inline void set_status(entity::LegStatus value);
  
  // required double Last = 3;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 3;
  inline double last() const;
  inline void set_last(double value);
  
  // required double Ask = 4;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 4;
  inline double ask() const;
  inline void set_ask(double value);
  
  // required int32 AskSize = 5;
  inline bool has_asksize() const;
  inline void clear_asksize();
  static const int kAskSizeFieldNumber = 5;
  inline ::google::protobuf::int32 asksize() const;
  inline void set_asksize(::google::protobuf::int32 value);
  
  // required double Bid = 6;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 6;
  inline double bid() const;
  inline void set_bid(double value);
  
  // required int32 BidSize = 7;
  inline bool has_bidsize() const;
  inline void clear_bidsize();
  static const int kBidSizeFieldNumber = 7;
  inline ::google::protobuf::int32 bidsize() const;
  inline void set_bidsize(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.LegUpdateItem)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_asksize();
  inline void clear_has_asksize();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_bidsize();
  inline void clear_has_bidsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  double last_;
  int status_;
  ::google::protobuf::int32 asksize_;
  double ask_;
  double bid_;
  ::google::protobuf::int32 bidsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegUpdateItem* default_instance_;
};
// -------------------------------------------------------------------

class HistSourceCfg : public ::google::protobuf::Message {
 public:
  HistSourceCfg();
  virtual ~HistSourceCfg();
  
  HistSourceCfg(const HistSourceCfg& from);
  
  inline HistSourceCfg& operator=(const HistSourceCfg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HistSourceCfg& default_instance();
  
  void Swap(HistSourceCfg* other);
  
  // implements Message ----------------------------------------------
  
  HistSourceCfg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistSourceCfg& from);
  void MergeFrom(const HistSourceCfg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required int32 Precision = 2;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.HistSourceCfg)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_precision();
  inline void clear_has_precision();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  ::google::protobuf::int32 precision_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static HistSourceCfg* default_instance_;
};
// -------------------------------------------------------------------

class StrategyItem : public ::google::protobuf::Message {
 public:
  StrategyItem();
  virtual ~StrategyItem();
  
  StrategyItem(const StrategyItem& from);
  
  inline StrategyItem& operator=(const StrategyItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyItem& default_instance();
  
  void Swap(StrategyItem* other);
  
  // implements Message ----------------------------------------------
  
  StrategyItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrategyItem& from);
  void MergeFrom(const StrategyItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.StrategyType Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline entity::StrategyType type() const;
  inline void set_type(entity::StrategyType value);
  
  // required int32 RetryTimes = 2;
  inline bool has_retrytimes() const;
  inline void clear_retrytimes();
  static const int kRetryTimesFieldNumber = 2;
  inline ::google::protobuf::int32 retrytimes() const;
  inline void set_retrytimes(::google::protobuf::int32 value);
  
  // required int32 OpenTimeout = 3;
  inline bool has_opentimeout() const;
  inline void clear_opentimeout();
  static const int kOpenTimeoutFieldNumber = 3;
  inline ::google::protobuf::int32 opentimeout() const;
  inline void set_opentimeout(::google::protobuf::int32 value);
  
  // repeated .entity.TriggerItem Triggers = 4;
  inline int triggers_size() const;
  inline void clear_triggers();
  static const int kTriggersFieldNumber = 4;
  inline const ::entity::TriggerItem& triggers(int index) const;
  inline ::entity::TriggerItem* mutable_triggers(int index);
  inline ::entity::TriggerItem* add_triggers();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::TriggerItem >&
      triggers() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::TriggerItem >*
      mutable_triggers();
  
  // optional .entity.PosiDirectionType AR_Side = 101;
  inline bool has_ar_side() const;
  inline void clear_ar_side();
  static const int kARSideFieldNumber = 101;
  inline entity::PosiDirectionType ar_side() const;
  inline void set_ar_side(entity::PosiDirectionType value);
  
  // optional string CP_CloseLeg = 201;
  inline bool has_cp_closeleg() const;
  inline void clear_cp_closeleg();
  static const int kCPCloseLegFieldNumber = 201;
  inline const ::std::string& cp_closeleg() const;
  inline void set_cp_closeleg(const ::std::string& value);
  inline void set_cp_closeleg(const char* value);
  inline void set_cp_closeleg(const char* value, size_t size);
  inline ::std::string* mutable_cp_closeleg();
  inline ::std::string* release_cp_closeleg();
  
  // optional .entity.PosiDirectionType CP_CloseLegSide = 202;
  inline bool has_cp_closelegside() const;
  inline void clear_cp_closelegside();
  static const int kCPCloseLegSideFieldNumber = 202;
  inline entity::PosiDirectionType cp_closelegside() const;
  inline void set_cp_closelegside(entity::PosiDirectionType value);
  
  // optional double SC_PriceTick = 301;
  inline bool has_sc_pricetick() const;
  inline void clear_sc_pricetick();
  static const int kSCPriceTickFieldNumber = 301;
  inline double sc_pricetick() const;
  inline void set_sc_pricetick(double value);
  
  // optional .entity.DirectionDepends SC_CaseLE2Tick = 302;
  inline bool has_sc_casele2tick() const;
  inline void clear_sc_casele2tick();
  static const int kSCCaseLE2TickFieldNumber = 302;
  inline entity::DirectionDepends sc_casele2tick() const;
  inline void set_sc_casele2tick(entity::DirectionDepends value);
  
  // optional .entity.DirectionDepends SC_CaseLE3Tick = 303;
  inline bool has_sc_casele3tick() const;
  inline void clear_sc_casele3tick();
  static const int kSCCaseLE3TickFieldNumber = 303;
  inline entity::DirectionDepends sc_casele3tick() const;
  inline void set_sc_casele3tick(entity::DirectionDepends value);
  
  // optional .entity.DirectionDepends SC_CaseGE4Tick = 304;
  inline bool has_sc_casege4tick() const;
  inline void clear_sc_casege4tick();
  static const int kSCCaseGE4TickFieldNumber = 304;
  inline entity::DirectionDepends sc_casege4tick() const;
  inline void set_sc_casege4tick(entity::DirectionDepends value);
  
  // optional .entity.DirectionDepends SC_CaseNoChange = 305;
  inline bool has_sc_casenochange() const;
  inline void clear_sc_casenochange();
  static const int kSCCaseNoChangeFieldNumber = 305;
  inline entity::DirectionDepends sc_casenochange() const;
  inline void set_sc_casenochange(entity::DirectionDepends value);
  
  // optional .entity.StopLossCloseMethods SC_StopLossStrategy = 306;
  inline bool has_sc_stoplossstrategy() const;
  inline void clear_sc_stoplossstrategy();
  static const int kSCStopLossStrategyFieldNumber = 306;
  inline entity::StopLossCloseMethods sc_stoplossstrategy() const;
  inline void set_sc_stoplossstrategy(entity::StopLossCloseMethods value);
  
  // repeated .entity.HistSourceCfg HistSources = 401;
  inline int histsources_size() const;
  inline void clear_histsources();
  static const int kHistSourcesFieldNumber = 401;
  inline const ::entity::HistSourceCfg& histsources(int index) const;
  inline ::entity::HistSourceCfg* mutable_histsources(int index);
  inline ::entity::HistSourceCfg* add_histsources();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::HistSourceCfg >&
      histsources() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::HistSourceCfg >*
      mutable_histsources();
  
  // optional int32 HS_Short = 501;
  inline bool has_hs_short() const;
  inline void clear_hs_short();
  static const int kHSShortFieldNumber = 501;
  inline ::google::protobuf::int32 hs_short() const;
  inline void set_hs_short(::google::protobuf::int32 value);
  
  // optional int32 HS_Long = 502;
  inline bool has_hs_long() const;
  inline void clear_hs_long();
  static const int kHSLongFieldNumber = 502;
  inline ::google::protobuf::int32 hs_long() const;
  inline void set_hs_long(::google::protobuf::int32 value);
  
  // optional int32 HS_M = 503;
  inline bool has_hs_m() const;
  inline void clear_hs_m();
  static const int kHSMFieldNumber = 503;
  inline ::google::protobuf::int32 hs_m() const;
  inline void set_hs_m(::google::protobuf::int32 value);
  
  // optional double HS_FastStdDiff = 504;
  inline bool has_hs_faststddiff() const;
  inline void clear_hs_faststddiff();
  static const int kHSFastStdDiffFieldNumber = 504;
  inline double hs_faststddiff() const;
  inline void set_hs_faststddiff(double value);
  
  // optional double HS_SlowStdDiff = 505;
  inline bool has_hs_slowstddiff() const;
  inline void clear_hs_slowstddiff();
  static const int kHSSlowStdDiffFieldNumber = 505;
  inline double hs_slowstddiff() const;
  inline void set_hs_slowstddiff(double value);
  
  // optional int32 HS_FastPeriod = 506;
  inline bool has_hs_fastperiod() const;
  inline void clear_hs_fastperiod();
  static const int kHSFastPeriodFieldNumber = 506;
  inline ::google::protobuf::int32 hs_fastperiod() const;
  inline void set_hs_fastperiod(::google::protobuf::int32 value);
  
  // optional int32 HS_SlowPeriod = 507;
  inline bool has_hs_slowperiod() const;
  inline void clear_hs_slowperiod();
  static const int kHSSlowPeriodFieldNumber = 507;
  inline ::google::protobuf::int32 hs_slowperiod() const;
  inline void set_hs_slowperiod(::google::protobuf::int32 value);
  
  // optional double HS_FastShortEMASeed = 508;
  inline bool has_hs_fastshortemaseed() const;
  inline void clear_hs_fastshortemaseed();
  static const int kHSFastShortEMASeedFieldNumber = 508;
  inline double hs_fastshortemaseed() const;
  inline void set_hs_fastshortemaseed(double value);
  
  // optional double HS_FastLongEMASeed = 509;
  inline bool has_hs_fastlongemaseed() const;
  inline void clear_hs_fastlongemaseed();
  static const int kHSFastLongEMASeedFieldNumber = 509;
  inline double hs_fastlongemaseed() const;
  inline void set_hs_fastlongemaseed(double value);
  
  // optional double HS_FastSignalEMASeed = 510;
  inline bool has_hs_fastsignalemaseed() const;
  inline void clear_hs_fastsignalemaseed();
  static const int kHSFastSignalEMASeedFieldNumber = 510;
  inline double hs_fastsignalemaseed() const;
  inline void set_hs_fastsignalemaseed(double value);
  
  // optional double HS_SlowShortEMASeed = 511;
  inline bool has_hs_slowshortemaseed() const;
  inline void clear_hs_slowshortemaseed();
  static const int kHSSlowShortEMASeedFieldNumber = 511;
  inline double hs_slowshortemaseed() const;
  inline void set_hs_slowshortemaseed(double value);
  
  // optional double HS_SlowLongEMASeed = 512;
  inline bool has_hs_slowlongemaseed() const;
  inline void clear_hs_slowlongemaseed();
  static const int kHSSlowLongEMASeedFieldNumber = 512;
  inline double hs_slowlongemaseed() const;
  inline void set_hs_slowlongemaseed(double value);
  
  // optional double HS_SlowSignalEMASeed = 513;
  inline bool has_hs_slowsignalemaseed() const;
  inline void clear_hs_slowsignalemaseed();
  static const int kHSSlowSignalEMASeedFieldNumber = 513;
  inline double hs_slowsignalemaseed() const;
  inline void set_hs_slowsignalemaseed(double value);
  
  // optional int32 DX_BollM = 521;
  inline bool has_dx_bollm() const;
  inline void clear_dx_bollm();
  static const int kDXBollMFieldNumber = 521;
  inline ::google::protobuf::int32 dx_bollm() const;
  inline void set_dx_bollm(::google::protobuf::int32 value);
  
  // optional int32 DX_BollP = 522;
  inline bool has_dx_bollp() const;
  inline void clear_dx_bollp();
  static const int kDXBollPFieldNumber = 522;
  inline ::google::protobuf::int32 dx_bollp() const;
  inline void set_dx_bollp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.StrategyItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_retrytimes();
  inline void clear_has_retrytimes();
  inline void set_has_opentimeout();
  inline void clear_has_opentimeout();
  inline void set_has_ar_side();
  inline void clear_has_ar_side();
  inline void set_has_cp_closeleg();
  inline void clear_has_cp_closeleg();
  inline void set_has_cp_closelegside();
  inline void clear_has_cp_closelegside();
  inline void set_has_sc_pricetick();
  inline void clear_has_sc_pricetick();
  inline void set_has_sc_casele2tick();
  inline void clear_has_sc_casele2tick();
  inline void set_has_sc_casele3tick();
  inline void clear_has_sc_casele3tick();
  inline void set_has_sc_casege4tick();
  inline void clear_has_sc_casege4tick();
  inline void set_has_sc_casenochange();
  inline void clear_has_sc_casenochange();
  inline void set_has_sc_stoplossstrategy();
  inline void clear_has_sc_stoplossstrategy();
  inline void set_has_hs_short();
  inline void clear_has_hs_short();
  inline void set_has_hs_long();
  inline void clear_has_hs_long();
  inline void set_has_hs_m();
  inline void clear_has_hs_m();
  inline void set_has_hs_faststddiff();
  inline void clear_has_hs_faststddiff();
  inline void set_has_hs_slowstddiff();
  inline void clear_has_hs_slowstddiff();
  inline void set_has_hs_fastperiod();
  inline void clear_has_hs_fastperiod();
  inline void set_has_hs_slowperiod();
  inline void clear_has_hs_slowperiod();
  inline void set_has_hs_fastshortemaseed();
  inline void clear_has_hs_fastshortemaseed();
  inline void set_has_hs_fastlongemaseed();
  inline void clear_has_hs_fastlongemaseed();
  inline void set_has_hs_fastsignalemaseed();
  inline void clear_has_hs_fastsignalemaseed();
  inline void set_has_hs_slowshortemaseed();
  inline void clear_has_hs_slowshortemaseed();
  inline void set_has_hs_slowlongemaseed();
  inline void clear_has_hs_slowlongemaseed();
  inline void set_has_hs_slowsignalemaseed();
  inline void clear_has_hs_slowsignalemaseed();
  inline void set_has_dx_bollm();
  inline void clear_has_dx_bollm();
  inline void set_has_dx_bollp();
  inline void clear_has_dx_bollp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 retrytimes_;
  ::google::protobuf::int32 opentimeout_;
  int ar_side_;
  ::google::protobuf::RepeatedPtrField< ::entity::TriggerItem > triggers_;
  ::std::string* cp_closeleg_;
  double sc_pricetick_;
  int cp_closelegside_;
  int sc_casele2tick_;
  int sc_casele3tick_;
  int sc_casege4tick_;
  int sc_casenochange_;
  int sc_stoplossstrategy_;
  ::google::protobuf::RepeatedPtrField< ::entity::HistSourceCfg > histsources_;
  ::google::protobuf::int32 hs_short_;
  ::google::protobuf::int32 hs_long_;
  double hs_faststddiff_;
  ::google::protobuf::int32 hs_m_;
  ::google::protobuf::int32 hs_fastperiod_;
  double hs_slowstddiff_;
  double hs_fastshortemaseed_;
  double hs_fastlongemaseed_;
  double hs_fastsignalemaseed_;
  ::google::protobuf::int32 hs_slowperiod_;
  ::google::protobuf::int32 dx_bollm_;
  double hs_slowshortemaseed_;
  double hs_slowlongemaseed_;
  double hs_slowsignalemaseed_;
  ::google::protobuf::int32 dx_bollp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static StrategyItem* default_instance_;
};
// -------------------------------------------------------------------

class TriggerItem : public ::google::protobuf::Message {
 public:
  TriggerItem();
  virtual ~TriggerItem();
  
  TriggerItem(const TriggerItem& from);
  
  inline TriggerItem& operator=(const TriggerItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerItem& default_instance();
  
  void Swap(TriggerItem* other);
  
  // implements Message ----------------------------------------------
  
  TriggerItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerItem& from);
  void MergeFrom(const TriggerItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.StrategyType Strategy = 1;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 1;
  inline entity::StrategyType strategy() const;
  inline void set_strategy(entity::StrategyType value);
  
  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required bool Enabled = 3;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // optional .entity.CompareCondition AR_Condition = 101;
  inline bool has_ar_condition() const;
  inline void clear_ar_condition();
  static const int kARConditionFieldNumber = 101;
  inline entity::CompareCondition ar_condition() const;
  inline void set_ar_condition(entity::CompareCondition value);
  
  // optional double AR_Threshold = 102;
  inline bool has_ar_threshold() const;
  inline void clear_ar_threshold();
  static const int kARThresholdFieldNumber = 102;
  inline double ar_threshold() const;
  inline void set_ar_threshold(double value);
  
  // optional .entity.PosiOffsetFlag AR_Offset = 103;
  inline bool has_ar_offset() const;
  inline void clear_ar_offset();
  static const int kAROffsetFieldNumber = 103;
  inline entity::PosiOffsetFlag ar_offset() const;
  inline void set_ar_offset(entity::PosiOffsetFlag value);
  
  // optional .entity.CompareCondition CP_Condition = 201;
  inline bool has_cp_condition() const;
  inline void clear_cp_condition();
  static const int kCPConditionFieldNumber = 201;
  inline entity::CompareCondition cp_condition() const;
  inline void set_cp_condition(entity::CompareCondition value);
  
  // optional double CP_Threshold = 202;
  inline bool has_cp_threshold() const;
  inline void clear_cp_threshold();
  static const int kCPThresholdFieldNumber = 202;
  inline double cp_threshold() const;
  inline void set_cp_threshold(double value);
  
  // optional double SC_Threshold = 301;
  inline bool has_sc_threshold() const;
  inline void clear_sc_threshold();
  static const int kSCThresholdFieldNumber = 301;
  inline double sc_threshold() const;
  inline void set_sc_threshold(double value);
  
  // optional .entity.PosiOffsetFlag HS_Offset = 401;
  inline bool has_hs_offset() const;
  inline void clear_hs_offset();
  static const int kHSOffsetFieldNumber = 401;
  inline entity::PosiOffsetFlag hs_offset() const;
  inline void set_hs_offset(entity::PosiOffsetFlag value);
  
  // optional double HS_FastAngleThreshold = 402;
  inline bool has_hs_fastanglethreshold() const;
  inline void clear_hs_fastanglethreshold();
  static const int kHSFastAngleThresholdFieldNumber = 402;
  inline double hs_fastanglethreshold() const;
  inline void set_hs_fastanglethreshold(double value);
  
  // optional double HS_SlowAngleThreshold = 403;
  inline bool has_hs_slowanglethreshold() const;
  inline void clear_hs_slowanglethreshold();
  static const int kHSSlowAngleThresholdFieldNumber = 403;
  inline double hs_slowanglethreshold() const;
  inline void set_hs_slowanglethreshold(double value);
  
  // optional double TS_BackValue = 411;
  inline bool has_ts_backvalue() const;
  inline void clear_ts_backvalue();
  static const int kTSBackValueFieldNumber = 411;
  inline double ts_backvalue() const;
  inline void set_ts_backvalue(double value);
  
  // @@protoc_insertion_point(class_scope:entity.TriggerItem)
 private:
  inline void set_has_strategy();
  inline void clear_has_strategy();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_ar_condition();
  inline void clear_has_ar_condition();
  inline void set_has_ar_threshold();
  inline void clear_has_ar_threshold();
  inline void set_has_ar_offset();
  inline void clear_has_ar_offset();
  inline void set_has_cp_condition();
  inline void clear_has_cp_condition();
  inline void set_has_cp_threshold();
  inline void clear_has_cp_threshold();
  inline void set_has_sc_threshold();
  inline void clear_has_sc_threshold();
  inline void set_has_hs_offset();
  inline void clear_has_hs_offset();
  inline void set_has_hs_fastanglethreshold();
  inline void clear_has_hs_fastanglethreshold();
  inline void set_has_hs_slowanglethreshold();
  inline void clear_has_hs_slowanglethreshold();
  inline void set_has_ts_backvalue();
  inline void clear_has_ts_backvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  int strategy_;
  bool enabled_;
  double ar_threshold_;
  int ar_condition_;
  int ar_offset_;
  double cp_threshold_;
  int cp_condition_;
  int hs_offset_;
  double sc_threshold_;
  double hs_fastanglethreshold_;
  double hs_slowanglethreshold_;
  double ts_backvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static TriggerItem* default_instance_;
};
// -------------------------------------------------------------------

class TriggerStatus : public ::google::protobuf::Message {
 public:
  TriggerStatus();
  virtual ~TriggerStatus();
  
  TriggerStatus(const TriggerStatus& from);
  
  inline TriggerStatus& operator=(const TriggerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggerStatus& default_instance();
  
  void Swap(TriggerStatus* other);
  
  // implements Message ----------------------------------------------
  
  TriggerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggerStatus& from);
  void MergeFrom(const TriggerStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.StrategyType Strategy = 1;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 1;
  inline entity::StrategyType strategy() const;
  inline void set_strategy(entity::StrategyType value);
  
  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required bool Enabled = 3;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.TriggerStatus)
 private:
  inline void set_has_strategy();
  inline void clear_has_strategy();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  int strategy_;
  bool enabled_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static TriggerStatus* default_instance_;
};
// -------------------------------------------------------------------

class PortfolioItem : public ::google::protobuf::Message {
 public:
  PortfolioItem();
  virtual ~PortfolioItem();
  
  PortfolioItem(const PortfolioItem& from);
  
  inline PortfolioItem& operator=(const PortfolioItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortfolioItem& default_instance();
  
  void Swap(PortfolioItem* other);
  
  // implements Message ----------------------------------------------
  
  PortfolioItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortfolioItem& from);
  void MergeFrom(const PortfolioItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // repeated .entity.LegItem Legs = 3;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 3;
  inline const ::entity::LegItem& legs(int index) const;
  inline ::entity::LegItem* mutable_legs(int index);
  inline ::entity::LegItem* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
      mutable_legs();
  
  // required int32 MaxCancel = 4;
  inline bool has_maxcancel() const;
  inline void clear_maxcancel();
  static const int kMaxCancelFieldNumber = 4;
  inline ::google::protobuf::int32 maxcancel() const;
  inline void set_maxcancel(::google::protobuf::int32 value);
  
  // required int32 MaxOpenPerStart = 5;
  inline bool has_maxopenperstart() const;
  inline void clear_maxopenperstart();
  static const int kMaxOpenPerStartFieldNumber = 5;
  inline ::google::protobuf::int32 maxopenperstart() const;
  inline void set_maxopenperstart(::google::protobuf::int32 value);
  
  // required int32 TotalOpenLimit = 6;
  inline bool has_totalopenlimit() const;
  inline void clear_totalopenlimit();
  static const int kTotalOpenLimitFieldNumber = 6;
  inline ::google::protobuf::int32 totalopenlimit() const;
  inline void set_totalopenlimit(::google::protobuf::int32 value);
  
  // repeated string EndTimePoints = 7;
  inline int endtimepoints_size() const;
  inline void clear_endtimepoints();
  static const int kEndTimePointsFieldNumber = 7;
  inline const ::std::string& endtimepoints(int index) const;
  inline ::std::string* mutable_endtimepoints(int index);
  inline void set_endtimepoints(int index, const ::std::string& value);
  inline void set_endtimepoints(int index, const char* value);
  inline void set_endtimepoints(int index, const char* value, size_t size);
  inline ::std::string* add_endtimepoints();
  inline void add_endtimepoints(const ::std::string& value);
  inline void add_endtimepoints(const char* value);
  inline void add_endtimepoints(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& endtimepoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endtimepoints();
  
  // required .entity.StrategyItem Strategy = 8;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 8;
  inline const ::entity::StrategyItem& strategy() const;
  inline ::entity::StrategyItem* mutable_strategy();
  inline ::entity::StrategyItem* release_strategy();
  
  // @@protoc_insertion_point(class_scope:entity.PortfolioItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_maxcancel();
  inline void clear_has_maxcancel();
  inline void set_has_maxopenperstart();
  inline void clear_has_maxopenperstart();
  inline void set_has_totalopenlimit();
  inline void clear_has_totalopenlimit();
  inline void set_has_strategy();
  inline void clear_has_strategy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::entity::LegItem > legs_;
  ::google::protobuf::int32 quantity_;
  ::google::protobuf::int32 maxcancel_;
  ::google::protobuf::int32 maxopenperstart_;
  ::google::protobuf::int32 totalopenlimit_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endtimepoints_;
  ::entity::StrategyItem* strategy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PortfolioItem* default_instance_;
};
// -------------------------------------------------------------------

class PortfolioUpdateItem : public ::google::protobuf::Message {
 public:
  PortfolioUpdateItem();
  virtual ~PortfolioUpdateItem();
  
  PortfolioUpdateItem(const PortfolioUpdateItem& from);
  
  inline PortfolioUpdateItem& operator=(const PortfolioUpdateItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PortfolioUpdateItem& default_instance();
  
  void Swap(PortfolioUpdateItem* other);
  
  // implements Message ----------------------------------------------
  
  PortfolioUpdateItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortfolioUpdateItem& from);
  void MergeFrom(const PortfolioUpdateItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // repeated .entity.LegUpdateItem Legs = 2;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 2;
  inline const ::entity::LegUpdateItem& legs(int index) const;
  inline ::entity::LegUpdateItem* mutable_legs(int index);
  inline ::entity::LegUpdateItem* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::LegUpdateItem >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::LegUpdateItem >*
      mutable_legs();
  
  // required .entity.StrategyType Strategy = 3;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  inline entity::StrategyType strategy() const;
  inline void set_strategy(entity::StrategyType value);
  
  // required bool Running = 4;
  inline bool has_running() const;
  inline void clear_running();
  static const int kRunningFieldNumber = 4;
  inline bool running() const;
  inline void set_running(bool value);
  
  // repeated .entity.TriggerStatus Triggers = 5;
  inline int triggers_size() const;
  inline void clear_triggers();
  static const int kTriggersFieldNumber = 5;
  inline const ::entity::TriggerStatus& triggers(int index) const;
  inline ::entity::TriggerStatus* mutable_triggers(int index);
  inline ::entity::TriggerStatus* add_triggers();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::TriggerStatus >&
      triggers() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::TriggerStatus >*
      mutable_triggers();
  
  // required int32 TotalOpenTimes = 6;
  inline bool has_totalopentimes() const;
  inline void clear_totalopentimes();
  static const int kTotalOpenTimesFieldNumber = 6;
  inline ::google::protobuf::int32 totalopentimes() const;
  inline void set_totalopentimes(::google::protobuf::int32 value);
  
  // required int32 TotalCloseTimes = 7;
  inline bool has_totalclosetimes() const;
  inline void clear_totalclosetimes();
  static const int kTotalCloseTimesFieldNumber = 7;
  inline ::google::protobuf::int32 totalclosetimes() const;
  inline void set_totalclosetimes(::google::protobuf::int32 value);
  
  // required int32 CurrentPosition = 8;
  inline bool has_currentposition() const;
  inline void clear_currentposition();
  static const int kCurrentPositionFieldNumber = 8;
  inline ::google::protobuf::int32 currentposition() const;
  inline void set_currentposition(::google::protobuf::int32 value);
  
  // required int32 CancelTimes = 9;
  inline bool has_canceltimes() const;
  inline void clear_canceltimes();
  static const int kCancelTimesFieldNumber = 9;
  inline ::google::protobuf::int32 canceltimes() const;
  inline void set_canceltimes(::google::protobuf::int32 value);
  
  // required double Profit = 10;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 10;
  inline double profit() const;
  inline void set_profit(double value);
  
  // optional string Message = 11;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 11;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional double AR_Diff = 101;
  inline bool has_ar_diff() const;
  inline void clear_ar_diff();
  static const int kARDiffFieldNumber = 101;
  inline double ar_diff() const;
  inline void set_ar_diff(double value);
  
  // optional double AR_LongDiff = 102;
  inline bool has_ar_longdiff() const;
  inline void clear_ar_longdiff();
  static const int kARLongDiffFieldNumber = 102;
  inline double ar_longdiff() const;
  inline void set_ar_longdiff(double value);
  
  // optional double AR_ShortDiff = 103;
  inline bool has_ar_shortdiff() const;
  inline void clear_ar_shortdiff();
  static const int kARShortDiffFieldNumber = 103;
  inline double ar_shortdiff() const;
  inline void set_ar_shortdiff(double value);
  
  // optional int32 AR_LongSize = 104;
  inline bool has_ar_longsize() const;
  inline void clear_ar_longsize();
  static const int kARLongSizeFieldNumber = 104;
  inline ::google::protobuf::int32 ar_longsize() const;
  inline void set_ar_longsize(::google::protobuf::int32 value);
  
  // optional int32 AR_ShortSize = 105;
  inline bool has_ar_shortsize() const;
  inline void clear_ar_shortsize();
  static const int kARShortSizeFieldNumber = 105;
  inline ::google::protobuf::int32 ar_shortsize() const;
  inline void set_ar_shortsize(::google::protobuf::int32 value);
  
  // optional double SC_Diff = 201;
  inline bool has_sc_diff() const;
  inline void clear_sc_diff();
  static const int kSCDiffFieldNumber = 201;
  inline double sc_diff() const;
  inline void set_sc_diff(double value);
  
  // optional double HS_FastAngle = 301;
  inline bool has_hs_fastangle() const;
  inline void clear_hs_fastangle();
  static const int kHSFastAngleFieldNumber = 301;
  inline double hs_fastangle() const;
  inline void set_hs_fastangle(double value);
  
  // optional double HS_SlowAngle = 302;
  inline bool has_hs_slowangle() const;
  inline void clear_hs_slowangle();
  static const int kHSSlowAngleFieldNumber = 302;
  inline double hs_slowangle() const;
  inline void set_hs_slowangle(double value);
  
  // optional double HS_FastMacdHist = 303;
  inline bool has_hs_fastmacdhist() const;
  inline void clear_hs_fastmacdhist();
  static const int kHSFastMacdHistFieldNumber = 303;
  inline double hs_fastmacdhist() const;
  inline void set_hs_fastmacdhist(double value);
  
  // optional double HS_FastMacdHistDiff = 304;
  inline bool has_hs_fastmacdhistdiff() const;
  inline void clear_hs_fastmacdhistdiff();
  static const int kHSFastMacdHistDiffFieldNumber = 304;
  inline double hs_fastmacdhistdiff() const;
  inline void set_hs_fastmacdhistdiff(double value);
  
  // optional double HS_SlowMacdHist = 305;
  inline bool has_hs_slowmacdhist() const;
  inline void clear_hs_slowmacdhist();
  static const int kHSSlowMacdHistFieldNumber = 305;
  inline double hs_slowmacdhist() const;
  inline void set_hs_slowmacdhist(double value);
  
  // optional double HS_SlowMacdHistDiff = 306;
  inline bool has_hs_slowmacdhistdiff() const;
  inline void clear_hs_slowmacdhistdiff();
  static const int kHSSlowMacdHistDiffFieldNumber = 306;
  inline double hs_slowmacdhistdiff() const;
  inline void set_hs_slowmacdhistdiff(double value);
  
  // optional .entity.SlopeDirection HS_FastSlopeDirection = 307;
  inline bool has_hs_fastslopedirection() const;
  inline void clear_hs_fastslopedirection();
  static const int kHSFastSlopeDirectionFieldNumber = 307;
  inline entity::SlopeDirection hs_fastslopedirection() const;
  inline void set_hs_fastslopedirection(entity::SlopeDirection value);
  
  // optional .entity.SlopeDirection HS_SlowSlopeDirection = 308;
  inline bool has_hs_slowslopedirection() const;
  inline void clear_hs_slowslopedirection();
  static const int kHSSlowSlopeDirectionFieldNumber = 308;
  inline entity::SlopeDirection hs_slowslopedirection() const;
  inline void set_hs_slowslopedirection(entity::SlopeDirection value);
  
  // optional double DX_BollTop = 311;
  inline bool has_dx_bolltop() const;
  inline void clear_dx_bolltop();
  static const int kDXBollTopFieldNumber = 311;
  inline double dx_bolltop() const;
  inline void set_dx_bolltop(double value);
  
  // optional double DX_BollBottom = 312;
  inline bool has_dx_bollbottom() const;
  inline void clear_dx_bollbottom();
  static const int kDXBollBottomFieldNumber = 312;
  inline double dx_bollbottom() const;
  inline void set_dx_bollbottom(double value);
  
  // @@protoc_insertion_point(class_scope:entity.PortfolioUpdateItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_strategy();
  inline void clear_has_strategy();
  inline void set_has_running();
  inline void clear_has_running();
  inline void set_has_totalopentimes();
  inline void clear_has_totalopentimes();
  inline void set_has_totalclosetimes();
  inline void clear_has_totalclosetimes();
  inline void set_has_currentposition();
  inline void clear_has_currentposition();
  inline void set_has_canceltimes();
  inline void clear_has_canceltimes();
  inline void set_has_profit();
  inline void clear_has_profit();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_ar_diff();
  inline void clear_has_ar_diff();
  inline void set_has_ar_longdiff();
  inline void clear_has_ar_longdiff();
  inline void set_has_ar_shortdiff();
  inline void clear_has_ar_shortdiff();
  inline void set_has_ar_longsize();
  inline void clear_has_ar_longsize();
  inline void set_has_ar_shortsize();
  inline void clear_has_ar_shortsize();
  inline void set_has_sc_diff();
  inline void clear_has_sc_diff();
  inline void set_has_hs_fastangle();
  inline void clear_has_hs_fastangle();
  inline void set_has_hs_slowangle();
  inline void clear_has_hs_slowangle();
  inline void set_has_hs_fastmacdhist();
  inline void clear_has_hs_fastmacdhist();
  inline void set_has_hs_fastmacdhistdiff();
  inline void clear_has_hs_fastmacdhistdiff();
  inline void set_has_hs_slowmacdhist();
  inline void clear_has_hs_slowmacdhist();
  inline void set_has_hs_slowmacdhistdiff();
  inline void clear_has_hs_slowmacdhistdiff();
  inline void set_has_hs_fastslopedirection();
  inline void clear_has_hs_fastslopedirection();
  inline void set_has_hs_slowslopedirection();
  inline void clear_has_hs_slowslopedirection();
  inline void set_has_dx_bolltop();
  inline void clear_has_dx_bolltop();
  inline void set_has_dx_bollbottom();
  inline void clear_has_dx_bollbottom();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::entity::LegUpdateItem > legs_;
  int strategy_;
  bool running_;
  ::google::protobuf::RepeatedPtrField< ::entity::TriggerStatus > triggers_;
  ::google::protobuf::int32 totalopentimes_;
  ::google::protobuf::int32 totalclosetimes_;
  ::google::protobuf::int32 currentposition_;
  ::google::protobuf::int32 canceltimes_;
  double profit_;
  ::std::string* message_;
  double ar_diff_;
  double ar_longdiff_;
  double ar_shortdiff_;
  ::google::protobuf::int32 ar_longsize_;
  ::google::protobuf::int32 ar_shortsize_;
  double sc_diff_;
  double hs_fastangle_;
  double hs_slowangle_;
  double hs_fastmacdhist_;
  double hs_fastmacdhistdiff_;
  double hs_slowmacdhist_;
  double hs_slowmacdhistdiff_;
  int hs_fastslopedirection_;
  int hs_slowslopedirection_;
  double dx_bolltop_;
  double dx_bollbottom_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PortfolioUpdateItem* default_instance_;
};
// -------------------------------------------------------------------

class ConnectParam : public ::google::protobuf::Message {
 public:
  ConnectParam();
  virtual ~ConnectParam();
  
  ConnectParam(const ConnectParam& from);
  
  inline ConnectParam& operator=(const ConnectParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectParam& default_instance();
  
  void Swap(ConnectParam* other);
  
  // implements Message ----------------------------------------------
  
  ConnectParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectParam& from);
  void MergeFrom(const ConnectParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string QuoteAddress = 1;
  inline bool has_quoteaddress() const;
  inline void clear_quoteaddress();
  static const int kQuoteAddressFieldNumber = 1;
  inline const ::std::string& quoteaddress() const;
  inline void set_quoteaddress(const ::std::string& value);
  inline void set_quoteaddress(const char* value);
  inline void set_quoteaddress(const char* value, size_t size);
  inline ::std::string* mutable_quoteaddress();
  inline ::std::string* release_quoteaddress();
  
  // required string StreamFolder = 2;
  inline bool has_streamfolder() const;
  inline void clear_streamfolder();
  static const int kStreamFolderFieldNumber = 2;
  inline const ::std::string& streamfolder() const;
  inline void set_streamfolder(const ::std::string& value);
  inline void set_streamfolder(const char* value);
  inline void set_streamfolder(const char* value, size_t size);
  inline ::std::string* mutable_streamfolder();
  inline ::std::string* release_streamfolder();
  
  // @@protoc_insertion_point(class_scope:entity.ConnectParam)
 private:
  inline void set_has_quoteaddress();
  inline void clear_has_quoteaddress();
  inline void set_has_streamfolder();
  inline void clear_has_streamfolder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* quoteaddress_;
  ::std::string* streamfolder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ConnectParam* default_instance_;
};
// -------------------------------------------------------------------

class OperationReturn : public ::google::protobuf::Message {
 public:
  OperationReturn();
  virtual ~OperationReturn();
  
  OperationReturn(const OperationReturn& from);
  
  inline OperationReturn& operator=(const OperationReturn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationReturn& default_instance();
  
  void Swap(OperationReturn* other);
  
  // implements Message ----------------------------------------------
  
  OperationReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationReturn& from);
  void MergeFrom(const OperationReturn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool Success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string ErrorMessage = 2;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:entity.OperationReturn)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormessage_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static OperationReturn* default_instance_;
};
// -------------------------------------------------------------------

class AccountSettings : public ::google::protobuf::Message {
 public:
  AccountSettings();
  virtual ~AccountSettings();
  
  AccountSettings(const AccountSettings& from);
  
  inline AccountSettings& operator=(const AccountSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountSettings& default_instance();
  
  void Swap(AccountSettings* other);
  
  // implements Message ----------------------------------------------
  
  AccountSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountSettings& from);
  void MergeFrom(const AccountSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 MaxSubmit = 1;
  inline bool has_maxsubmit() const;
  inline void clear_maxsubmit();
  static const int kMaxSubmitFieldNumber = 1;
  inline ::google::protobuf::int32 maxsubmit() const;
  inline void set_maxsubmit(::google::protobuf::int32 value);
  
  // required int32 MaxCancel = 2;
  inline bool has_maxcancel() const;
  inline void clear_maxcancel();
  static const int kMaxCancelFieldNumber = 2;
  inline ::google::protobuf::int32 maxcancel() const;
  inline void set_maxcancel(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.AccountSettings)
 private:
  inline void set_has_maxsubmit();
  inline void clear_has_maxsubmit();
  inline void set_has_maxcancel();
  inline void clear_has_maxcancel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 maxsubmit_;
  ::google::protobuf::int32 maxcancel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static AccountSettings* default_instance_;
};
// -------------------------------------------------------------------

class LoginParam : public ::google::protobuf::Message {
 public:
  LoginParam();
  virtual ~LoginParam();
  
  LoginParam(const LoginParam& from);
  
  inline LoginParam& operator=(const LoginParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginParam& default_instance();
  
  void Swap(LoginParam* other);
  
  // implements Message ----------------------------------------------
  
  LoginParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginParam& from);
  void MergeFrom(const LoginParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerId = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIdFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string UserId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional .entity.AccountSettings AcctSettings = 4;
  inline bool has_acctsettings() const;
  inline void clear_acctsettings();
  static const int kAcctSettingsFieldNumber = 4;
  inline const ::entity::AccountSettings& acctsettings() const;
  inline ::entity::AccountSettings* mutable_acctsettings();
  inline ::entity::AccountSettings* release_acctsettings();
  
  // @@protoc_insertion_point(class_scope:entity.LoginParam)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_acctsettings();
  inline void clear_has_acctsettings();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* userid_;
  ::std::string* password_;
  ::entity::AccountSettings* acctsettings_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LoginParam* default_instance_;
};
// -------------------------------------------------------------------

class RegQuoteParam : public ::google::protobuf::Message {
 public:
  RegQuoteParam();
  virtual ~RegQuoteParam();
  
  RegQuoteParam(const RegQuoteParam& from);
  
  inline RegQuoteParam& operator=(const RegQuoteParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegQuoteParam& default_instance();
  
  void Swap(RegQuoteParam* other);
  
  // implements Message ----------------------------------------------
  
  RegQuoteParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegQuoteParam& from);
  void MergeFrom(const RegQuoteParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string Symbols = 1;
  inline int symbols_size() const;
  inline void clear_symbols();
  static const int kSymbolsFieldNumber = 1;
  inline const ::std::string& symbols(int index) const;
  inline ::std::string* mutable_symbols(int index);
  inline void set_symbols(int index, const ::std::string& value);
  inline void set_symbols(int index, const char* value);
  inline void set_symbols(int index, const char* value, size_t size);
  inline ::std::string* add_symbols();
  inline void add_symbols(const ::std::string& value);
  inline void add_symbols(const char* value);
  inline void add_symbols(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& symbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_symbols();
  
  // @@protoc_insertion_point(class_scope:entity.RegQuoteParam)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> symbols_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static RegQuoteParam* default_instance_;
};
// -------------------------------------------------------------------

class AddPortfolioParam : public ::google::protobuf::Message {
 public:
  AddPortfolioParam();
  virtual ~AddPortfolioParam();
  
  AddPortfolioParam(const AddPortfolioParam& from);
  
  inline AddPortfolioParam& operator=(const AddPortfolioParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddPortfolioParam& default_instance();
  
  void Swap(AddPortfolioParam* other);
  
  // implements Message ----------------------------------------------
  
  AddPortfolioParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddPortfolioParam& from);
  void MergeFrom(const AddPortfolioParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .entity.PortfolioItem PortfolioItems = 1;
  inline int portfolioitems_size() const;
  inline void clear_portfolioitems();
  static const int kPortfolioItemsFieldNumber = 1;
  inline const ::entity::PortfolioItem& portfolioitems(int index) const;
  inline ::entity::PortfolioItem* mutable_portfolioitems(int index);
  inline ::entity::PortfolioItem* add_portfolioitems();
  inline const ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >&
      portfolioitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >*
      mutable_portfolioitems();
  
  // @@protoc_insertion_point(class_scope:entity.AddPortfolioParam)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem > portfolioitems_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static AddPortfolioParam* default_instance_;
};
// -------------------------------------------------------------------

class PorfOpenPosiParam : public ::google::protobuf::Message {
 public:
  PorfOpenPosiParam();
  virtual ~PorfOpenPosiParam();
  
  PorfOpenPosiParam(const PorfOpenPosiParam& from);
  
  inline PorfOpenPosiParam& operator=(const PorfOpenPosiParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PorfOpenPosiParam& default_instance();
  
  void Swap(PorfOpenPosiParam* other);
  
  // implements Message ----------------------------------------------
  
  PorfOpenPosiParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PorfOpenPosiParam& from);
  void MergeFrom(const PorfOpenPosiParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required int32 Quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // required bool IsVirtual = 3;
  inline bool has_isvirtual() const;
  inline void clear_isvirtual();
  static const int kIsVirtualFieldNumber = 3;
  inline bool isvirtual() const;
  inline void set_isvirtual(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.PorfOpenPosiParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_isvirtual();
  inline void clear_has_isvirtual();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::google::protobuf::int32 quantity_;
  bool isvirtual_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static PorfOpenPosiParam* default_instance_;
};
// -------------------------------------------------------------------

class ClosePositionParam : public ::google::protobuf::Message {
 public:
  ClosePositionParam();
  virtual ~ClosePositionParam();
  
  ClosePositionParam(const ClosePositionParam& from);
  
  inline ClosePositionParam& operator=(const ClosePositionParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClosePositionParam& default_instance();
  
  void Swap(ClosePositionParam* other);
  
  // implements Message ----------------------------------------------
  
  ClosePositionParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClosePositionParam& from);
  void MergeFrom(const ClosePositionParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .trade.MultiLegOrder MultiLegOrder = 1;
  inline bool has_multilegorder() const;
  inline void clear_multilegorder();
  static const int kMultiLegOrderFieldNumber = 1;
  inline const ::trade::MultiLegOrder& multilegorder() const;
  inline ::trade::MultiLegOrder* mutable_multilegorder();
  inline ::trade::MultiLegOrder* release_multilegorder();
  
  // optional string LegOrdRef = 2;
  inline bool has_legordref() const;
  inline void clear_legordref();
  static const int kLegOrdRefFieldNumber = 2;
  inline const ::std::string& legordref() const;
  inline void set_legordref(const ::std::string& value);
  inline void set_legordref(const char* value);
  inline void set_legordref(const char* value, size_t size);
  inline ::std::string* mutable_legordref();
  inline ::std::string* release_legordref();
  
  // @@protoc_insertion_point(class_scope:entity.ClosePositionParam)
 private:
  inline void set_has_multilegorder();
  inline void clear_has_multilegorder();
  inline void set_has_legordref();
  inline void clear_has_legordref();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::trade::MultiLegOrder* multilegorder_;
  ::std::string* legordref_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ClosePositionParam* default_instance_;
};
// -------------------------------------------------------------------

class LegOrderUpdateParam : public ::google::protobuf::Message {
 public:
  LegOrderUpdateParam();
  virtual ~LegOrderUpdateParam();
  
  LegOrderUpdateParam(const LegOrderUpdateParam& from);
  
  inline LegOrderUpdateParam& operator=(const LegOrderUpdateParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LegOrderUpdateParam& default_instance();
  
  void Swap(LegOrderUpdateParam* other);
  
  // implements Message ----------------------------------------------
  
  LegOrderUpdateParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegOrderUpdateParam& from);
  void MergeFrom(const LegOrderUpdateParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string MultiLegOrderId = 2;
  inline bool has_multilegorderid() const;
  inline void clear_multilegorderid();
  static const int kMultiLegOrderIdFieldNumber = 2;
  inline const ::std::string& multilegorderid() const;
  inline void set_multilegorderid(const ::std::string& value);
  inline void set_multilegorderid(const char* value);
  inline void set_multilegorderid(const char* value, size_t size);
  inline ::std::string* mutable_multilegorderid();
  inline ::std::string* release_multilegorderid();
  
  // required string LegOrderRef = 3;
  inline bool has_legorderref() const;
  inline void clear_legorderref();
  static const int kLegOrderRefFieldNumber = 3;
  inline const ::std::string& legorderref() const;
  inline void set_legorderref(const ::std::string& value);
  inline void set_legorderref(const char* value);
  inline void set_legorderref(const char* value, size_t size);
  inline ::std::string* mutable_legorderref();
  inline ::std::string* release_legorderref();
  
  // required .trade.Order LegOrder = 4;
  inline bool has_legorder() const;
  inline void clear_legorder();
  static const int kLegOrderFieldNumber = 4;
  inline const ::trade::Order& legorder() const;
  inline ::trade::Order* mutable_legorder();
  inline ::trade::Order* release_legorder();
  
  // @@protoc_insertion_point(class_scope:entity.LegOrderUpdateParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_multilegorderid();
  inline void clear_has_multilegorderid();
  inline void set_has_legorderref();
  inline void clear_has_legorderref();
  inline void set_has_legorder();
  inline void clear_has_legorder();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* multilegorderid_;
  ::std::string* legorderref_;
  ::trade::Order* legorder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LegOrderUpdateParam* default_instance_;
};
// -------------------------------------------------------------------

class ArbitrageStrategySettings : public ::google::protobuf::Message {
 public:
  ArbitrageStrategySettings();
  virtual ~ArbitrageStrategySettings();
  
  ArbitrageStrategySettings(const ArbitrageStrategySettings& from);
  
  inline ArbitrageStrategySettings& operator=(const ArbitrageStrategySettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArbitrageStrategySettings& default_instance();
  
  void Swap(ArbitrageStrategySettings* other);
  
  // implements Message ----------------------------------------------
  
  ArbitrageStrategySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArbitrageStrategySettings& from);
  void MergeFrom(const ArbitrageStrategySettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .entity.PosiDirectionType Side = 1;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 1;
  inline entity::PosiDirectionType side() const;
  inline void set_side(entity::PosiDirectionType value);
  
  // required .entity.CompareCondition OpenCondition = 2;
  inline bool has_opencondition() const;
  inline void clear_opencondition();
  static const int kOpenConditionFieldNumber = 2;
  inline entity::CompareCondition opencondition() const;
  inline void set_opencondition(entity::CompareCondition value);
  
  // required double OpenPosiThreshold = 3;
  inline bool has_openposithreshold() const;
  inline void clear_openposithreshold();
  static const int kOpenPosiThresholdFieldNumber = 3;
  inline double openposithreshold() const;
  inline void set_openposithreshold(double value);
  
  // required .entity.CompareCondition StopGainCondition = 4;
  inline bool has_stopgaincondition() const;
  inline void clear_stopgaincondition();
  static const int kStopGainConditionFieldNumber = 4;
  inline entity::CompareCondition stopgaincondition() const;
  inline void set_stopgaincondition(entity::CompareCondition value);
  
  // required double StopGainThreshold = 5;
  inline bool has_stopgainthreshold() const;
  inline void clear_stopgainthreshold();
  static const int kStopGainThresholdFieldNumber = 5;
  inline double stopgainthreshold() const;
  inline void set_stopgainthreshold(double value);
  
  // required .entity.CompareCondition StopLossCondition = 6;
  inline bool has_stoplosscondition() const;
  inline void clear_stoplosscondition();
  static const int kStopLossConditionFieldNumber = 6;
  inline entity::CompareCondition stoplosscondition() const;
  inline void set_stoplosscondition(entity::CompareCondition value);
  
  // required double StopLossThreshold = 7;
  inline bool has_stoplossthreshold() const;
  inline void clear_stoplossthreshold();
  static const int kStopLossThresholdFieldNumber = 7;
  inline double stoplossthreshold() const;
  inline void set_stoplossthreshold(double value);
  
  // @@protoc_insertion_point(class_scope:entity.ArbitrageStrategySettings)
 private:
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_opencondition();
  inline void clear_has_opencondition();
  inline void set_has_openposithreshold();
  inline void clear_has_openposithreshold();
  inline void set_has_stopgaincondition();
  inline void clear_has_stopgaincondition();
  inline void set_has_stopgainthreshold();
  inline void clear_has_stopgainthreshold();
  inline void set_has_stoplosscondition();
  inline void clear_has_stoplosscondition();
  inline void set_has_stoplossthreshold();
  inline void clear_has_stoplossthreshold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int side_;
  int opencondition_;
  double openposithreshold_;
  double stopgainthreshold_;
  int stopgaincondition_;
  int stoplosscondition_;
  double stoplossthreshold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ArbitrageStrategySettings* default_instance_;
};
// -------------------------------------------------------------------

class ChangePosiStrategySettings : public ::google::protobuf::Message {
 public:
  ChangePosiStrategySettings();
  virtual ~ChangePosiStrategySettings();
  
  ChangePosiStrategySettings(const ChangePosiStrategySettings& from);
  
  inline ChangePosiStrategySettings& operator=(const ChangePosiStrategySettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePosiStrategySettings& default_instance();
  
  void Swap(ChangePosiStrategySettings* other);
  
  // implements Message ----------------------------------------------
  
  ChangePosiStrategySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePosiStrategySettings& from);
  void MergeFrom(const ChangePosiStrategySettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string CloseLeg = 1;
  inline bool has_closeleg() const;
  inline void clear_closeleg();
  static const int kCloseLegFieldNumber = 1;
  inline const ::std::string& closeleg() const;
  inline void set_closeleg(const ::std::string& value);
  inline void set_closeleg(const char* value);
  inline void set_closeleg(const char* value, size_t size);
  inline ::std::string* mutable_closeleg();
  inline ::std::string* release_closeleg();
  
  // required .entity.PosiDirectionType CloseLegSide = 2;
  inline bool has_closelegside() const;
  inline void clear_closelegside();
  static const int kCloseLegSideFieldNumber = 2;
  inline entity::PosiDirectionType closelegside() const;
  inline void set_closelegside(entity::PosiDirectionType value);
  
  // required .entity.CompareCondition TriggerCondition = 3;
  inline bool has_triggercondition() const;
  inline void clear_triggercondition();
  static const int kTriggerConditionFieldNumber = 3;
  inline entity::CompareCondition triggercondition() const;
  inline void set_triggercondition(entity::CompareCondition value);
  
  // required double Threshold = 4;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  inline double threshold() const;
  inline void set_threshold(double value);
  
  // @@protoc_insertion_point(class_scope:entity.ChangePosiStrategySettings)
 private:
  inline void set_has_closeleg();
  inline void clear_has_closeleg();
  inline void set_has_closelegside();
  inline void clear_has_closelegside();
  inline void set_has_triggercondition();
  inline void clear_has_triggercondition();
  inline void set_has_threshold();
  inline void clear_has_threshold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* closeleg_;
  int closelegside_;
  int triggercondition_;
  double threshold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ChangePosiStrategySettings* default_instance_;
};
// -------------------------------------------------------------------

class ScalperSettings : public ::google::protobuf::Message {
 public:
  ScalperSettings();
  virtual ~ScalperSettings();
  
  ScalperSettings(const ScalperSettings& from);
  
  inline ScalperSettings& operator=(const ScalperSettings& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScalperSettings& default_instance();
  
  void Swap(ScalperSettings* other);
  
  // implements Message ----------------------------------------------
  
  ScalperSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScalperSettings& from);
  void MergeFrom(const ScalperSettings& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double Threshold = 1;
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 1;
  inline double threshold() const;
  inline void set_threshold(double value);
  
  // required double PriceTick = 2;
  inline bool has_pricetick() const;
  inline void clear_pricetick();
  static const int kPriceTickFieldNumber = 2;
  inline double pricetick() const;
  inline void set_pricetick(double value);
  
  // required .entity.DirectionDepends CaseLE2Tick = 3;
  inline bool has_casele2tick() const;
  inline void clear_casele2tick();
  static const int kCaseLE2TickFieldNumber = 3;
  inline entity::DirectionDepends casele2tick() const;
  inline void set_casele2tick(entity::DirectionDepends value);
  
  // required .entity.DirectionDepends CaseLE3Tick = 4;
  inline bool has_casele3tick() const;
  inline void clear_casele3tick();
  static const int kCaseLE3TickFieldNumber = 4;
  inline entity::DirectionDepends casele3tick() const;
  inline void set_casele3tick(entity::DirectionDepends value);
  
  // required .entity.DirectionDepends CaseGE4Tick = 5;
  inline bool has_casege4tick() const;
  inline void clear_casege4tick();
  static const int kCaseGE4TickFieldNumber = 5;
  inline entity::DirectionDepends casege4tick() const;
  inline void set_casege4tick(entity::DirectionDepends value);
  
  // required .entity.DirectionDepends CaseNoChange = 6;
  inline bool has_casenochange() const;
  inline void clear_casenochange();
  static const int kCaseNoChangeFieldNumber = 6;
  inline entity::DirectionDepends casenochange() const;
  inline void set_casenochange(entity::DirectionDepends value);
  
  // required .entity.StopLossCloseMethods StopLossStrategy = 7;
  inline bool has_stoplossstrategy() const;
  inline void clear_stoplossstrategy();
  static const int kStopLossStrategyFieldNumber = 7;
  inline entity::StopLossCloseMethods stoplossstrategy() const;
  inline void set_stoplossstrategy(entity::StopLossCloseMethods value);
  
  // required int32 RetryTimes = 8;
  inline bool has_retrytimes() const;
  inline void clear_retrytimes();
  static const int kRetryTimesFieldNumber = 8;
  inline ::google::protobuf::int32 retrytimes() const;
  inline void set_retrytimes(::google::protobuf::int32 value);
  
  // optional int32 OpenTimeout = 9;
  inline bool has_opentimeout() const;
  inline void clear_opentimeout();
  static const int kOpenTimeoutFieldNumber = 9;
  inline ::google::protobuf::int32 opentimeout() const;
  inline void set_opentimeout(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.ScalperSettings)
 private:
  inline void set_has_threshold();
  inline void clear_has_threshold();
  inline void set_has_pricetick();
  inline void clear_has_pricetick();
  inline void set_has_casele2tick();
  inline void clear_has_casele2tick();
  inline void set_has_casele3tick();
  inline void clear_has_casele3tick();
  inline void set_has_casege4tick();
  inline void clear_has_casege4tick();
  inline void set_has_casenochange();
  inline void clear_has_casenochange();
  inline void set_has_stoplossstrategy();
  inline void clear_has_stoplossstrategy();
  inline void set_has_retrytimes();
  inline void clear_has_retrytimes();
  inline void set_has_opentimeout();
  inline void clear_has_opentimeout();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double threshold_;
  double pricetick_;
  int casele2tick_;
  int casele3tick_;
  int casege4tick_;
  int casenochange_;
  int stoplossstrategy_;
  ::google::protobuf::int32 retrytimes_;
  ::google::protobuf::int32 opentimeout_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ScalperSettings* default_instance_;
};
// -------------------------------------------------------------------

class ModifyStrategyParam : public ::google::protobuf::Message {
 public:
  ModifyStrategyParam();
  virtual ~ModifyStrategyParam();
  
  ModifyStrategyParam(const ModifyStrategyParam& from);
  
  inline ModifyStrategyParam& operator=(const ModifyStrategyParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyStrategyParam& default_instance();
  
  void Swap(ModifyStrategyParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyStrategyParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyStrategyParam& from);
  void MergeFrom(const ModifyStrategyParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string StrategyName = 2;
  inline bool has_strategyname() const;
  inline void clear_strategyname();
  static const int kStrategyNameFieldNumber = 2;
  inline const ::std::string& strategyname() const;
  inline void set_strategyname(const ::std::string& value);
  inline void set_strategyname(const char* value);
  inline void set_strategyname(const char* value, size_t size);
  inline ::std::string* mutable_strategyname();
  inline ::std::string* release_strategyname();
  
  // required bytes StrategyData = 3;
  inline bool has_strategydata() const;
  inline void clear_strategydata();
  static const int kStrategyDataFieldNumber = 3;
  inline const ::std::string& strategydata() const;
  inline void set_strategydata(const ::std::string& value);
  inline void set_strategydata(const char* value);
  inline void set_strategydata(const void* value, size_t size);
  inline ::std::string* mutable_strategydata();
  inline ::std::string* release_strategydata();
  
  // @@protoc_insertion_point(class_scope:entity.ModifyStrategyParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_strategyname();
  inline void clear_has_strategyname();
  inline void set_has_strategydata();
  inline void clear_has_strategydata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* strategyname_;
  ::std::string* strategydata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyStrategyParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyPortfolioSwitchParam : public ::google::protobuf::Message {
 public:
  ModifyPortfolioSwitchParam();
  virtual ~ModifyPortfolioSwitchParam();
  
  ModifyPortfolioSwitchParam(const ModifyPortfolioSwitchParam& from);
  
  inline ModifyPortfolioSwitchParam& operator=(const ModifyPortfolioSwitchParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyPortfolioSwitchParam& default_instance();
  
  void Swap(ModifyPortfolioSwitchParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyPortfolioSwitchParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyPortfolioSwitchParam& from);
  void MergeFrom(const ModifyPortfolioSwitchParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required bool AutoOpen = 2;
  inline bool has_autoopen() const;
  inline void clear_autoopen();
  static const int kAutoOpenFieldNumber = 2;
  inline bool autoopen() const;
  inline void set_autoopen(bool value);
  
  // required bool AutoStopGain = 3;
  inline bool has_autostopgain() const;
  inline void clear_autostopgain();
  static const int kAutoStopGainFieldNumber = 3;
  inline bool autostopgain() const;
  inline void set_autostopgain(bool value);
  
  // required bool AutoStopLoss = 4;
  inline bool has_autostoploss() const;
  inline void clear_autostoploss();
  static const int kAutoStopLossFieldNumber = 4;
  inline bool autostoploss() const;
  inline void set_autostoploss(bool value);
  
  // required bool AutoTracking = 5;
  inline bool has_autotracking() const;
  inline void clear_autotracking();
  static const int kAutoTrackingFieldNumber = 5;
  inline bool autotracking() const;
  inline void set_autotracking(bool value);
  
  // required bool EnablePrefer = 6;
  inline bool has_enableprefer() const;
  inline void clear_enableprefer();
  static const int kEnablePreferFieldNumber = 6;
  inline bool enableprefer() const;
  inline void set_enableprefer(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.ModifyPortfolioSwitchParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_autoopen();
  inline void clear_has_autoopen();
  inline void set_has_autostopgain();
  inline void clear_has_autostopgain();
  inline void set_has_autostoploss();
  inline void clear_has_autostoploss();
  inline void set_has_autotracking();
  inline void clear_has_autotracking();
  inline void set_has_enableprefer();
  inline void clear_has_enableprefer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  bool autoopen_;
  bool autostopgain_;
  bool autostoploss_;
  bool autotracking_;
  bool enableprefer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyPortfolioSwitchParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyPortfolioQtyParam : public ::google::protobuf::Message {
 public:
  ModifyPortfolioQtyParam();
  virtual ~ModifyPortfolioQtyParam();
  
  ModifyPortfolioQtyParam(const ModifyPortfolioQtyParam& from);
  
  inline ModifyPortfolioQtyParam& operator=(const ModifyPortfolioQtyParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyPortfolioQtyParam& default_instance();
  
  void Swap(ModifyPortfolioQtyParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyPortfolioQtyParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyPortfolioQtyParam& from);
  void MergeFrom(const ModifyPortfolioQtyParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required int32 PerOpenQty = 2;
  inline bool has_peropenqty() const;
  inline void clear_peropenqty();
  static const int kPerOpenQtyFieldNumber = 2;
  inline ::google::protobuf::int32 peropenqty() const;
  inline void set_peropenqty(::google::protobuf::int32 value);
  
  // required int32 PerStartQty = 3;
  inline bool has_perstartqty() const;
  inline void clear_perstartqty();
  static const int kPerStartQtyFieldNumber = 3;
  inline ::google::protobuf::int32 perstartqty() const;
  inline void set_perstartqty(::google::protobuf::int32 value);
  
  // required int32 TotalOpenLimit = 4;
  inline bool has_totalopenlimit() const;
  inline void clear_totalopenlimit();
  static const int kTotalOpenLimitFieldNumber = 4;
  inline ::google::protobuf::int32 totalopenlimit() const;
  inline void set_totalopenlimit(::google::protobuf::int32 value);
  
  // required int32 MaxCancelQty = 5;
  inline bool has_maxcancelqty() const;
  inline void clear_maxcancelqty();
  static const int kMaxCancelQtyFieldNumber = 5;
  inline ::google::protobuf::int32 maxcancelqty() const;
  inline void set_maxcancelqty(::google::protobuf::int32 value);
  
  // repeated string EndTimePoints = 6;
  inline int endtimepoints_size() const;
  inline void clear_endtimepoints();
  static const int kEndTimePointsFieldNumber = 6;
  inline const ::std::string& endtimepoints(int index) const;
  inline ::std::string* mutable_endtimepoints(int index);
  inline void set_endtimepoints(int index, const ::std::string& value);
  inline void set_endtimepoints(int index, const char* value);
  inline void set_endtimepoints(int index, const char* value, size_t size);
  inline ::std::string* add_endtimepoints();
  inline void add_endtimepoints(const ::std::string& value);
  inline void add_endtimepoints(const char* value);
  inline void add_endtimepoints(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& endtimepoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endtimepoints();
  
  // @@protoc_insertion_point(class_scope:entity.ModifyPortfolioQtyParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_peropenqty();
  inline void clear_has_peropenqty();
  inline void set_has_perstartqty();
  inline void clear_has_perstartqty();
  inline void set_has_totalopenlimit();
  inline void clear_has_totalopenlimit();
  inline void set_has_maxcancelqty();
  inline void clear_has_maxcancelqty();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::google::protobuf::int32 peropenqty_;
  ::google::protobuf::int32 perstartqty_;
  ::google::protobuf::int32 totalopenlimit_;
  ::google::protobuf::int32 maxcancelqty_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endtimepoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyPortfolioQtyParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyRunningStatusParam : public ::google::protobuf::Message {
 public:
  ModifyRunningStatusParam();
  virtual ~ModifyRunningStatusParam();
  
  ModifyRunningStatusParam(const ModifyRunningStatusParam& from);
  
  inline ModifyRunningStatusParam& operator=(const ModifyRunningStatusParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyRunningStatusParam& default_instance();
  
  void Swap(ModifyRunningStatusParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyRunningStatusParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyRunningStatusParam& from);
  void MergeFrom(const ModifyRunningStatusParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required bool Enabled = 2;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // @@protoc_insertion_point(class_scope:entity.ModifyRunningStatusParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  bool enabled_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyRunningStatusParam* default_instance_;
};
// -------------------------------------------------------------------

class ModifyPortfolioPreferredLegParam : public ::google::protobuf::Message {
 public:
  ModifyPortfolioPreferredLegParam();
  virtual ~ModifyPortfolioPreferredLegParam();
  
  ModifyPortfolioPreferredLegParam(const ModifyPortfolioPreferredLegParam& from);
  
  inline ModifyPortfolioPreferredLegParam& operator=(const ModifyPortfolioPreferredLegParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyPortfolioPreferredLegParam& default_instance();
  
  void Swap(ModifyPortfolioPreferredLegParam* other);
  
  // implements Message ----------------------------------------------
  
  ModifyPortfolioPreferredLegParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyPortfolioPreferredLegParam& from);
  void MergeFrom(const ModifyPortfolioPreferredLegParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string PortfId = 1;
  inline bool has_portfid() const;
  inline void clear_portfid();
  static const int kPortfIdFieldNumber = 1;
  inline const ::std::string& portfid() const;
  inline void set_portfid(const ::std::string& value);
  inline void set_portfid(const char* value);
  inline void set_portfid(const char* value, size_t size);
  inline ::std::string* mutable_portfid();
  inline ::std::string* release_portfid();
  
  // required string LegSymbol = 2;
  inline bool has_legsymbol() const;
  inline void clear_legsymbol();
  static const int kLegSymbolFieldNumber = 2;
  inline const ::std::string& legsymbol() const;
  inline void set_legsymbol(const ::std::string& value);
  inline void set_legsymbol(const char* value);
  inline void set_legsymbol(const char* value, size_t size);
  inline ::std::string* mutable_legsymbol();
  inline ::std::string* release_legsymbol();
  
  // @@protoc_insertion_point(class_scope:entity.ModifyPortfolioPreferredLegParam)
 private:
  inline void set_has_portfid();
  inline void clear_has_portfid();
  inline void set_has_legsymbol();
  inline void clear_has_legsymbol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* portfid_;
  ::std::string* legsymbol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ModifyPortfolioPreferredLegParam* default_instance_;
};
// -------------------------------------------------------------------

class CancelOrderParam : public ::google::protobuf::Message {
 public:
  CancelOrderParam();
  virtual ~CancelOrderParam();
  
  CancelOrderParam(const CancelOrderParam& from);
  
  inline CancelOrderParam& operator=(const CancelOrderParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelOrderParam& default_instance();
  
  void Swap(CancelOrderParam* other);
  
  // implements Message ----------------------------------------------
  
  CancelOrderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelOrderParam& from);
  void MergeFrom(const CancelOrderParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string OrderRef = 1;
  inline bool has_orderref() const;
  inline void clear_orderref();
  static const int kOrderRefFieldNumber = 1;
  inline const ::std::string& orderref() const;
  inline void set_orderref(const ::std::string& value);
  inline void set_orderref(const char* value);
  inline void set_orderref(const char* value, size_t size);
  inline ::std::string* mutable_orderref();
  inline ::std::string* release_orderref();
  
  // required string ExchangeId = 2;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIdFieldNumber = 2;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required string OrdSysId = 3;
  inline bool has_ordsysid() const;
  inline void clear_ordsysid();
  static const int kOrdSysIdFieldNumber = 3;
  inline const ::std::string& ordsysid() const;
  inline void set_ordsysid(const ::std::string& value);
  inline void set_ordsysid(const char* value);
  inline void set_ordsysid(const char* value, size_t size);
  inline ::std::string* mutable_ordsysid();
  inline ::std::string* release_ordsysid();
  
  // required string UserId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string Symbol = 5;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 5;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // @@protoc_insertion_point(class_scope:entity.CancelOrderParam)
 private:
  inline void set_has_orderref();
  inline void clear_has_orderref();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_ordsysid();
  inline void clear_has_ordsysid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* orderref_;
  ::std::string* exchangeid_;
  ::std::string* ordsysid_;
  ::std::string* userid_;
  ::std::string* symbol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static CancelOrderParam* default_instance_;
};
// -------------------------------------------------------------------

class ManualCloseOrderParam : public ::google::protobuf::Message {
 public:
  ManualCloseOrderParam();
  virtual ~ManualCloseOrderParam();
  
  ManualCloseOrderParam(const ManualCloseOrderParam& from);
  
  inline ManualCloseOrderParam& operator=(const ManualCloseOrderParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualCloseOrderParam& default_instance();
  
  void Swap(ManualCloseOrderParam* other);
  
  // implements Message ----------------------------------------------
  
  ManualCloseOrderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManualCloseOrderParam& from);
  void MergeFrom(const ManualCloseOrderParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // required .trade.TradeDirectionType Direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline trade::TradeDirectionType direction() const;
  inline void set_direction(trade::TradeDirectionType value);
  
  // required string OpenDate = 3;
  inline bool has_opendate() const;
  inline void clear_opendate();
  static const int kOpenDateFieldNumber = 3;
  inline const ::std::string& opendate() const;
  inline void set_opendate(const ::std::string& value);
  inline void set_opendate(const char* value);
  inline void set_opendate(const char* value, size_t size);
  inline ::std::string* mutable_opendate();
  inline ::std::string* release_opendate();
  
  // required int32 Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:entity.ManualCloseOrderParam)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_opendate();
  inline void clear_has_opendate();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* symbol_;
  ::std::string* opendate_;
  int direction_;
  ::google::protobuf::int32 quantity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ManualCloseOrderParam* default_instance_;
};
// -------------------------------------------------------------------

class SymbolInfo : public ::google::protobuf::Message {
 public:
  SymbolInfo();
  virtual ~SymbolInfo();
  
  SymbolInfo(const SymbolInfo& from);
  
  inline SymbolInfo& operator=(const SymbolInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolInfo& default_instance();
  
  void Swap(SymbolInfo* other);
  
  // implements Message ----------------------------------------------
  
  SymbolInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolInfo& from);
  void MergeFrom(const SymbolInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Instrument = 1;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  inline const ::std::string& instrument() const;
  inline void set_instrument(const ::std::string& value);
  inline void set_instrument(const char* value);
  inline void set_instrument(const char* value, size_t size);
  inline ::std::string* mutable_instrument();
  inline ::std::string* release_instrument();
  
  // required string ExchangeID = 2;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 2;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required string ExchangeInstID = 3;
  inline bool has_exchangeinstid() const;
  inline void clear_exchangeinstid();
  static const int kExchangeInstIDFieldNumber = 3;
  inline const ::std::string& exchangeinstid() const;
  inline void set_exchangeinstid(const ::std::string& value);
  inline void set_exchangeinstid(const char* value);
  inline void set_exchangeinstid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeinstid();
  inline ::std::string* release_exchangeinstid();
  
  // required string ProductID = 4;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 4;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  
  // required int32 VolumeMultiple = 5;
  inline bool has_volumemultiple() const;
  inline void clear_volumemultiple();
  static const int kVolumeMultipleFieldNumber = 5;
  inline ::google::protobuf::int32 volumemultiple() const;
  inline void set_volumemultiple(::google::protobuf::int32 value);
  
  // required double PriceTick = 6;
  inline bool has_pricetick() const;
  inline void clear_pricetick();
  static const int kPriceTickFieldNumber = 6;
  inline double pricetick() const;
  inline void set_pricetick(double value);
  
  // @@protoc_insertion_point(class_scope:entity.SymbolInfo)
 private:
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_exchangeinstid();
  inline void clear_has_exchangeinstid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_volumemultiple();
  inline void clear_has_volumemultiple();
  inline void set_has_pricetick();
  inline void clear_has_pricetick();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_;
  ::std::string* exchangeid_;
  ::std::string* exchangeinstid_;
  ::std::string* productid_;
  double pricetick_;
  ::google::protobuf::int32 volumemultiple_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginPuzzleResponse

// required string session_id = 1;
inline bool LoginPuzzleResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginPuzzleResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginPuzzleResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginPuzzleResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginPuzzleResponse::session_id() const {
  return *session_id_;
}
inline void LoginPuzzleResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginPuzzleResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginPuzzleResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginPuzzleResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LoginPuzzleResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginRequest

// required bool is_new = 1;
inline bool LoginRequest::has_is_new() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_is_new() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool LoginRequest::is_new() const {
  return is_new_;
}
inline void LoginRequest::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
}

// required string session_id = 2;
inline bool LoginRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginRequest::session_id() const {
  return *session_id_;
}
inline void LoginRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginRequest::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LoginRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string previous_session_id = 3;
inline bool LoginRequest::has_previous_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_previous_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_previous_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_previous_session_id() {
  if (previous_session_id_ != &::google::protobuf::internal::kEmptyString) {
    previous_session_id_->clear();
  }
  clear_has_previous_session_id();
}
inline const ::std::string& LoginRequest::previous_session_id() const {
  return *previous_session_id_;
}
inline void LoginRequest::set_previous_session_id(const ::std::string& value) {
  set_has_previous_session_id();
  if (previous_session_id_ == &::google::protobuf::internal::kEmptyString) {
    previous_session_id_ = new ::std::string;
  }
  previous_session_id_->assign(value);
}
inline void LoginRequest::set_previous_session_id(const char* value) {
  set_has_previous_session_id();
  if (previous_session_id_ == &::google::protobuf::internal::kEmptyString) {
    previous_session_id_ = new ::std::string;
  }
  previous_session_id_->assign(value);
}
inline void LoginRequest::set_previous_session_id(const char* value, size_t size) {
  set_has_previous_session_id();
  if (previous_session_id_ == &::google::protobuf::internal::kEmptyString) {
    previous_session_id_ = new ::std::string;
  }
  previous_session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_previous_session_id() {
  set_has_previous_session_id();
  if (previous_session_id_ == &::google::protobuf::internal::kEmptyString) {
    previous_session_id_ = new ::std::string;
  }
  return previous_session_id_;
}
inline ::std::string* LoginRequest::release_previous_session_id() {
  clear_has_previous_session_id();
  if (previous_session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previous_session_id_;
    previous_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string pseudo = 4;
inline bool LoginRequest::has_pseudo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_pseudo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_pseudo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_pseudo() {
  if (pseudo_ != &::google::protobuf::internal::kEmptyString) {
    pseudo_->clear();
  }
  clear_has_pseudo();
}
inline const ::std::string& LoginRequest::pseudo() const {
  return *pseudo_;
}
inline void LoginRequest::set_pseudo(const ::std::string& value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginRequest::set_pseudo(const char* value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginRequest::set_pseudo(const char* value, size_t size) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_pseudo() {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  return pseudo_;
}
inline ::std::string* LoginRequest::release_pseudo() {
  clear_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_;
    pseudo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required bool accepted = 1;
inline bool LoginResponse::has_accepted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_accepted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_accepted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_accepted() {
  accepted_ = false;
  clear_has_accepted();
}
inline bool LoginResponse::accepted() const {
  return accepted_;
}
inline void LoginResponse::set_accepted(bool value) {
  set_has_accepted();
  accepted_ = value;
}

// required string session_id = 2;
inline bool LoginResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginResponse::session_id() const {
  return *session_id_;
}
inline void LoginResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LoginResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool is_new = 3;
inline bool LoginResponse::has_is_new() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_is_new() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool LoginResponse::is_new() const {
  return is_new_;
}
inline void LoginResponse::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
}

// required string error_msg = 4;
inline bool LoginResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& LoginResponse::error_msg() const {
  return *error_msg_;
}
inline void LoginResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void LoginResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void LoginResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* LoginResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeartbeatRequest

// required string timestamp = 1;
inline bool HeartbeatRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& HeartbeatRequest::timestamp() const {
  return *timestamp_;
}
inline void HeartbeatRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* HeartbeatRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeartbeatResponse

// required string timestamp = 1;
inline bool HeartbeatResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& HeartbeatResponse::timestamp() const {
  return *timestamp_;
}
inline void HeartbeatResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* HeartbeatResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerLoginRequest

// required .entity.ServerType Type = 1;
inline bool ServerLoginRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerLoginRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerLoginRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerLoginRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline entity::ServerType ServerLoginRequest::type() const {
  return static_cast< entity::ServerType >(type_);
}
inline void ServerLoginRequest::set_type(entity::ServerType value) {
  GOOGLE_DCHECK(entity::ServerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string Address = 2;
inline bool ServerLoginRequest::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerLoginRequest::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerLoginRequest::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerLoginRequest::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ServerLoginRequest::address() const {
  return *address_;
}
inline void ServerLoginRequest::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ServerLoginRequest::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ServerLoginRequest::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginRequest::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ServerLoginRequest::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BrokerId = 3;
inline bool ServerLoginRequest::has_brokerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerLoginRequest::set_has_brokerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerLoginRequest::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerLoginRequest::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& ServerLoginRequest::brokerid() const {
  return *brokerid_;
}
inline void ServerLoginRequest::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void ServerLoginRequest::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void ServerLoginRequest::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginRequest::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* ServerLoginRequest::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 4;
inline bool ServerLoginRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerLoginRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerLoginRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerLoginRequest::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ServerLoginRequest::userid() const {
  return *userid_;
}
inline void ServerLoginRequest::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ServerLoginRequest::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ServerLoginRequest::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginRequest::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ServerLoginRequest::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 5;
inline bool ServerLoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerLoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerLoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerLoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ServerLoginRequest::password() const {
  return *password_;
}
inline void ServerLoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ServerLoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ServerLoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ServerLoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerLoginResponse

// required bool Success = 1;
inline bool ServerLoginResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerLoginResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerLoginResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerLoginResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ServerLoginResponse::success() const {
  return success_;
}
inline void ServerLoginResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string ErrorMessage = 2;
inline bool ServerLoginResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerLoginResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerLoginResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerLoginResponse::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& ServerLoginResponse::errormessage() const {
  return *errormessage_;
}
inline void ServerLoginResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void ServerLoginResponse::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void ServerLoginResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginResponse::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* ServerLoginResponse::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.ServerType Type = 3;
inline bool ServerLoginResponse::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerLoginResponse::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerLoginResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerLoginResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline entity::ServerType ServerLoginResponse::type() const {
  return static_cast< entity::ServerType >(type_);
}
inline void ServerLoginResponse::set_type(entity::ServerType value) {
  GOOGLE_DCHECK(entity::ServerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string Address = 4;
inline bool ServerLoginResponse::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerLoginResponse::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerLoginResponse::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerLoginResponse::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ServerLoginResponse::address() const {
  return *address_;
}
inline void ServerLoginResponse::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ServerLoginResponse::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ServerLoginResponse::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginResponse::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ServerLoginResponse::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BrokerId = 5;
inline bool ServerLoginResponse::has_brokerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerLoginResponse::set_has_brokerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerLoginResponse::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerLoginResponse::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& ServerLoginResponse::brokerid() const {
  return *brokerid_;
}
inline void ServerLoginResponse::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void ServerLoginResponse::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void ServerLoginResponse::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginResponse::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* ServerLoginResponse::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 6;
inline bool ServerLoginResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerLoginResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerLoginResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerLoginResponse::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ServerLoginResponse::userid() const {
  return *userid_;
}
inline void ServerLoginResponse::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ServerLoginResponse::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void ServerLoginResponse::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerLoginResponse::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* ServerLoginResponse::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServerLogoutRequest

// required .entity.ServerType Type = 1;
inline bool ServerLogoutRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerLogoutRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerLogoutRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerLogoutRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline entity::ServerType ServerLogoutRequest::type() const {
  return static_cast< entity::ServerType >(type_);
}
inline void ServerLogoutRequest::set_type(entity::ServerType value) {
  GOOGLE_DCHECK(entity::ServerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AddPortfolioRequest

// repeated .entity.PortfolioItem Portfolios = 1;
inline int AddPortfolioRequest::portfolios_size() const {
  return portfolios_.size();
}
inline void AddPortfolioRequest::clear_portfolios() {
  portfolios_.Clear();
}
inline const ::entity::PortfolioItem& AddPortfolioRequest::portfolios(int index) const {
  return portfolios_.Get(index);
}
inline ::entity::PortfolioItem* AddPortfolioRequest::mutable_portfolios(int index) {
  return portfolios_.Mutable(index);
}
inline ::entity::PortfolioItem* AddPortfolioRequest::add_portfolios() {
  return portfolios_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >&
AddPortfolioRequest::portfolios() const {
  return portfolios_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >*
AddPortfolioRequest::mutable_portfolios() {
  return &portfolios_;
}

// -------------------------------------------------------------------

// SwitchPortfolioRequest

// required string PID = 1;
inline bool SwitchPortfolioRequest::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchPortfolioRequest::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwitchPortfolioRequest::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwitchPortfolioRequest::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& SwitchPortfolioRequest::pid() const {
  return *pid_;
}
inline void SwitchPortfolioRequest::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void SwitchPortfolioRequest::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void SwitchPortfolioRequest::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwitchPortfolioRequest::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* SwitchPortfolioRequest::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.PortfolioSwitchType SwitchType = 2;
inline bool SwitchPortfolioRequest::has_switchtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwitchPortfolioRequest::set_has_switchtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwitchPortfolioRequest::clear_has_switchtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwitchPortfolioRequest::clear_switchtype() {
  switchtype_ = 0;
  clear_has_switchtype();
}
inline entity::PortfolioSwitchType SwitchPortfolioRequest::switchtype() const {
  return static_cast< entity::PortfolioSwitchType >(switchtype_);
}
inline void SwitchPortfolioRequest::set_switchtype(entity::PortfolioSwitchType value) {
  GOOGLE_DCHECK(entity::PortfolioSwitchType_IsValid(value));
  set_has_switchtype();
  switchtype_ = value;
}

// optional bool StartStrategy = 11;
inline bool SwitchPortfolioRequest::has_startstrategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwitchPortfolioRequest::set_has_startstrategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwitchPortfolioRequest::clear_has_startstrategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwitchPortfolioRequest::clear_startstrategy() {
  startstrategy_ = false;
  clear_has_startstrategy();
}
inline bool SwitchPortfolioRequest::startstrategy() const {
  return startstrategy_;
}
inline void SwitchPortfolioRequest::set_startstrategy(bool value) {
  set_has_startstrategy();
  startstrategy_ = value;
}

// optional int32 LastOrderId = 12;
inline bool SwitchPortfolioRequest::has_lastorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwitchPortfolioRequest::set_has_lastorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwitchPortfolioRequest::clear_has_lastorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwitchPortfolioRequest::clear_lastorderid() {
  lastorderid_ = 0;
  clear_has_lastorderid();
}
inline ::google::protobuf::int32 SwitchPortfolioRequest::lastorderid() const {
  return lastorderid_;
}
inline void SwitchPortfolioRequest::set_lastorderid(::google::protobuf::int32 value) {
  set_has_lastorderid();
  lastorderid_ = value;
}

// optional int32 TriggerIndex = 21;
inline bool SwitchPortfolioRequest::has_triggerindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwitchPortfolioRequest::set_has_triggerindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwitchPortfolioRequest::clear_has_triggerindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwitchPortfolioRequest::clear_triggerindex() {
  triggerindex_ = 0;
  clear_has_triggerindex();
}
inline ::google::protobuf::int32 SwitchPortfolioRequest::triggerindex() const {
  return triggerindex_;
}
inline void SwitchPortfolioRequest::set_triggerindex(::google::protobuf::int32 value) {
  set_has_triggerindex();
  triggerindex_ = value;
}

// optional bool EnableTrigger = 22;
inline bool SwitchPortfolioRequest::has_enabletrigger() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SwitchPortfolioRequest::set_has_enabletrigger() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SwitchPortfolioRequest::clear_has_enabletrigger() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SwitchPortfolioRequest::clear_enabletrigger() {
  enabletrigger_ = false;
  clear_has_enabletrigger();
}
inline bool SwitchPortfolioRequest::enabletrigger() const {
  return enabletrigger_;
}
inline void SwitchPortfolioRequest::set_enabletrigger(bool value) {
  set_has_enabletrigger();
  enabletrigger_ = value;
}

// -------------------------------------------------------------------

// ApplyStrategySettingsRequest

// required string PID = 1;
inline bool ApplyStrategySettingsRequest::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyStrategySettingsRequest::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyStrategySettingsRequest::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyStrategySettingsRequest::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& ApplyStrategySettingsRequest::pid() const {
  return *pid_;
}
inline void ApplyStrategySettingsRequest::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void ApplyStrategySettingsRequest::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void ApplyStrategySettingsRequest::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplyStrategySettingsRequest::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* ApplyStrategySettingsRequest::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.StrategyItem Strategy = 2;
inline bool ApplyStrategySettingsRequest::has_strategy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyStrategySettingsRequest::set_has_strategy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyStrategySettingsRequest::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyStrategySettingsRequest::clear_strategy() {
  if (strategy_ != NULL) strategy_->::entity::StrategyItem::Clear();
  clear_has_strategy();
}
inline const ::entity::StrategyItem& ApplyStrategySettingsRequest::strategy() const {
  return strategy_ != NULL ? *strategy_ : *default_instance_->strategy_;
}
inline ::entity::StrategyItem* ApplyStrategySettingsRequest::mutable_strategy() {
  set_has_strategy();
  if (strategy_ == NULL) strategy_ = new ::entity::StrategyItem;
  return strategy_;
}
inline ::entity::StrategyItem* ApplyStrategySettingsRequest::release_strategy() {
  clear_has_strategy();
  ::entity::StrategyItem* temp = strategy_;
  strategy_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// StringParam

// required string Data = 1;
inline bool StringParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringParam::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& StringParam::data() const {
  return *data_;
}
inline void StringParam::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StringParam::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringParam::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* StringParam::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IntParam

// required int32 Data = 2;
inline bool IntParam::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntParam::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntParam::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntParam::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 IntParam::data() const {
  return data_;
}
inline void IntParam::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
}

// -------------------------------------------------------------------

// LegItem

// required int32 LegId = 1;
inline bool LegItem::has_legid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegItem::set_has_legid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegItem::clear_has_legid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegItem::clear_legid() {
  legid_ = 0;
  clear_has_legid();
}
inline ::google::protobuf::int32 LegItem::legid() const {
  return legid_;
}
inline void LegItem::set_legid(::google::protobuf::int32 value) {
  set_has_legid();
  legid_ = value;
}

// required string Symbol = 2;
inline bool LegItem::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegItem::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegItem::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegItem::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& LegItem::symbol() const {
  return *symbol_;
}
inline void LegItem::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegItem::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegItem::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* LegItem::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Ratio = 3;
inline bool LegItem::has_ratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegItem::set_has_ratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegItem::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegItem::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline ::google::protobuf::int32 LegItem::ratio() const {
  return ratio_;
}
inline void LegItem::set_ratio(::google::protobuf::int32 value) {
  set_has_ratio();
  ratio_ = value;
}

// required .entity.PosiDirectionType Side = 4;
inline bool LegItem::has_side() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegItem::set_has_side() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegItem::clear_has_side() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegItem::clear_side() {
  side_ = 49;
  clear_has_side();
}
inline entity::PosiDirectionType LegItem::side() const {
  return static_cast< entity::PosiDirectionType >(side_);
}
inline void LegItem::set_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_side();
  side_ = value;
}

// required bool IsPreferred = 5;
inline bool LegItem::has_ispreferred() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegItem::set_has_ispreferred() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegItem::clear_has_ispreferred() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegItem::clear_ispreferred() {
  ispreferred_ = false;
  clear_has_ispreferred();
}
inline bool LegItem::ispreferred() const {
  return ispreferred_;
}
inline void LegItem::set_ispreferred(bool value) {
  set_has_ispreferred();
  ispreferred_ = value;
}

// -------------------------------------------------------------------

// LegUpdateItem

// required string Symbol = 1;
inline bool LegUpdateItem::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegUpdateItem::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegUpdateItem::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegUpdateItem::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& LegUpdateItem::symbol() const {
  return *symbol_;
}
inline void LegUpdateItem::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegUpdateItem::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void LegUpdateItem::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegUpdateItem::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* LegUpdateItem::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.LegStatus Status = 2;
inline bool LegUpdateItem::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegUpdateItem::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegUpdateItem::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegUpdateItem::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline entity::LegStatus LegUpdateItem::status() const {
  return static_cast< entity::LegStatus >(status_);
}
inline void LegUpdateItem::set_status(entity::LegStatus value) {
  GOOGLE_DCHECK(entity::LegStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// required double Last = 3;
inline bool LegUpdateItem::has_last() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegUpdateItem::set_has_last() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegUpdateItem::clear_has_last() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegUpdateItem::clear_last() {
  last_ = 0;
  clear_has_last();
}
inline double LegUpdateItem::last() const {
  return last_;
}
inline void LegUpdateItem::set_last(double value) {
  set_has_last();
  last_ = value;
}

// required double Ask = 4;
inline bool LegUpdateItem::has_ask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegUpdateItem::set_has_ask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegUpdateItem::clear_has_ask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegUpdateItem::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline double LegUpdateItem::ask() const {
  return ask_;
}
inline void LegUpdateItem::set_ask(double value) {
  set_has_ask();
  ask_ = value;
}

// required int32 AskSize = 5;
inline bool LegUpdateItem::has_asksize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegUpdateItem::set_has_asksize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegUpdateItem::clear_has_asksize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegUpdateItem::clear_asksize() {
  asksize_ = 0;
  clear_has_asksize();
}
inline ::google::protobuf::int32 LegUpdateItem::asksize() const {
  return asksize_;
}
inline void LegUpdateItem::set_asksize(::google::protobuf::int32 value) {
  set_has_asksize();
  asksize_ = value;
}

// required double Bid = 6;
inline bool LegUpdateItem::has_bid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LegUpdateItem::set_has_bid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LegUpdateItem::clear_has_bid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LegUpdateItem::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline double LegUpdateItem::bid() const {
  return bid_;
}
inline void LegUpdateItem::set_bid(double value) {
  set_has_bid();
  bid_ = value;
}

// required int32 BidSize = 7;
inline bool LegUpdateItem::has_bidsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LegUpdateItem::set_has_bidsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LegUpdateItem::clear_has_bidsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LegUpdateItem::clear_bidsize() {
  bidsize_ = 0;
  clear_has_bidsize();
}
inline ::google::protobuf::int32 LegUpdateItem::bidsize() const {
  return bidsize_;
}
inline void LegUpdateItem::set_bidsize(::google::protobuf::int32 value) {
  set_has_bidsize();
  bidsize_ = value;
}

// -------------------------------------------------------------------

// HistSourceCfg

// required string Symbol = 1;
inline bool HistSourceCfg::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistSourceCfg::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistSourceCfg::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistSourceCfg::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& HistSourceCfg::symbol() const {
  return *symbol_;
}
inline void HistSourceCfg::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void HistSourceCfg::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void HistSourceCfg::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HistSourceCfg::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* HistSourceCfg::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Precision = 2;
inline bool HistSourceCfg::has_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistSourceCfg::set_has_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistSourceCfg::clear_has_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistSourceCfg::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::google::protobuf::int32 HistSourceCfg::precision() const {
  return precision_;
}
inline void HistSourceCfg::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// -------------------------------------------------------------------

// StrategyItem

// required .entity.StrategyType Type = 1;
inline bool StrategyItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrategyItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrategyItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrategyItem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline entity::StrategyType StrategyItem::type() const {
  return static_cast< entity::StrategyType >(type_);
}
inline void StrategyItem::set_type(entity::StrategyType value) {
  GOOGLE_DCHECK(entity::StrategyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 RetryTimes = 2;
inline bool StrategyItem::has_retrytimes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrategyItem::set_has_retrytimes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrategyItem::clear_has_retrytimes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrategyItem::clear_retrytimes() {
  retrytimes_ = 0;
  clear_has_retrytimes();
}
inline ::google::protobuf::int32 StrategyItem::retrytimes() const {
  return retrytimes_;
}
inline void StrategyItem::set_retrytimes(::google::protobuf::int32 value) {
  set_has_retrytimes();
  retrytimes_ = value;
}

// required int32 OpenTimeout = 3;
inline bool StrategyItem::has_opentimeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrategyItem::set_has_opentimeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrategyItem::clear_has_opentimeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrategyItem::clear_opentimeout() {
  opentimeout_ = 0;
  clear_has_opentimeout();
}
inline ::google::protobuf::int32 StrategyItem::opentimeout() const {
  return opentimeout_;
}
inline void StrategyItem::set_opentimeout(::google::protobuf::int32 value) {
  set_has_opentimeout();
  opentimeout_ = value;
}

// repeated .entity.TriggerItem Triggers = 4;
inline int StrategyItem::triggers_size() const {
  return triggers_.size();
}
inline void StrategyItem::clear_triggers() {
  triggers_.Clear();
}
inline const ::entity::TriggerItem& StrategyItem::triggers(int index) const {
  return triggers_.Get(index);
}
inline ::entity::TriggerItem* StrategyItem::mutable_triggers(int index) {
  return triggers_.Mutable(index);
}
inline ::entity::TriggerItem* StrategyItem::add_triggers() {
  return triggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::TriggerItem >&
StrategyItem::triggers() const {
  return triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::TriggerItem >*
StrategyItem::mutable_triggers() {
  return &triggers_;
}

// optional .entity.PosiDirectionType AR_Side = 101;
inline bool StrategyItem::has_ar_side() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StrategyItem::set_has_ar_side() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StrategyItem::clear_has_ar_side() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StrategyItem::clear_ar_side() {
  ar_side_ = 49;
  clear_has_ar_side();
}
inline entity::PosiDirectionType StrategyItem::ar_side() const {
  return static_cast< entity::PosiDirectionType >(ar_side_);
}
inline void StrategyItem::set_ar_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_ar_side();
  ar_side_ = value;
}

// optional string CP_CloseLeg = 201;
inline bool StrategyItem::has_cp_closeleg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StrategyItem::set_has_cp_closeleg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StrategyItem::clear_has_cp_closeleg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StrategyItem::clear_cp_closeleg() {
  if (cp_closeleg_ != &::google::protobuf::internal::kEmptyString) {
    cp_closeleg_->clear();
  }
  clear_has_cp_closeleg();
}
inline const ::std::string& StrategyItem::cp_closeleg() const {
  return *cp_closeleg_;
}
inline void StrategyItem::set_cp_closeleg(const ::std::string& value) {
  set_has_cp_closeleg();
  if (cp_closeleg_ == &::google::protobuf::internal::kEmptyString) {
    cp_closeleg_ = new ::std::string;
  }
  cp_closeleg_->assign(value);
}
inline void StrategyItem::set_cp_closeleg(const char* value) {
  set_has_cp_closeleg();
  if (cp_closeleg_ == &::google::protobuf::internal::kEmptyString) {
    cp_closeleg_ = new ::std::string;
  }
  cp_closeleg_->assign(value);
}
inline void StrategyItem::set_cp_closeleg(const char* value, size_t size) {
  set_has_cp_closeleg();
  if (cp_closeleg_ == &::google::protobuf::internal::kEmptyString) {
    cp_closeleg_ = new ::std::string;
  }
  cp_closeleg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyItem::mutable_cp_closeleg() {
  set_has_cp_closeleg();
  if (cp_closeleg_ == &::google::protobuf::internal::kEmptyString) {
    cp_closeleg_ = new ::std::string;
  }
  return cp_closeleg_;
}
inline ::std::string* StrategyItem::release_cp_closeleg() {
  clear_has_cp_closeleg();
  if (cp_closeleg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cp_closeleg_;
    cp_closeleg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .entity.PosiDirectionType CP_CloseLegSide = 202;
inline bool StrategyItem::has_cp_closelegside() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StrategyItem::set_has_cp_closelegside() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StrategyItem::clear_has_cp_closelegside() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StrategyItem::clear_cp_closelegside() {
  cp_closelegside_ = 49;
  clear_has_cp_closelegside();
}
inline entity::PosiDirectionType StrategyItem::cp_closelegside() const {
  return static_cast< entity::PosiDirectionType >(cp_closelegside_);
}
inline void StrategyItem::set_cp_closelegside(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_cp_closelegside();
  cp_closelegside_ = value;
}

// optional double SC_PriceTick = 301;
inline bool StrategyItem::has_sc_pricetick() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StrategyItem::set_has_sc_pricetick() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StrategyItem::clear_has_sc_pricetick() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StrategyItem::clear_sc_pricetick() {
  sc_pricetick_ = 0;
  clear_has_sc_pricetick();
}
inline double StrategyItem::sc_pricetick() const {
  return sc_pricetick_;
}
inline void StrategyItem::set_sc_pricetick(double value) {
  set_has_sc_pricetick();
  sc_pricetick_ = value;
}

// optional .entity.DirectionDepends SC_CaseLE2Tick = 302;
inline bool StrategyItem::has_sc_casele2tick() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StrategyItem::set_has_sc_casele2tick() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StrategyItem::clear_has_sc_casele2tick() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StrategyItem::clear_sc_casele2tick() {
  sc_casele2tick_ = 0;
  clear_has_sc_casele2tick();
}
inline entity::DirectionDepends StrategyItem::sc_casele2tick() const {
  return static_cast< entity::DirectionDepends >(sc_casele2tick_);
}
inline void StrategyItem::set_sc_casele2tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_sc_casele2tick();
  sc_casele2tick_ = value;
}

// optional .entity.DirectionDepends SC_CaseLE3Tick = 303;
inline bool StrategyItem::has_sc_casele3tick() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StrategyItem::set_has_sc_casele3tick() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StrategyItem::clear_has_sc_casele3tick() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StrategyItem::clear_sc_casele3tick() {
  sc_casele3tick_ = 0;
  clear_has_sc_casele3tick();
}
inline entity::DirectionDepends StrategyItem::sc_casele3tick() const {
  return static_cast< entity::DirectionDepends >(sc_casele3tick_);
}
inline void StrategyItem::set_sc_casele3tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_sc_casele3tick();
  sc_casele3tick_ = value;
}

// optional .entity.DirectionDepends SC_CaseGE4Tick = 304;
inline bool StrategyItem::has_sc_casege4tick() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StrategyItem::set_has_sc_casege4tick() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StrategyItem::clear_has_sc_casege4tick() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StrategyItem::clear_sc_casege4tick() {
  sc_casege4tick_ = 0;
  clear_has_sc_casege4tick();
}
inline entity::DirectionDepends StrategyItem::sc_casege4tick() const {
  return static_cast< entity::DirectionDepends >(sc_casege4tick_);
}
inline void StrategyItem::set_sc_casege4tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_sc_casege4tick();
  sc_casege4tick_ = value;
}

// optional .entity.DirectionDepends SC_CaseNoChange = 305;
inline bool StrategyItem::has_sc_casenochange() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StrategyItem::set_has_sc_casenochange() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StrategyItem::clear_has_sc_casenochange() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StrategyItem::clear_sc_casenochange() {
  sc_casenochange_ = 0;
  clear_has_sc_casenochange();
}
inline entity::DirectionDepends StrategyItem::sc_casenochange() const {
  return static_cast< entity::DirectionDepends >(sc_casenochange_);
}
inline void StrategyItem::set_sc_casenochange(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_sc_casenochange();
  sc_casenochange_ = value;
}

// optional .entity.StopLossCloseMethods SC_StopLossStrategy = 306;
inline bool StrategyItem::has_sc_stoplossstrategy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StrategyItem::set_has_sc_stoplossstrategy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StrategyItem::clear_has_sc_stoplossstrategy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StrategyItem::clear_sc_stoplossstrategy() {
  sc_stoplossstrategy_ = 0;
  clear_has_sc_stoplossstrategy();
}
inline entity::StopLossCloseMethods StrategyItem::sc_stoplossstrategy() const {
  return static_cast< entity::StopLossCloseMethods >(sc_stoplossstrategy_);
}
inline void StrategyItem::set_sc_stoplossstrategy(entity::StopLossCloseMethods value) {
  GOOGLE_DCHECK(entity::StopLossCloseMethods_IsValid(value));
  set_has_sc_stoplossstrategy();
  sc_stoplossstrategy_ = value;
}

// repeated .entity.HistSourceCfg HistSources = 401;
inline int StrategyItem::histsources_size() const {
  return histsources_.size();
}
inline void StrategyItem::clear_histsources() {
  histsources_.Clear();
}
inline const ::entity::HistSourceCfg& StrategyItem::histsources(int index) const {
  return histsources_.Get(index);
}
inline ::entity::HistSourceCfg* StrategyItem::mutable_histsources(int index) {
  return histsources_.Mutable(index);
}
inline ::entity::HistSourceCfg* StrategyItem::add_histsources() {
  return histsources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::HistSourceCfg >&
StrategyItem::histsources() const {
  return histsources_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::HistSourceCfg >*
StrategyItem::mutable_histsources() {
  return &histsources_;
}

// optional int32 HS_Short = 501;
inline bool StrategyItem::has_hs_short() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StrategyItem::set_has_hs_short() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StrategyItem::clear_has_hs_short() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StrategyItem::clear_hs_short() {
  hs_short_ = 0;
  clear_has_hs_short();
}
inline ::google::protobuf::int32 StrategyItem::hs_short() const {
  return hs_short_;
}
inline void StrategyItem::set_hs_short(::google::protobuf::int32 value) {
  set_has_hs_short();
  hs_short_ = value;
}

// optional int32 HS_Long = 502;
inline bool StrategyItem::has_hs_long() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StrategyItem::set_has_hs_long() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StrategyItem::clear_has_hs_long() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StrategyItem::clear_hs_long() {
  hs_long_ = 0;
  clear_has_hs_long();
}
inline ::google::protobuf::int32 StrategyItem::hs_long() const {
  return hs_long_;
}
inline void StrategyItem::set_hs_long(::google::protobuf::int32 value) {
  set_has_hs_long();
  hs_long_ = value;
}

// optional int32 HS_M = 503;
inline bool StrategyItem::has_hs_m() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StrategyItem::set_has_hs_m() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StrategyItem::clear_has_hs_m() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StrategyItem::clear_hs_m() {
  hs_m_ = 0;
  clear_has_hs_m();
}
inline ::google::protobuf::int32 StrategyItem::hs_m() const {
  return hs_m_;
}
inline void StrategyItem::set_hs_m(::google::protobuf::int32 value) {
  set_has_hs_m();
  hs_m_ = value;
}

// optional double HS_FastStdDiff = 504;
inline bool StrategyItem::has_hs_faststddiff() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StrategyItem::set_has_hs_faststddiff() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StrategyItem::clear_has_hs_faststddiff() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StrategyItem::clear_hs_faststddiff() {
  hs_faststddiff_ = 0;
  clear_has_hs_faststddiff();
}
inline double StrategyItem::hs_faststddiff() const {
  return hs_faststddiff_;
}
inline void StrategyItem::set_hs_faststddiff(double value) {
  set_has_hs_faststddiff();
  hs_faststddiff_ = value;
}

// optional double HS_SlowStdDiff = 505;
inline bool StrategyItem::has_hs_slowstddiff() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StrategyItem::set_has_hs_slowstddiff() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StrategyItem::clear_has_hs_slowstddiff() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void StrategyItem::clear_hs_slowstddiff() {
  hs_slowstddiff_ = 0;
  clear_has_hs_slowstddiff();
}
inline double StrategyItem::hs_slowstddiff() const {
  return hs_slowstddiff_;
}
inline void StrategyItem::set_hs_slowstddiff(double value) {
  set_has_hs_slowstddiff();
  hs_slowstddiff_ = value;
}

// optional int32 HS_FastPeriod = 506;
inline bool StrategyItem::has_hs_fastperiod() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StrategyItem::set_has_hs_fastperiod() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StrategyItem::clear_has_hs_fastperiod() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StrategyItem::clear_hs_fastperiod() {
  hs_fastperiod_ = 0;
  clear_has_hs_fastperiod();
}
inline ::google::protobuf::int32 StrategyItem::hs_fastperiod() const {
  return hs_fastperiod_;
}
inline void StrategyItem::set_hs_fastperiod(::google::protobuf::int32 value) {
  set_has_hs_fastperiod();
  hs_fastperiod_ = value;
}

// optional int32 HS_SlowPeriod = 507;
inline bool StrategyItem::has_hs_slowperiod() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void StrategyItem::set_has_hs_slowperiod() {
  _has_bits_[0] |= 0x00100000u;
}
inline void StrategyItem::clear_has_hs_slowperiod() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void StrategyItem::clear_hs_slowperiod() {
  hs_slowperiod_ = 0;
  clear_has_hs_slowperiod();
}
inline ::google::protobuf::int32 StrategyItem::hs_slowperiod() const {
  return hs_slowperiod_;
}
inline void StrategyItem::set_hs_slowperiod(::google::protobuf::int32 value) {
  set_has_hs_slowperiod();
  hs_slowperiod_ = value;
}

// optional double HS_FastShortEMASeed = 508;
inline bool StrategyItem::has_hs_fastshortemaseed() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void StrategyItem::set_has_hs_fastshortemaseed() {
  _has_bits_[0] |= 0x00200000u;
}
inline void StrategyItem::clear_has_hs_fastshortemaseed() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void StrategyItem::clear_hs_fastshortemaseed() {
  hs_fastshortemaseed_ = 0;
  clear_has_hs_fastshortemaseed();
}
inline double StrategyItem::hs_fastshortemaseed() const {
  return hs_fastshortemaseed_;
}
inline void StrategyItem::set_hs_fastshortemaseed(double value) {
  set_has_hs_fastshortemaseed();
  hs_fastshortemaseed_ = value;
}

// optional double HS_FastLongEMASeed = 509;
inline bool StrategyItem::has_hs_fastlongemaseed() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void StrategyItem::set_has_hs_fastlongemaseed() {
  _has_bits_[0] |= 0x00400000u;
}
inline void StrategyItem::clear_has_hs_fastlongemaseed() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void StrategyItem::clear_hs_fastlongemaseed() {
  hs_fastlongemaseed_ = 0;
  clear_has_hs_fastlongemaseed();
}
inline double StrategyItem::hs_fastlongemaseed() const {
  return hs_fastlongemaseed_;
}
inline void StrategyItem::set_hs_fastlongemaseed(double value) {
  set_has_hs_fastlongemaseed();
  hs_fastlongemaseed_ = value;
}

// optional double HS_FastSignalEMASeed = 510;
inline bool StrategyItem::has_hs_fastsignalemaseed() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void StrategyItem::set_has_hs_fastsignalemaseed() {
  _has_bits_[0] |= 0x00800000u;
}
inline void StrategyItem::clear_has_hs_fastsignalemaseed() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void StrategyItem::clear_hs_fastsignalemaseed() {
  hs_fastsignalemaseed_ = 0;
  clear_has_hs_fastsignalemaseed();
}
inline double StrategyItem::hs_fastsignalemaseed() const {
  return hs_fastsignalemaseed_;
}
inline void StrategyItem::set_hs_fastsignalemaseed(double value) {
  set_has_hs_fastsignalemaseed();
  hs_fastsignalemaseed_ = value;
}

// optional double HS_SlowShortEMASeed = 511;
inline bool StrategyItem::has_hs_slowshortemaseed() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void StrategyItem::set_has_hs_slowshortemaseed() {
  _has_bits_[0] |= 0x01000000u;
}
inline void StrategyItem::clear_has_hs_slowshortemaseed() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void StrategyItem::clear_hs_slowshortemaseed() {
  hs_slowshortemaseed_ = 0;
  clear_has_hs_slowshortemaseed();
}
inline double StrategyItem::hs_slowshortemaseed() const {
  return hs_slowshortemaseed_;
}
inline void StrategyItem::set_hs_slowshortemaseed(double value) {
  set_has_hs_slowshortemaseed();
  hs_slowshortemaseed_ = value;
}

// optional double HS_SlowLongEMASeed = 512;
inline bool StrategyItem::has_hs_slowlongemaseed() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void StrategyItem::set_has_hs_slowlongemaseed() {
  _has_bits_[0] |= 0x02000000u;
}
inline void StrategyItem::clear_has_hs_slowlongemaseed() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void StrategyItem::clear_hs_slowlongemaseed() {
  hs_slowlongemaseed_ = 0;
  clear_has_hs_slowlongemaseed();
}
inline double StrategyItem::hs_slowlongemaseed() const {
  return hs_slowlongemaseed_;
}
inline void StrategyItem::set_hs_slowlongemaseed(double value) {
  set_has_hs_slowlongemaseed();
  hs_slowlongemaseed_ = value;
}

// optional double HS_SlowSignalEMASeed = 513;
inline bool StrategyItem::has_hs_slowsignalemaseed() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void StrategyItem::set_has_hs_slowsignalemaseed() {
  _has_bits_[0] |= 0x04000000u;
}
inline void StrategyItem::clear_has_hs_slowsignalemaseed() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void StrategyItem::clear_hs_slowsignalemaseed() {
  hs_slowsignalemaseed_ = 0;
  clear_has_hs_slowsignalemaseed();
}
inline double StrategyItem::hs_slowsignalemaseed() const {
  return hs_slowsignalemaseed_;
}
inline void StrategyItem::set_hs_slowsignalemaseed(double value) {
  set_has_hs_slowsignalemaseed();
  hs_slowsignalemaseed_ = value;
}

// optional int32 DX_BollM = 521;
inline bool StrategyItem::has_dx_bollm() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void StrategyItem::set_has_dx_bollm() {
  _has_bits_[0] |= 0x08000000u;
}
inline void StrategyItem::clear_has_dx_bollm() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void StrategyItem::clear_dx_bollm() {
  dx_bollm_ = 0;
  clear_has_dx_bollm();
}
inline ::google::protobuf::int32 StrategyItem::dx_bollm() const {
  return dx_bollm_;
}
inline void StrategyItem::set_dx_bollm(::google::protobuf::int32 value) {
  set_has_dx_bollm();
  dx_bollm_ = value;
}

// optional int32 DX_BollP = 522;
inline bool StrategyItem::has_dx_bollp() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void StrategyItem::set_has_dx_bollp() {
  _has_bits_[0] |= 0x10000000u;
}
inline void StrategyItem::clear_has_dx_bollp() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void StrategyItem::clear_dx_bollp() {
  dx_bollp_ = 0;
  clear_has_dx_bollp();
}
inline ::google::protobuf::int32 StrategyItem::dx_bollp() const {
  return dx_bollp_;
}
inline void StrategyItem::set_dx_bollp(::google::protobuf::int32 value) {
  set_has_dx_bollp();
  dx_bollp_ = value;
}

// -------------------------------------------------------------------

// TriggerItem

// required .entity.StrategyType Strategy = 1;
inline bool TriggerItem::has_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerItem::set_has_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerItem::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerItem::clear_strategy() {
  strategy_ = 0;
  clear_has_strategy();
}
inline entity::StrategyType TriggerItem::strategy() const {
  return static_cast< entity::StrategyType >(strategy_);
}
inline void TriggerItem::set_strategy(entity::StrategyType value) {
  GOOGLE_DCHECK(entity::StrategyType_IsValid(value));
  set_has_strategy();
  strategy_ = value;
}

// required string Name = 2;
inline bool TriggerItem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerItem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TriggerItem::name() const {
  return *name_;
}
inline void TriggerItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TriggerItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TriggerItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TriggerItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool Enabled = 3;
inline bool TriggerItem::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerItem::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerItem::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerItem::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool TriggerItem::enabled() const {
  return enabled_;
}
inline void TriggerItem::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional .entity.CompareCondition AR_Condition = 101;
inline bool TriggerItem::has_ar_condition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TriggerItem::set_has_ar_condition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TriggerItem::clear_has_ar_condition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TriggerItem::clear_ar_condition() {
  ar_condition_ = 0;
  clear_has_ar_condition();
}
inline entity::CompareCondition TriggerItem::ar_condition() const {
  return static_cast< entity::CompareCondition >(ar_condition_);
}
inline void TriggerItem::set_ar_condition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_ar_condition();
  ar_condition_ = value;
}

// optional double AR_Threshold = 102;
inline bool TriggerItem::has_ar_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TriggerItem::set_has_ar_threshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TriggerItem::clear_has_ar_threshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TriggerItem::clear_ar_threshold() {
  ar_threshold_ = 0;
  clear_has_ar_threshold();
}
inline double TriggerItem::ar_threshold() const {
  return ar_threshold_;
}
inline void TriggerItem::set_ar_threshold(double value) {
  set_has_ar_threshold();
  ar_threshold_ = value;
}

// optional .entity.PosiOffsetFlag AR_Offset = 103;
inline bool TriggerItem::has_ar_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TriggerItem::set_has_ar_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TriggerItem::clear_has_ar_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TriggerItem::clear_ar_offset() {
  ar_offset_ = 0;
  clear_has_ar_offset();
}
inline entity::PosiOffsetFlag TriggerItem::ar_offset() const {
  return static_cast< entity::PosiOffsetFlag >(ar_offset_);
}
inline void TriggerItem::set_ar_offset(entity::PosiOffsetFlag value) {
  GOOGLE_DCHECK(entity::PosiOffsetFlag_IsValid(value));
  set_has_ar_offset();
  ar_offset_ = value;
}

// optional .entity.CompareCondition CP_Condition = 201;
inline bool TriggerItem::has_cp_condition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TriggerItem::set_has_cp_condition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TriggerItem::clear_has_cp_condition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TriggerItem::clear_cp_condition() {
  cp_condition_ = 0;
  clear_has_cp_condition();
}
inline entity::CompareCondition TriggerItem::cp_condition() const {
  return static_cast< entity::CompareCondition >(cp_condition_);
}
inline void TriggerItem::set_cp_condition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_cp_condition();
  cp_condition_ = value;
}

// optional double CP_Threshold = 202;
inline bool TriggerItem::has_cp_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TriggerItem::set_has_cp_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TriggerItem::clear_has_cp_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TriggerItem::clear_cp_threshold() {
  cp_threshold_ = 0;
  clear_has_cp_threshold();
}
inline double TriggerItem::cp_threshold() const {
  return cp_threshold_;
}
inline void TriggerItem::set_cp_threshold(double value) {
  set_has_cp_threshold();
  cp_threshold_ = value;
}

// optional double SC_Threshold = 301;
inline bool TriggerItem::has_sc_threshold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TriggerItem::set_has_sc_threshold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TriggerItem::clear_has_sc_threshold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TriggerItem::clear_sc_threshold() {
  sc_threshold_ = 0;
  clear_has_sc_threshold();
}
inline double TriggerItem::sc_threshold() const {
  return sc_threshold_;
}
inline void TriggerItem::set_sc_threshold(double value) {
  set_has_sc_threshold();
  sc_threshold_ = value;
}

// optional .entity.PosiOffsetFlag HS_Offset = 401;
inline bool TriggerItem::has_hs_offset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TriggerItem::set_has_hs_offset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TriggerItem::clear_has_hs_offset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TriggerItem::clear_hs_offset() {
  hs_offset_ = 0;
  clear_has_hs_offset();
}
inline entity::PosiOffsetFlag TriggerItem::hs_offset() const {
  return static_cast< entity::PosiOffsetFlag >(hs_offset_);
}
inline void TriggerItem::set_hs_offset(entity::PosiOffsetFlag value) {
  GOOGLE_DCHECK(entity::PosiOffsetFlag_IsValid(value));
  set_has_hs_offset();
  hs_offset_ = value;
}

// optional double HS_FastAngleThreshold = 402;
inline bool TriggerItem::has_hs_fastanglethreshold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TriggerItem::set_has_hs_fastanglethreshold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TriggerItem::clear_has_hs_fastanglethreshold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TriggerItem::clear_hs_fastanglethreshold() {
  hs_fastanglethreshold_ = 0;
  clear_has_hs_fastanglethreshold();
}
inline double TriggerItem::hs_fastanglethreshold() const {
  return hs_fastanglethreshold_;
}
inline void TriggerItem::set_hs_fastanglethreshold(double value) {
  set_has_hs_fastanglethreshold();
  hs_fastanglethreshold_ = value;
}

// optional double HS_SlowAngleThreshold = 403;
inline bool TriggerItem::has_hs_slowanglethreshold() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TriggerItem::set_has_hs_slowanglethreshold() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TriggerItem::clear_has_hs_slowanglethreshold() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TriggerItem::clear_hs_slowanglethreshold() {
  hs_slowanglethreshold_ = 0;
  clear_has_hs_slowanglethreshold();
}
inline double TriggerItem::hs_slowanglethreshold() const {
  return hs_slowanglethreshold_;
}
inline void TriggerItem::set_hs_slowanglethreshold(double value) {
  set_has_hs_slowanglethreshold();
  hs_slowanglethreshold_ = value;
}

// optional double TS_BackValue = 411;
inline bool TriggerItem::has_ts_backvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TriggerItem::set_has_ts_backvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TriggerItem::clear_has_ts_backvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TriggerItem::clear_ts_backvalue() {
  ts_backvalue_ = 0;
  clear_has_ts_backvalue();
}
inline double TriggerItem::ts_backvalue() const {
  return ts_backvalue_;
}
inline void TriggerItem::set_ts_backvalue(double value) {
  set_has_ts_backvalue();
  ts_backvalue_ = value;
}

// -------------------------------------------------------------------

// TriggerStatus

// required .entity.StrategyType Strategy = 1;
inline bool TriggerStatus::has_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggerStatus::set_has_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggerStatus::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggerStatus::clear_strategy() {
  strategy_ = 0;
  clear_has_strategy();
}
inline entity::StrategyType TriggerStatus::strategy() const {
  return static_cast< entity::StrategyType >(strategy_);
}
inline void TriggerStatus::set_strategy(entity::StrategyType value) {
  GOOGLE_DCHECK(entity::StrategyType_IsValid(value));
  set_has_strategy();
  strategy_ = value;
}

// required string Name = 2;
inline bool TriggerStatus::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggerStatus::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggerStatus::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggerStatus::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TriggerStatus::name() const {
  return *name_;
}
inline void TriggerStatus::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TriggerStatus::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TriggerStatus::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggerStatus::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TriggerStatus::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool Enabled = 3;
inline bool TriggerStatus::has_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggerStatus::set_has_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggerStatus::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggerStatus::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool TriggerStatus::enabled() const {
  return enabled_;
}
inline void TriggerStatus::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// PortfolioItem

// required string ID = 1;
inline bool PortfolioItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortfolioItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortfolioItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortfolioItem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PortfolioItem::id() const {
  return *id_;
}
inline void PortfolioItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PortfolioItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PortfolioItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortfolioItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortfolioItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortfolioItem::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PortfolioItem::quantity() const {
  return quantity_;
}
inline void PortfolioItem::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// repeated .entity.LegItem Legs = 3;
inline int PortfolioItem::legs_size() const {
  return legs_.size();
}
inline void PortfolioItem::clear_legs() {
  legs_.Clear();
}
inline const ::entity::LegItem& PortfolioItem::legs(int index) const {
  return legs_.Get(index);
}
inline ::entity::LegItem* PortfolioItem::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::entity::LegItem* PortfolioItem::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::LegItem >&
PortfolioItem::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::LegItem >*
PortfolioItem::mutable_legs() {
  return &legs_;
}

// required int32 MaxCancel = 4;
inline bool PortfolioItem::has_maxcancel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortfolioItem::set_has_maxcancel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortfolioItem::clear_has_maxcancel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortfolioItem::clear_maxcancel() {
  maxcancel_ = 0;
  clear_has_maxcancel();
}
inline ::google::protobuf::int32 PortfolioItem::maxcancel() const {
  return maxcancel_;
}
inline void PortfolioItem::set_maxcancel(::google::protobuf::int32 value) {
  set_has_maxcancel();
  maxcancel_ = value;
}

// required int32 MaxOpenPerStart = 5;
inline bool PortfolioItem::has_maxopenperstart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PortfolioItem::set_has_maxopenperstart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PortfolioItem::clear_has_maxopenperstart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PortfolioItem::clear_maxopenperstart() {
  maxopenperstart_ = 0;
  clear_has_maxopenperstart();
}
inline ::google::protobuf::int32 PortfolioItem::maxopenperstart() const {
  return maxopenperstart_;
}
inline void PortfolioItem::set_maxopenperstart(::google::protobuf::int32 value) {
  set_has_maxopenperstart();
  maxopenperstart_ = value;
}

// required int32 TotalOpenLimit = 6;
inline bool PortfolioItem::has_totalopenlimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PortfolioItem::set_has_totalopenlimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PortfolioItem::clear_has_totalopenlimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PortfolioItem::clear_totalopenlimit() {
  totalopenlimit_ = 0;
  clear_has_totalopenlimit();
}
inline ::google::protobuf::int32 PortfolioItem::totalopenlimit() const {
  return totalopenlimit_;
}
inline void PortfolioItem::set_totalopenlimit(::google::protobuf::int32 value) {
  set_has_totalopenlimit();
  totalopenlimit_ = value;
}

// repeated string EndTimePoints = 7;
inline int PortfolioItem::endtimepoints_size() const {
  return endtimepoints_.size();
}
inline void PortfolioItem::clear_endtimepoints() {
  endtimepoints_.Clear();
}
inline const ::std::string& PortfolioItem::endtimepoints(int index) const {
  return endtimepoints_.Get(index);
}
inline ::std::string* PortfolioItem::mutable_endtimepoints(int index) {
  return endtimepoints_.Mutable(index);
}
inline void PortfolioItem::set_endtimepoints(int index, const ::std::string& value) {
  endtimepoints_.Mutable(index)->assign(value);
}
inline void PortfolioItem::set_endtimepoints(int index, const char* value) {
  endtimepoints_.Mutable(index)->assign(value);
}
inline void PortfolioItem::set_endtimepoints(int index, const char* value, size_t size) {
  endtimepoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioItem::add_endtimepoints() {
  return endtimepoints_.Add();
}
inline void PortfolioItem::add_endtimepoints(const ::std::string& value) {
  endtimepoints_.Add()->assign(value);
}
inline void PortfolioItem::add_endtimepoints(const char* value) {
  endtimepoints_.Add()->assign(value);
}
inline void PortfolioItem::add_endtimepoints(const char* value, size_t size) {
  endtimepoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PortfolioItem::endtimepoints() const {
  return endtimepoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PortfolioItem::mutable_endtimepoints() {
  return &endtimepoints_;
}

// required .entity.StrategyItem Strategy = 8;
inline bool PortfolioItem::has_strategy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PortfolioItem::set_has_strategy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PortfolioItem::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PortfolioItem::clear_strategy() {
  if (strategy_ != NULL) strategy_->::entity::StrategyItem::Clear();
  clear_has_strategy();
}
inline const ::entity::StrategyItem& PortfolioItem::strategy() const {
  return strategy_ != NULL ? *strategy_ : *default_instance_->strategy_;
}
inline ::entity::StrategyItem* PortfolioItem::mutable_strategy() {
  set_has_strategy();
  if (strategy_ == NULL) strategy_ = new ::entity::StrategyItem;
  return strategy_;
}
inline ::entity::StrategyItem* PortfolioItem::release_strategy() {
  clear_has_strategy();
  ::entity::StrategyItem* temp = strategy_;
  strategy_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PortfolioUpdateItem

// required string ID = 1;
inline bool PortfolioUpdateItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortfolioUpdateItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortfolioUpdateItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortfolioUpdateItem::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& PortfolioUpdateItem::id() const {
  return *id_;
}
inline void PortfolioUpdateItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioUpdateItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void PortfolioUpdateItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioUpdateItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* PortfolioUpdateItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .entity.LegUpdateItem Legs = 2;
inline int PortfolioUpdateItem::legs_size() const {
  return legs_.size();
}
inline void PortfolioUpdateItem::clear_legs() {
  legs_.Clear();
}
inline const ::entity::LegUpdateItem& PortfolioUpdateItem::legs(int index) const {
  return legs_.Get(index);
}
inline ::entity::LegUpdateItem* PortfolioUpdateItem::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::entity::LegUpdateItem* PortfolioUpdateItem::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::LegUpdateItem >&
PortfolioUpdateItem::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::LegUpdateItem >*
PortfolioUpdateItem::mutable_legs() {
  return &legs_;
}

// required .entity.StrategyType Strategy = 3;
inline bool PortfolioUpdateItem::has_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PortfolioUpdateItem::set_has_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PortfolioUpdateItem::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PortfolioUpdateItem::clear_strategy() {
  strategy_ = 0;
  clear_has_strategy();
}
inline entity::StrategyType PortfolioUpdateItem::strategy() const {
  return static_cast< entity::StrategyType >(strategy_);
}
inline void PortfolioUpdateItem::set_strategy(entity::StrategyType value) {
  GOOGLE_DCHECK(entity::StrategyType_IsValid(value));
  set_has_strategy();
  strategy_ = value;
}

// required bool Running = 4;
inline bool PortfolioUpdateItem::has_running() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PortfolioUpdateItem::set_has_running() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PortfolioUpdateItem::clear_has_running() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PortfolioUpdateItem::clear_running() {
  running_ = false;
  clear_has_running();
}
inline bool PortfolioUpdateItem::running() const {
  return running_;
}
inline void PortfolioUpdateItem::set_running(bool value) {
  set_has_running();
  running_ = value;
}

// repeated .entity.TriggerStatus Triggers = 5;
inline int PortfolioUpdateItem::triggers_size() const {
  return triggers_.size();
}
inline void PortfolioUpdateItem::clear_triggers() {
  triggers_.Clear();
}
inline const ::entity::TriggerStatus& PortfolioUpdateItem::triggers(int index) const {
  return triggers_.Get(index);
}
inline ::entity::TriggerStatus* PortfolioUpdateItem::mutable_triggers(int index) {
  return triggers_.Mutable(index);
}
inline ::entity::TriggerStatus* PortfolioUpdateItem::add_triggers() {
  return triggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::TriggerStatus >&
PortfolioUpdateItem::triggers() const {
  return triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::TriggerStatus >*
PortfolioUpdateItem::mutable_triggers() {
  return &triggers_;
}

// required int32 TotalOpenTimes = 6;
inline bool PortfolioUpdateItem::has_totalopentimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PortfolioUpdateItem::set_has_totalopentimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PortfolioUpdateItem::clear_has_totalopentimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PortfolioUpdateItem::clear_totalopentimes() {
  totalopentimes_ = 0;
  clear_has_totalopentimes();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::totalopentimes() const {
  return totalopentimes_;
}
inline void PortfolioUpdateItem::set_totalopentimes(::google::protobuf::int32 value) {
  set_has_totalopentimes();
  totalopentimes_ = value;
}

// required int32 TotalCloseTimes = 7;
inline bool PortfolioUpdateItem::has_totalclosetimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PortfolioUpdateItem::set_has_totalclosetimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PortfolioUpdateItem::clear_has_totalclosetimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PortfolioUpdateItem::clear_totalclosetimes() {
  totalclosetimes_ = 0;
  clear_has_totalclosetimes();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::totalclosetimes() const {
  return totalclosetimes_;
}
inline void PortfolioUpdateItem::set_totalclosetimes(::google::protobuf::int32 value) {
  set_has_totalclosetimes();
  totalclosetimes_ = value;
}

// required int32 CurrentPosition = 8;
inline bool PortfolioUpdateItem::has_currentposition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PortfolioUpdateItem::set_has_currentposition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PortfolioUpdateItem::clear_has_currentposition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PortfolioUpdateItem::clear_currentposition() {
  currentposition_ = 0;
  clear_has_currentposition();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::currentposition() const {
  return currentposition_;
}
inline void PortfolioUpdateItem::set_currentposition(::google::protobuf::int32 value) {
  set_has_currentposition();
  currentposition_ = value;
}

// required int32 CancelTimes = 9;
inline bool PortfolioUpdateItem::has_canceltimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PortfolioUpdateItem::set_has_canceltimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PortfolioUpdateItem::clear_has_canceltimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PortfolioUpdateItem::clear_canceltimes() {
  canceltimes_ = 0;
  clear_has_canceltimes();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::canceltimes() const {
  return canceltimes_;
}
inline void PortfolioUpdateItem::set_canceltimes(::google::protobuf::int32 value) {
  set_has_canceltimes();
  canceltimes_ = value;
}

// required double Profit = 10;
inline bool PortfolioUpdateItem::has_profit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PortfolioUpdateItem::set_has_profit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PortfolioUpdateItem::clear_has_profit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PortfolioUpdateItem::clear_profit() {
  profit_ = 0;
  clear_has_profit();
}
inline double PortfolioUpdateItem::profit() const {
  return profit_;
}
inline void PortfolioUpdateItem::set_profit(double value) {
  set_has_profit();
  profit_ = value;
}

// optional string Message = 11;
inline bool PortfolioUpdateItem::has_message() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PortfolioUpdateItem::set_has_message() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PortfolioUpdateItem::clear_has_message() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PortfolioUpdateItem::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& PortfolioUpdateItem::message() const {
  return *message_;
}
inline void PortfolioUpdateItem::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PortfolioUpdateItem::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void PortfolioUpdateItem::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PortfolioUpdateItem::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* PortfolioUpdateItem::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double AR_Diff = 101;
inline bool PortfolioUpdateItem::has_ar_diff() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PortfolioUpdateItem::set_has_ar_diff() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PortfolioUpdateItem::clear_has_ar_diff() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PortfolioUpdateItem::clear_ar_diff() {
  ar_diff_ = 0;
  clear_has_ar_diff();
}
inline double PortfolioUpdateItem::ar_diff() const {
  return ar_diff_;
}
inline void PortfolioUpdateItem::set_ar_diff(double value) {
  set_has_ar_diff();
  ar_diff_ = value;
}

// optional double AR_LongDiff = 102;
inline bool PortfolioUpdateItem::has_ar_longdiff() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PortfolioUpdateItem::set_has_ar_longdiff() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PortfolioUpdateItem::clear_has_ar_longdiff() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PortfolioUpdateItem::clear_ar_longdiff() {
  ar_longdiff_ = 0;
  clear_has_ar_longdiff();
}
inline double PortfolioUpdateItem::ar_longdiff() const {
  return ar_longdiff_;
}
inline void PortfolioUpdateItem::set_ar_longdiff(double value) {
  set_has_ar_longdiff();
  ar_longdiff_ = value;
}

// optional double AR_ShortDiff = 103;
inline bool PortfolioUpdateItem::has_ar_shortdiff() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PortfolioUpdateItem::set_has_ar_shortdiff() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PortfolioUpdateItem::clear_has_ar_shortdiff() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PortfolioUpdateItem::clear_ar_shortdiff() {
  ar_shortdiff_ = 0;
  clear_has_ar_shortdiff();
}
inline double PortfolioUpdateItem::ar_shortdiff() const {
  return ar_shortdiff_;
}
inline void PortfolioUpdateItem::set_ar_shortdiff(double value) {
  set_has_ar_shortdiff();
  ar_shortdiff_ = value;
}

// optional int32 AR_LongSize = 104;
inline bool PortfolioUpdateItem::has_ar_longsize() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PortfolioUpdateItem::set_has_ar_longsize() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PortfolioUpdateItem::clear_has_ar_longsize() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PortfolioUpdateItem::clear_ar_longsize() {
  ar_longsize_ = 0;
  clear_has_ar_longsize();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::ar_longsize() const {
  return ar_longsize_;
}
inline void PortfolioUpdateItem::set_ar_longsize(::google::protobuf::int32 value) {
  set_has_ar_longsize();
  ar_longsize_ = value;
}

// optional int32 AR_ShortSize = 105;
inline bool PortfolioUpdateItem::has_ar_shortsize() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PortfolioUpdateItem::set_has_ar_shortsize() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PortfolioUpdateItem::clear_has_ar_shortsize() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PortfolioUpdateItem::clear_ar_shortsize() {
  ar_shortsize_ = 0;
  clear_has_ar_shortsize();
}
inline ::google::protobuf::int32 PortfolioUpdateItem::ar_shortsize() const {
  return ar_shortsize_;
}
inline void PortfolioUpdateItem::set_ar_shortsize(::google::protobuf::int32 value) {
  set_has_ar_shortsize();
  ar_shortsize_ = value;
}

// optional double SC_Diff = 201;
inline bool PortfolioUpdateItem::has_sc_diff() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PortfolioUpdateItem::set_has_sc_diff() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PortfolioUpdateItem::clear_has_sc_diff() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PortfolioUpdateItem::clear_sc_diff() {
  sc_diff_ = 0;
  clear_has_sc_diff();
}
inline double PortfolioUpdateItem::sc_diff() const {
  return sc_diff_;
}
inline void PortfolioUpdateItem::set_sc_diff(double value) {
  set_has_sc_diff();
  sc_diff_ = value;
}

// optional double HS_FastAngle = 301;
inline bool PortfolioUpdateItem::has_hs_fastangle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_fastangle() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PortfolioUpdateItem::clear_has_hs_fastangle() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PortfolioUpdateItem::clear_hs_fastangle() {
  hs_fastangle_ = 0;
  clear_has_hs_fastangle();
}
inline double PortfolioUpdateItem::hs_fastangle() const {
  return hs_fastangle_;
}
inline void PortfolioUpdateItem::set_hs_fastangle(double value) {
  set_has_hs_fastangle();
  hs_fastangle_ = value;
}

// optional double HS_SlowAngle = 302;
inline bool PortfolioUpdateItem::has_hs_slowangle() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_slowangle() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PortfolioUpdateItem::clear_has_hs_slowangle() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PortfolioUpdateItem::clear_hs_slowangle() {
  hs_slowangle_ = 0;
  clear_has_hs_slowangle();
}
inline double PortfolioUpdateItem::hs_slowangle() const {
  return hs_slowangle_;
}
inline void PortfolioUpdateItem::set_hs_slowangle(double value) {
  set_has_hs_slowangle();
  hs_slowangle_ = value;
}

// optional double HS_FastMacdHist = 303;
inline bool PortfolioUpdateItem::has_hs_fastmacdhist() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_fastmacdhist() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PortfolioUpdateItem::clear_has_hs_fastmacdhist() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PortfolioUpdateItem::clear_hs_fastmacdhist() {
  hs_fastmacdhist_ = 0;
  clear_has_hs_fastmacdhist();
}
inline double PortfolioUpdateItem::hs_fastmacdhist() const {
  return hs_fastmacdhist_;
}
inline void PortfolioUpdateItem::set_hs_fastmacdhist(double value) {
  set_has_hs_fastmacdhist();
  hs_fastmacdhist_ = value;
}

// optional double HS_FastMacdHistDiff = 304;
inline bool PortfolioUpdateItem::has_hs_fastmacdhistdiff() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_fastmacdhistdiff() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PortfolioUpdateItem::clear_has_hs_fastmacdhistdiff() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PortfolioUpdateItem::clear_hs_fastmacdhistdiff() {
  hs_fastmacdhistdiff_ = 0;
  clear_has_hs_fastmacdhistdiff();
}
inline double PortfolioUpdateItem::hs_fastmacdhistdiff() const {
  return hs_fastmacdhistdiff_;
}
inline void PortfolioUpdateItem::set_hs_fastmacdhistdiff(double value) {
  set_has_hs_fastmacdhistdiff();
  hs_fastmacdhistdiff_ = value;
}

// optional double HS_SlowMacdHist = 305;
inline bool PortfolioUpdateItem::has_hs_slowmacdhist() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_slowmacdhist() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PortfolioUpdateItem::clear_has_hs_slowmacdhist() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PortfolioUpdateItem::clear_hs_slowmacdhist() {
  hs_slowmacdhist_ = 0;
  clear_has_hs_slowmacdhist();
}
inline double PortfolioUpdateItem::hs_slowmacdhist() const {
  return hs_slowmacdhist_;
}
inline void PortfolioUpdateItem::set_hs_slowmacdhist(double value) {
  set_has_hs_slowmacdhist();
  hs_slowmacdhist_ = value;
}

// optional double HS_SlowMacdHistDiff = 306;
inline bool PortfolioUpdateItem::has_hs_slowmacdhistdiff() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_slowmacdhistdiff() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PortfolioUpdateItem::clear_has_hs_slowmacdhistdiff() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PortfolioUpdateItem::clear_hs_slowmacdhistdiff() {
  hs_slowmacdhistdiff_ = 0;
  clear_has_hs_slowmacdhistdiff();
}
inline double PortfolioUpdateItem::hs_slowmacdhistdiff() const {
  return hs_slowmacdhistdiff_;
}
inline void PortfolioUpdateItem::set_hs_slowmacdhistdiff(double value) {
  set_has_hs_slowmacdhistdiff();
  hs_slowmacdhistdiff_ = value;
}

// optional .entity.SlopeDirection HS_FastSlopeDirection = 307;
inline bool PortfolioUpdateItem::has_hs_fastslopedirection() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_fastslopedirection() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PortfolioUpdateItem::clear_has_hs_fastslopedirection() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PortfolioUpdateItem::clear_hs_fastslopedirection() {
  hs_fastslopedirection_ = 0;
  clear_has_hs_fastslopedirection();
}
inline entity::SlopeDirection PortfolioUpdateItem::hs_fastslopedirection() const {
  return static_cast< entity::SlopeDirection >(hs_fastslopedirection_);
}
inline void PortfolioUpdateItem::set_hs_fastslopedirection(entity::SlopeDirection value) {
  GOOGLE_DCHECK(entity::SlopeDirection_IsValid(value));
  set_has_hs_fastslopedirection();
  hs_fastslopedirection_ = value;
}

// optional .entity.SlopeDirection HS_SlowSlopeDirection = 308;
inline bool PortfolioUpdateItem::has_hs_slowslopedirection() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PortfolioUpdateItem::set_has_hs_slowslopedirection() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PortfolioUpdateItem::clear_has_hs_slowslopedirection() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PortfolioUpdateItem::clear_hs_slowslopedirection() {
  hs_slowslopedirection_ = 0;
  clear_has_hs_slowslopedirection();
}
inline entity::SlopeDirection PortfolioUpdateItem::hs_slowslopedirection() const {
  return static_cast< entity::SlopeDirection >(hs_slowslopedirection_);
}
inline void PortfolioUpdateItem::set_hs_slowslopedirection(entity::SlopeDirection value) {
  GOOGLE_DCHECK(entity::SlopeDirection_IsValid(value));
  set_has_hs_slowslopedirection();
  hs_slowslopedirection_ = value;
}

// optional double DX_BollTop = 311;
inline bool PortfolioUpdateItem::has_dx_bolltop() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PortfolioUpdateItem::set_has_dx_bolltop() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PortfolioUpdateItem::clear_has_dx_bolltop() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PortfolioUpdateItem::clear_dx_bolltop() {
  dx_bolltop_ = 0;
  clear_has_dx_bolltop();
}
inline double PortfolioUpdateItem::dx_bolltop() const {
  return dx_bolltop_;
}
inline void PortfolioUpdateItem::set_dx_bolltop(double value) {
  set_has_dx_bolltop();
  dx_bolltop_ = value;
}

// optional double DX_BollBottom = 312;
inline bool PortfolioUpdateItem::has_dx_bollbottom() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PortfolioUpdateItem::set_has_dx_bollbottom() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PortfolioUpdateItem::clear_has_dx_bollbottom() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PortfolioUpdateItem::clear_dx_bollbottom() {
  dx_bollbottom_ = 0;
  clear_has_dx_bollbottom();
}
inline double PortfolioUpdateItem::dx_bollbottom() const {
  return dx_bollbottom_;
}
inline void PortfolioUpdateItem::set_dx_bollbottom(double value) {
  set_has_dx_bollbottom();
  dx_bollbottom_ = value;
}

// -------------------------------------------------------------------

// ConnectParam

// required string QuoteAddress = 1;
inline bool ConnectParam::has_quoteaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectParam::set_has_quoteaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectParam::clear_has_quoteaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectParam::clear_quoteaddress() {
  if (quoteaddress_ != &::google::protobuf::internal::kEmptyString) {
    quoteaddress_->clear();
  }
  clear_has_quoteaddress();
}
inline const ::std::string& ConnectParam::quoteaddress() const {
  return *quoteaddress_;
}
inline void ConnectParam::set_quoteaddress(const ::std::string& value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(value);
}
inline void ConnectParam::set_quoteaddress(const char* value, size_t size) {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  quoteaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_quoteaddress() {
  set_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    quoteaddress_ = new ::std::string;
  }
  return quoteaddress_;
}
inline ::std::string* ConnectParam::release_quoteaddress() {
  clear_has_quoteaddress();
  if (quoteaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quoteaddress_;
    quoteaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StreamFolder = 2;
inline bool ConnectParam::has_streamfolder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectParam::set_has_streamfolder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectParam::clear_has_streamfolder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectParam::clear_streamfolder() {
  if (streamfolder_ != &::google::protobuf::internal::kEmptyString) {
    streamfolder_->clear();
  }
  clear_has_streamfolder();
}
inline const ::std::string& ConnectParam::streamfolder() const {
  return *streamfolder_;
}
inline void ConnectParam::set_streamfolder(const ::std::string& value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(value);
}
inline void ConnectParam::set_streamfolder(const char* value, size_t size) {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  streamfolder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectParam::mutable_streamfolder() {
  set_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    streamfolder_ = new ::std::string;
  }
  return streamfolder_;
}
inline ::std::string* ConnectParam::release_streamfolder() {
  clear_has_streamfolder();
  if (streamfolder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = streamfolder_;
    streamfolder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OperationReturn

// required bool Success = 1;
inline bool OperationReturn::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationReturn::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationReturn::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationReturn::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool OperationReturn::success() const {
  return success_;
}
inline void OperationReturn::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string ErrorMessage = 2;
inline bool OperationReturn::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationReturn::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationReturn::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationReturn::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& OperationReturn::errormessage() const {
  return *errormessage_;
}
inline void OperationReturn::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void OperationReturn::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OperationReturn::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* OperationReturn::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AccountSettings

// required int32 MaxSubmit = 1;
inline bool AccountSettings::has_maxsubmit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountSettings::set_has_maxsubmit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountSettings::clear_has_maxsubmit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountSettings::clear_maxsubmit() {
  maxsubmit_ = 0;
  clear_has_maxsubmit();
}
inline ::google::protobuf::int32 AccountSettings::maxsubmit() const {
  return maxsubmit_;
}
inline void AccountSettings::set_maxsubmit(::google::protobuf::int32 value) {
  set_has_maxsubmit();
  maxsubmit_ = value;
}

// required int32 MaxCancel = 2;
inline bool AccountSettings::has_maxcancel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountSettings::set_has_maxcancel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountSettings::clear_has_maxcancel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountSettings::clear_maxcancel() {
  maxcancel_ = 0;
  clear_has_maxcancel();
}
inline ::google::protobuf::int32 AccountSettings::maxcancel() const {
  return maxcancel_;
}
inline void AccountSettings::set_maxcancel(::google::protobuf::int32 value) {
  set_has_maxcancel();
  maxcancel_ = value;
}

// -------------------------------------------------------------------

// LoginParam

// required string BrokerId = 1;
inline bool LoginParam::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginParam::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginParam::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginParam::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& LoginParam::brokerid() const {
  return *brokerid_;
}
inline void LoginParam::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void LoginParam::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* LoginParam::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 2;
inline bool LoginParam::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginParam::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginParam::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginParam::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& LoginParam::userid() const {
  return *userid_;
}
inline void LoginParam::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LoginParam::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* LoginParam::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 3;
inline bool LoginParam::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginParam::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginParam::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginParam::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginParam::password() const {
  return *password_;
}
inline void LoginParam::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginParam::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginParam::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginParam::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .entity.AccountSettings AcctSettings = 4;
inline bool LoginParam::has_acctsettings() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginParam::set_has_acctsettings() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginParam::clear_has_acctsettings() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginParam::clear_acctsettings() {
  if (acctsettings_ != NULL) acctsettings_->::entity::AccountSettings::Clear();
  clear_has_acctsettings();
}
inline const ::entity::AccountSettings& LoginParam::acctsettings() const {
  return acctsettings_ != NULL ? *acctsettings_ : *default_instance_->acctsettings_;
}
inline ::entity::AccountSettings* LoginParam::mutable_acctsettings() {
  set_has_acctsettings();
  if (acctsettings_ == NULL) acctsettings_ = new ::entity::AccountSettings;
  return acctsettings_;
}
inline ::entity::AccountSettings* LoginParam::release_acctsettings() {
  clear_has_acctsettings();
  ::entity::AccountSettings* temp = acctsettings_;
  acctsettings_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RegQuoteParam

// repeated string Symbols = 1;
inline int RegQuoteParam::symbols_size() const {
  return symbols_.size();
}
inline void RegQuoteParam::clear_symbols() {
  symbols_.Clear();
}
inline const ::std::string& RegQuoteParam::symbols(int index) const {
  return symbols_.Get(index);
}
inline ::std::string* RegQuoteParam::mutable_symbols(int index) {
  return symbols_.Mutable(index);
}
inline void RegQuoteParam::set_symbols(int index, const ::std::string& value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value) {
  symbols_.Mutable(index)->assign(value);
}
inline void RegQuoteParam::set_symbols(int index, const char* value, size_t size) {
  symbols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegQuoteParam::add_symbols() {
  return symbols_.Add();
}
inline void RegQuoteParam::add_symbols(const ::std::string& value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value) {
  symbols_.Add()->assign(value);
}
inline void RegQuoteParam::add_symbols(const char* value, size_t size) {
  symbols_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegQuoteParam::symbols() const {
  return symbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegQuoteParam::mutable_symbols() {
  return &symbols_;
}

// -------------------------------------------------------------------

// AddPortfolioParam

// repeated .entity.PortfolioItem PortfolioItems = 1;
inline int AddPortfolioParam::portfolioitems_size() const {
  return portfolioitems_.size();
}
inline void AddPortfolioParam::clear_portfolioitems() {
  portfolioitems_.Clear();
}
inline const ::entity::PortfolioItem& AddPortfolioParam::portfolioitems(int index) const {
  return portfolioitems_.Get(index);
}
inline ::entity::PortfolioItem* AddPortfolioParam::mutable_portfolioitems(int index) {
  return portfolioitems_.Mutable(index);
}
inline ::entity::PortfolioItem* AddPortfolioParam::add_portfolioitems() {
  return portfolioitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >&
AddPortfolioParam::portfolioitems() const {
  return portfolioitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::entity::PortfolioItem >*
AddPortfolioParam::mutable_portfolioitems() {
  return &portfolioitems_;
}

// -------------------------------------------------------------------

// PorfOpenPosiParam

// required string PortfId = 1;
inline bool PorfOpenPosiParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PorfOpenPosiParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PorfOpenPosiParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PorfOpenPosiParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& PorfOpenPosiParam::portfid() const {
  return *portfid_;
}
inline void PorfOpenPosiParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void PorfOpenPosiParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PorfOpenPosiParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* PorfOpenPosiParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 2;
inline bool PorfOpenPosiParam::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PorfOpenPosiParam::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PorfOpenPosiParam::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PorfOpenPosiParam::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 PorfOpenPosiParam::quantity() const {
  return quantity_;
}
inline void PorfOpenPosiParam::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required bool IsVirtual = 3;
inline bool PorfOpenPosiParam::has_isvirtual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PorfOpenPosiParam::set_has_isvirtual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PorfOpenPosiParam::clear_has_isvirtual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PorfOpenPosiParam::clear_isvirtual() {
  isvirtual_ = false;
  clear_has_isvirtual();
}
inline bool PorfOpenPosiParam::isvirtual() const {
  return isvirtual_;
}
inline void PorfOpenPosiParam::set_isvirtual(bool value) {
  set_has_isvirtual();
  isvirtual_ = value;
}

// -------------------------------------------------------------------

// ClosePositionParam

// required .trade.MultiLegOrder MultiLegOrder = 1;
inline bool ClosePositionParam::has_multilegorder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClosePositionParam::set_has_multilegorder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClosePositionParam::clear_has_multilegorder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClosePositionParam::clear_multilegorder() {
  if (multilegorder_ != NULL) multilegorder_->::trade::MultiLegOrder::Clear();
  clear_has_multilegorder();
}
inline const ::trade::MultiLegOrder& ClosePositionParam::multilegorder() const {
  return multilegorder_ != NULL ? *multilegorder_ : *default_instance_->multilegorder_;
}
inline ::trade::MultiLegOrder* ClosePositionParam::mutable_multilegorder() {
  set_has_multilegorder();
  if (multilegorder_ == NULL) multilegorder_ = new ::trade::MultiLegOrder;
  return multilegorder_;
}
inline ::trade::MultiLegOrder* ClosePositionParam::release_multilegorder() {
  clear_has_multilegorder();
  ::trade::MultiLegOrder* temp = multilegorder_;
  multilegorder_ = NULL;
  return temp;
}

// optional string LegOrdRef = 2;
inline bool ClosePositionParam::has_legordref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClosePositionParam::set_has_legordref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClosePositionParam::clear_has_legordref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClosePositionParam::clear_legordref() {
  if (legordref_ != &::google::protobuf::internal::kEmptyString) {
    legordref_->clear();
  }
  clear_has_legordref();
}
inline const ::std::string& ClosePositionParam::legordref() const {
  return *legordref_;
}
inline void ClosePositionParam::set_legordref(const ::std::string& value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(value);
}
inline void ClosePositionParam::set_legordref(const char* value, size_t size) {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  legordref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClosePositionParam::mutable_legordref() {
  set_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    legordref_ = new ::std::string;
  }
  return legordref_;
}
inline ::std::string* ClosePositionParam::release_legordref() {
  clear_has_legordref();
  if (legordref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legordref_;
    legordref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LegOrderUpdateParam

// required string PortfId = 1;
inline bool LegOrderUpdateParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegOrderUpdateParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegOrderUpdateParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegOrderUpdateParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& LegOrderUpdateParam::portfid() const {
  return *portfid_;
}
inline void LegOrderUpdateParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void LegOrderUpdateParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void LegOrderUpdateParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* LegOrderUpdateParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string MultiLegOrderId = 2;
inline bool LegOrderUpdateParam::has_multilegorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegOrderUpdateParam::set_has_multilegorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegOrderUpdateParam::clear_has_multilegorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegOrderUpdateParam::clear_multilegorderid() {
  if (multilegorderid_ != &::google::protobuf::internal::kEmptyString) {
    multilegorderid_->clear();
  }
  clear_has_multilegorderid();
}
inline const ::std::string& LegOrderUpdateParam::multilegorderid() const {
  return *multilegorderid_;
}
inline void LegOrderUpdateParam::set_multilegorderid(const ::std::string& value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void LegOrderUpdateParam::set_multilegorderid(const char* value) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(value);
}
inline void LegOrderUpdateParam::set_multilegorderid(const char* value, size_t size) {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  multilegorderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_multilegorderid() {
  set_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    multilegorderid_ = new ::std::string;
  }
  return multilegorderid_;
}
inline ::std::string* LegOrderUpdateParam::release_multilegorderid() {
  clear_has_multilegorderid();
  if (multilegorderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multilegorderid_;
    multilegorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string LegOrderRef = 3;
inline bool LegOrderUpdateParam::has_legorderref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegOrderUpdateParam::set_has_legorderref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegOrderUpdateParam::clear_has_legorderref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegOrderUpdateParam::clear_legorderref() {
  if (legorderref_ != &::google::protobuf::internal::kEmptyString) {
    legorderref_->clear();
  }
  clear_has_legorderref();
}
inline const ::std::string& LegOrderUpdateParam::legorderref() const {
  return *legorderref_;
}
inline void LegOrderUpdateParam::set_legorderref(const ::std::string& value) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(value);
}
inline void LegOrderUpdateParam::set_legorderref(const char* value) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(value);
}
inline void LegOrderUpdateParam::set_legorderref(const char* value, size_t size) {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  legorderref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegOrderUpdateParam::mutable_legorderref() {
  set_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    legorderref_ = new ::std::string;
  }
  return legorderref_;
}
inline ::std::string* LegOrderUpdateParam::release_legorderref() {
  clear_has_legorderref();
  if (legorderref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legorderref_;
    legorderref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .trade.Order LegOrder = 4;
inline bool LegOrderUpdateParam::has_legorder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegOrderUpdateParam::set_has_legorder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegOrderUpdateParam::clear_has_legorder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegOrderUpdateParam::clear_legorder() {
  if (legorder_ != NULL) legorder_->::trade::Order::Clear();
  clear_has_legorder();
}
inline const ::trade::Order& LegOrderUpdateParam::legorder() const {
  return legorder_ != NULL ? *legorder_ : *default_instance_->legorder_;
}
inline ::trade::Order* LegOrderUpdateParam::mutable_legorder() {
  set_has_legorder();
  if (legorder_ == NULL) legorder_ = new ::trade::Order;
  return legorder_;
}
inline ::trade::Order* LegOrderUpdateParam::release_legorder() {
  clear_has_legorder();
  ::trade::Order* temp = legorder_;
  legorder_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ArbitrageStrategySettings

// required .entity.PosiDirectionType Side = 1;
inline bool ArbitrageStrategySettings::has_side() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArbitrageStrategySettings::set_has_side() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArbitrageStrategySettings::clear_has_side() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArbitrageStrategySettings::clear_side() {
  side_ = 49;
  clear_has_side();
}
inline entity::PosiDirectionType ArbitrageStrategySettings::side() const {
  return static_cast< entity::PosiDirectionType >(side_);
}
inline void ArbitrageStrategySettings::set_side(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_side();
  side_ = value;
}

// required .entity.CompareCondition OpenCondition = 2;
inline bool ArbitrageStrategySettings::has_opencondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArbitrageStrategySettings::set_has_opencondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArbitrageStrategySettings::clear_has_opencondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArbitrageStrategySettings::clear_opencondition() {
  opencondition_ = 0;
  clear_has_opencondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::opencondition() const {
  return static_cast< entity::CompareCondition >(opencondition_);
}
inline void ArbitrageStrategySettings::set_opencondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_opencondition();
  opencondition_ = value;
}

// required double OpenPosiThreshold = 3;
inline bool ArbitrageStrategySettings::has_openposithreshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArbitrageStrategySettings::set_has_openposithreshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArbitrageStrategySettings::clear_has_openposithreshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArbitrageStrategySettings::clear_openposithreshold() {
  openposithreshold_ = 0;
  clear_has_openposithreshold();
}
inline double ArbitrageStrategySettings::openposithreshold() const {
  return openposithreshold_;
}
inline void ArbitrageStrategySettings::set_openposithreshold(double value) {
  set_has_openposithreshold();
  openposithreshold_ = value;
}

// required .entity.CompareCondition StopGainCondition = 4;
inline bool ArbitrageStrategySettings::has_stopgaincondition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stopgaincondition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArbitrageStrategySettings::clear_has_stopgaincondition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArbitrageStrategySettings::clear_stopgaincondition() {
  stopgaincondition_ = 0;
  clear_has_stopgaincondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::stopgaincondition() const {
  return static_cast< entity::CompareCondition >(stopgaincondition_);
}
inline void ArbitrageStrategySettings::set_stopgaincondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_stopgaincondition();
  stopgaincondition_ = value;
}

// required double StopGainThreshold = 5;
inline bool ArbitrageStrategySettings::has_stopgainthreshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stopgainthreshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArbitrageStrategySettings::clear_has_stopgainthreshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArbitrageStrategySettings::clear_stopgainthreshold() {
  stopgainthreshold_ = 0;
  clear_has_stopgainthreshold();
}
inline double ArbitrageStrategySettings::stopgainthreshold() const {
  return stopgainthreshold_;
}
inline void ArbitrageStrategySettings::set_stopgainthreshold(double value) {
  set_has_stopgainthreshold();
  stopgainthreshold_ = value;
}

// required .entity.CompareCondition StopLossCondition = 6;
inline bool ArbitrageStrategySettings::has_stoplosscondition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stoplosscondition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArbitrageStrategySettings::clear_has_stoplosscondition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArbitrageStrategySettings::clear_stoplosscondition() {
  stoplosscondition_ = 0;
  clear_has_stoplosscondition();
}
inline entity::CompareCondition ArbitrageStrategySettings::stoplosscondition() const {
  return static_cast< entity::CompareCondition >(stoplosscondition_);
}
inline void ArbitrageStrategySettings::set_stoplosscondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_stoplosscondition();
  stoplosscondition_ = value;
}

// required double StopLossThreshold = 7;
inline bool ArbitrageStrategySettings::has_stoplossthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArbitrageStrategySettings::set_has_stoplossthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArbitrageStrategySettings::clear_has_stoplossthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArbitrageStrategySettings::clear_stoplossthreshold() {
  stoplossthreshold_ = 0;
  clear_has_stoplossthreshold();
}
inline double ArbitrageStrategySettings::stoplossthreshold() const {
  return stoplossthreshold_;
}
inline void ArbitrageStrategySettings::set_stoplossthreshold(double value) {
  set_has_stoplossthreshold();
  stoplossthreshold_ = value;
}

// -------------------------------------------------------------------

// ChangePosiStrategySettings

// required string CloseLeg = 1;
inline bool ChangePosiStrategySettings::has_closeleg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePosiStrategySettings::set_has_closeleg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePosiStrategySettings::clear_has_closeleg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePosiStrategySettings::clear_closeleg() {
  if (closeleg_ != &::google::protobuf::internal::kEmptyString) {
    closeleg_->clear();
  }
  clear_has_closeleg();
}
inline const ::std::string& ChangePosiStrategySettings::closeleg() const {
  return *closeleg_;
}
inline void ChangePosiStrategySettings::set_closeleg(const ::std::string& value) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(value);
}
inline void ChangePosiStrategySettings::set_closeleg(const char* value) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(value);
}
inline void ChangePosiStrategySettings::set_closeleg(const char* value, size_t size) {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  closeleg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChangePosiStrategySettings::mutable_closeleg() {
  set_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    closeleg_ = new ::std::string;
  }
  return closeleg_;
}
inline ::std::string* ChangePosiStrategySettings::release_closeleg() {
  clear_has_closeleg();
  if (closeleg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = closeleg_;
    closeleg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .entity.PosiDirectionType CloseLegSide = 2;
inline bool ChangePosiStrategySettings::has_closelegside() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePosiStrategySettings::set_has_closelegside() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePosiStrategySettings::clear_has_closelegside() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePosiStrategySettings::clear_closelegside() {
  closelegside_ = 49;
  clear_has_closelegside();
}
inline entity::PosiDirectionType ChangePosiStrategySettings::closelegside() const {
  return static_cast< entity::PosiDirectionType >(closelegside_);
}
inline void ChangePosiStrategySettings::set_closelegside(entity::PosiDirectionType value) {
  GOOGLE_DCHECK(entity::PosiDirectionType_IsValid(value));
  set_has_closelegside();
  closelegside_ = value;
}

// required .entity.CompareCondition TriggerCondition = 3;
inline bool ChangePosiStrategySettings::has_triggercondition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangePosiStrategySettings::set_has_triggercondition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangePosiStrategySettings::clear_has_triggercondition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangePosiStrategySettings::clear_triggercondition() {
  triggercondition_ = 0;
  clear_has_triggercondition();
}
inline entity::CompareCondition ChangePosiStrategySettings::triggercondition() const {
  return static_cast< entity::CompareCondition >(triggercondition_);
}
inline void ChangePosiStrategySettings::set_triggercondition(entity::CompareCondition value) {
  GOOGLE_DCHECK(entity::CompareCondition_IsValid(value));
  set_has_triggercondition();
  triggercondition_ = value;
}

// required double Threshold = 4;
inline bool ChangePosiStrategySettings::has_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangePosiStrategySettings::set_has_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangePosiStrategySettings::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangePosiStrategySettings::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline double ChangePosiStrategySettings::threshold() const {
  return threshold_;
}
inline void ChangePosiStrategySettings::set_threshold(double value) {
  set_has_threshold();
  threshold_ = value;
}

// -------------------------------------------------------------------

// ScalperSettings

// required double Threshold = 1;
inline bool ScalperSettings::has_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScalperSettings::set_has_threshold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScalperSettings::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScalperSettings::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline double ScalperSettings::threshold() const {
  return threshold_;
}
inline void ScalperSettings::set_threshold(double value) {
  set_has_threshold();
  threshold_ = value;
}

// required double PriceTick = 2;
inline bool ScalperSettings::has_pricetick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScalperSettings::set_has_pricetick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScalperSettings::clear_has_pricetick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScalperSettings::clear_pricetick() {
  pricetick_ = 0;
  clear_has_pricetick();
}
inline double ScalperSettings::pricetick() const {
  return pricetick_;
}
inline void ScalperSettings::set_pricetick(double value) {
  set_has_pricetick();
  pricetick_ = value;
}

// required .entity.DirectionDepends CaseLE2Tick = 3;
inline bool ScalperSettings::has_casele2tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScalperSettings::set_has_casele2tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScalperSettings::clear_has_casele2tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScalperSettings::clear_casele2tick() {
  casele2tick_ = 0;
  clear_has_casele2tick();
}
inline entity::DirectionDepends ScalperSettings::casele2tick() const {
  return static_cast< entity::DirectionDepends >(casele2tick_);
}
inline void ScalperSettings::set_casele2tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_casele2tick();
  casele2tick_ = value;
}

// required .entity.DirectionDepends CaseLE3Tick = 4;
inline bool ScalperSettings::has_casele3tick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScalperSettings::set_has_casele3tick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScalperSettings::clear_has_casele3tick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScalperSettings::clear_casele3tick() {
  casele3tick_ = 0;
  clear_has_casele3tick();
}
inline entity::DirectionDepends ScalperSettings::casele3tick() const {
  return static_cast< entity::DirectionDepends >(casele3tick_);
}
inline void ScalperSettings::set_casele3tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_casele3tick();
  casele3tick_ = value;
}

// required .entity.DirectionDepends CaseGE4Tick = 5;
inline bool ScalperSettings::has_casege4tick() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScalperSettings::set_has_casege4tick() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScalperSettings::clear_has_casege4tick() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScalperSettings::clear_casege4tick() {
  casege4tick_ = 0;
  clear_has_casege4tick();
}
inline entity::DirectionDepends ScalperSettings::casege4tick() const {
  return static_cast< entity::DirectionDepends >(casege4tick_);
}
inline void ScalperSettings::set_casege4tick(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_casege4tick();
  casege4tick_ = value;
}

// required .entity.DirectionDepends CaseNoChange = 6;
inline bool ScalperSettings::has_casenochange() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScalperSettings::set_has_casenochange() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScalperSettings::clear_has_casenochange() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScalperSettings::clear_casenochange() {
  casenochange_ = 0;
  clear_has_casenochange();
}
inline entity::DirectionDepends ScalperSettings::casenochange() const {
  return static_cast< entity::DirectionDepends >(casenochange_);
}
inline void ScalperSettings::set_casenochange(entity::DirectionDepends value) {
  GOOGLE_DCHECK(entity::DirectionDepends_IsValid(value));
  set_has_casenochange();
  casenochange_ = value;
}

// required .entity.StopLossCloseMethods StopLossStrategy = 7;
inline bool ScalperSettings::has_stoplossstrategy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScalperSettings::set_has_stoplossstrategy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScalperSettings::clear_has_stoplossstrategy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScalperSettings::clear_stoplossstrategy() {
  stoplossstrategy_ = 0;
  clear_has_stoplossstrategy();
}
inline entity::StopLossCloseMethods ScalperSettings::stoplossstrategy() const {
  return static_cast< entity::StopLossCloseMethods >(stoplossstrategy_);
}
inline void ScalperSettings::set_stoplossstrategy(entity::StopLossCloseMethods value) {
  GOOGLE_DCHECK(entity::StopLossCloseMethods_IsValid(value));
  set_has_stoplossstrategy();
  stoplossstrategy_ = value;
}

// required int32 RetryTimes = 8;
inline bool ScalperSettings::has_retrytimes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScalperSettings::set_has_retrytimes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScalperSettings::clear_has_retrytimes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScalperSettings::clear_retrytimes() {
  retrytimes_ = 0;
  clear_has_retrytimes();
}
inline ::google::protobuf::int32 ScalperSettings::retrytimes() const {
  return retrytimes_;
}
inline void ScalperSettings::set_retrytimes(::google::protobuf::int32 value) {
  set_has_retrytimes();
  retrytimes_ = value;
}

// optional int32 OpenTimeout = 9;
inline bool ScalperSettings::has_opentimeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScalperSettings::set_has_opentimeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScalperSettings::clear_has_opentimeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScalperSettings::clear_opentimeout() {
  opentimeout_ = 0;
  clear_has_opentimeout();
}
inline ::google::protobuf::int32 ScalperSettings::opentimeout() const {
  return opentimeout_;
}
inline void ScalperSettings::set_opentimeout(::google::protobuf::int32 value) {
  set_has_opentimeout();
  opentimeout_ = value;
}

// -------------------------------------------------------------------

// ModifyStrategyParam

// required string PortfId = 1;
inline bool ModifyStrategyParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyStrategyParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyStrategyParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyStrategyParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyStrategyParam::portfid() const {
  return *portfid_;
}
inline void ModifyStrategyParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyStrategyParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyStrategyParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyStrategyParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StrategyName = 2;
inline bool ModifyStrategyParam::has_strategyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyStrategyParam::set_has_strategyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyStrategyParam::clear_has_strategyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyStrategyParam::clear_strategyname() {
  if (strategyname_ != &::google::protobuf::internal::kEmptyString) {
    strategyname_->clear();
  }
  clear_has_strategyname();
}
inline const ::std::string& ModifyStrategyParam::strategyname() const {
  return *strategyname_;
}
inline void ModifyStrategyParam::set_strategyname(const ::std::string& value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void ModifyStrategyParam::set_strategyname(const char* value) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(value);
}
inline void ModifyStrategyParam::set_strategyname(const char* value, size_t size) {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  strategyname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_strategyname() {
  set_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    strategyname_ = new ::std::string;
  }
  return strategyname_;
}
inline ::std::string* ModifyStrategyParam::release_strategyname() {
  clear_has_strategyname();
  if (strategyname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategyname_;
    strategyname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes StrategyData = 3;
inline bool ModifyStrategyParam::has_strategydata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyStrategyParam::set_has_strategydata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyStrategyParam::clear_has_strategydata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyStrategyParam::clear_strategydata() {
  if (strategydata_ != &::google::protobuf::internal::kEmptyString) {
    strategydata_->clear();
  }
  clear_has_strategydata();
}
inline const ::std::string& ModifyStrategyParam::strategydata() const {
  return *strategydata_;
}
inline void ModifyStrategyParam::set_strategydata(const ::std::string& value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void ModifyStrategyParam::set_strategydata(const char* value) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(value);
}
inline void ModifyStrategyParam::set_strategydata(const void* value, size_t size) {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  strategydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyStrategyParam::mutable_strategydata() {
  set_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    strategydata_ = new ::std::string;
  }
  return strategydata_;
}
inline ::std::string* ModifyStrategyParam::release_strategydata() {
  clear_has_strategydata();
  if (strategydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategydata_;
    strategydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ModifyPortfolioSwitchParam

// required string PortfId = 1;
inline bool ModifyPortfolioSwitchParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyPortfolioSwitchParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyPortfolioSwitchParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyPortfolioSwitchParam::portfid() const {
  return *portfid_;
}
inline void ModifyPortfolioSwitchParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioSwitchParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioSwitchParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioSwitchParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyPortfolioSwitchParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool AutoOpen = 2;
inline bool ModifyPortfolioSwitchParam::has_autoopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autoopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autoopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyPortfolioSwitchParam::clear_autoopen() {
  autoopen_ = false;
  clear_has_autoopen();
}
inline bool ModifyPortfolioSwitchParam::autoopen() const {
  return autoopen_;
}
inline void ModifyPortfolioSwitchParam::set_autoopen(bool value) {
  set_has_autoopen();
  autoopen_ = value;
}

// required bool AutoStopGain = 3;
inline bool ModifyPortfolioSwitchParam::has_autostopgain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autostopgain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autostopgain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyPortfolioSwitchParam::clear_autostopgain() {
  autostopgain_ = false;
  clear_has_autostopgain();
}
inline bool ModifyPortfolioSwitchParam::autostopgain() const {
  return autostopgain_;
}
inline void ModifyPortfolioSwitchParam::set_autostopgain(bool value) {
  set_has_autostopgain();
  autostopgain_ = value;
}

// required bool AutoStopLoss = 4;
inline bool ModifyPortfolioSwitchParam::has_autostoploss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autostoploss() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autostoploss() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyPortfolioSwitchParam::clear_autostoploss() {
  autostoploss_ = false;
  clear_has_autostoploss();
}
inline bool ModifyPortfolioSwitchParam::autostoploss() const {
  return autostoploss_;
}
inline void ModifyPortfolioSwitchParam::set_autostoploss(bool value) {
  set_has_autostoploss();
  autostoploss_ = value;
}

// required bool AutoTracking = 5;
inline bool ModifyPortfolioSwitchParam::has_autotracking() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_autotracking() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyPortfolioSwitchParam::clear_has_autotracking() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyPortfolioSwitchParam::clear_autotracking() {
  autotracking_ = false;
  clear_has_autotracking();
}
inline bool ModifyPortfolioSwitchParam::autotracking() const {
  return autotracking_;
}
inline void ModifyPortfolioSwitchParam::set_autotracking(bool value) {
  set_has_autotracking();
  autotracking_ = value;
}

// required bool EnablePrefer = 6;
inline bool ModifyPortfolioSwitchParam::has_enableprefer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModifyPortfolioSwitchParam::set_has_enableprefer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModifyPortfolioSwitchParam::clear_has_enableprefer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModifyPortfolioSwitchParam::clear_enableprefer() {
  enableprefer_ = false;
  clear_has_enableprefer();
}
inline bool ModifyPortfolioSwitchParam::enableprefer() const {
  return enableprefer_;
}
inline void ModifyPortfolioSwitchParam::set_enableprefer(bool value) {
  set_has_enableprefer();
  enableprefer_ = value;
}

// -------------------------------------------------------------------

// ModifyPortfolioQtyParam

// required string PortfId = 1;
inline bool ModifyPortfolioQtyParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyPortfolioQtyParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyPortfolioQtyParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyPortfolioQtyParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyPortfolioQtyParam::portfid() const {
  return *portfid_;
}
inline void ModifyPortfolioQtyParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioQtyParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioQtyParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioQtyParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyPortfolioQtyParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 PerOpenQty = 2;
inline bool ModifyPortfolioQtyParam::has_peropenqty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyPortfolioQtyParam::set_has_peropenqty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyPortfolioQtyParam::clear_has_peropenqty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyPortfolioQtyParam::clear_peropenqty() {
  peropenqty_ = 0;
  clear_has_peropenqty();
}
inline ::google::protobuf::int32 ModifyPortfolioQtyParam::peropenqty() const {
  return peropenqty_;
}
inline void ModifyPortfolioQtyParam::set_peropenqty(::google::protobuf::int32 value) {
  set_has_peropenqty();
  peropenqty_ = value;
}

// required int32 PerStartQty = 3;
inline bool ModifyPortfolioQtyParam::has_perstartqty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyPortfolioQtyParam::set_has_perstartqty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyPortfolioQtyParam::clear_has_perstartqty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyPortfolioQtyParam::clear_perstartqty() {
  perstartqty_ = 0;
  clear_has_perstartqty();
}
inline ::google::protobuf::int32 ModifyPortfolioQtyParam::perstartqty() const {
  return perstartqty_;
}
inline void ModifyPortfolioQtyParam::set_perstartqty(::google::protobuf::int32 value) {
  set_has_perstartqty();
  perstartqty_ = value;
}

// required int32 TotalOpenLimit = 4;
inline bool ModifyPortfolioQtyParam::has_totalopenlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModifyPortfolioQtyParam::set_has_totalopenlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModifyPortfolioQtyParam::clear_has_totalopenlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModifyPortfolioQtyParam::clear_totalopenlimit() {
  totalopenlimit_ = 0;
  clear_has_totalopenlimit();
}
inline ::google::protobuf::int32 ModifyPortfolioQtyParam::totalopenlimit() const {
  return totalopenlimit_;
}
inline void ModifyPortfolioQtyParam::set_totalopenlimit(::google::protobuf::int32 value) {
  set_has_totalopenlimit();
  totalopenlimit_ = value;
}

// required int32 MaxCancelQty = 5;
inline bool ModifyPortfolioQtyParam::has_maxcancelqty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModifyPortfolioQtyParam::set_has_maxcancelqty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModifyPortfolioQtyParam::clear_has_maxcancelqty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModifyPortfolioQtyParam::clear_maxcancelqty() {
  maxcancelqty_ = 0;
  clear_has_maxcancelqty();
}
inline ::google::protobuf::int32 ModifyPortfolioQtyParam::maxcancelqty() const {
  return maxcancelqty_;
}
inline void ModifyPortfolioQtyParam::set_maxcancelqty(::google::protobuf::int32 value) {
  set_has_maxcancelqty();
  maxcancelqty_ = value;
}

// repeated string EndTimePoints = 6;
inline int ModifyPortfolioQtyParam::endtimepoints_size() const {
  return endtimepoints_.size();
}
inline void ModifyPortfolioQtyParam::clear_endtimepoints() {
  endtimepoints_.Clear();
}
inline const ::std::string& ModifyPortfolioQtyParam::endtimepoints(int index) const {
  return endtimepoints_.Get(index);
}
inline ::std::string* ModifyPortfolioQtyParam::mutable_endtimepoints(int index) {
  return endtimepoints_.Mutable(index);
}
inline void ModifyPortfolioQtyParam::set_endtimepoints(int index, const ::std::string& value) {
  endtimepoints_.Mutable(index)->assign(value);
}
inline void ModifyPortfolioQtyParam::set_endtimepoints(int index, const char* value) {
  endtimepoints_.Mutable(index)->assign(value);
}
inline void ModifyPortfolioQtyParam::set_endtimepoints(int index, const char* value, size_t size) {
  endtimepoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioQtyParam::add_endtimepoints() {
  return endtimepoints_.Add();
}
inline void ModifyPortfolioQtyParam::add_endtimepoints(const ::std::string& value) {
  endtimepoints_.Add()->assign(value);
}
inline void ModifyPortfolioQtyParam::add_endtimepoints(const char* value) {
  endtimepoints_.Add()->assign(value);
}
inline void ModifyPortfolioQtyParam::add_endtimepoints(const char* value, size_t size) {
  endtimepoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModifyPortfolioQtyParam::endtimepoints() const {
  return endtimepoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModifyPortfolioQtyParam::mutable_endtimepoints() {
  return &endtimepoints_;
}

// -------------------------------------------------------------------

// ModifyRunningStatusParam

// required string PortfId = 1;
inline bool ModifyRunningStatusParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyRunningStatusParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyRunningStatusParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyRunningStatusParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyRunningStatusParam::portfid() const {
  return *portfid_;
}
inline void ModifyRunningStatusParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyRunningStatusParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyRunningStatusParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyRunningStatusParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyRunningStatusParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool Enabled = 2;
inline bool ModifyRunningStatusParam::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyRunningStatusParam::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyRunningStatusParam::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyRunningStatusParam::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ModifyRunningStatusParam::enabled() const {
  return enabled_;
}
inline void ModifyRunningStatusParam::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// ModifyPortfolioPreferredLegParam

// required string PortfId = 1;
inline bool ModifyPortfolioPreferredLegParam::has_portfid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyPortfolioPreferredLegParam::set_has_portfid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyPortfolioPreferredLegParam::clear_has_portfid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyPortfolioPreferredLegParam::clear_portfid() {
  if (portfid_ != &::google::protobuf::internal::kEmptyString) {
    portfid_->clear();
  }
  clear_has_portfid();
}
inline const ::std::string& ModifyPortfolioPreferredLegParam::portfid() const {
  return *portfid_;
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const ::std::string& value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const char* value) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_portfid(const char* value, size_t size) {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  portfid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioPreferredLegParam::mutable_portfid() {
  set_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    portfid_ = new ::std::string;
  }
  return portfid_;
}
inline ::std::string* ModifyPortfolioPreferredLegParam::release_portfid() {
  clear_has_portfid();
  if (portfid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portfid_;
    portfid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string LegSymbol = 2;
inline bool ModifyPortfolioPreferredLegParam::has_legsymbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyPortfolioPreferredLegParam::set_has_legsymbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyPortfolioPreferredLegParam::clear_has_legsymbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyPortfolioPreferredLegParam::clear_legsymbol() {
  if (legsymbol_ != &::google::protobuf::internal::kEmptyString) {
    legsymbol_->clear();
  }
  clear_has_legsymbol();
}
inline const ::std::string& ModifyPortfolioPreferredLegParam::legsymbol() const {
  return *legsymbol_;
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const ::std::string& value) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const char* value) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(value);
}
inline void ModifyPortfolioPreferredLegParam::set_legsymbol(const char* value, size_t size) {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  legsymbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyPortfolioPreferredLegParam::mutable_legsymbol() {
  set_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    legsymbol_ = new ::std::string;
  }
  return legsymbol_;
}
inline ::std::string* ModifyPortfolioPreferredLegParam::release_legsymbol() {
  clear_has_legsymbol();
  if (legsymbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legsymbol_;
    legsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CancelOrderParam

// required string OrderRef = 1;
inline bool CancelOrderParam::has_orderref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelOrderParam::set_has_orderref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelOrderParam::clear_has_orderref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelOrderParam::clear_orderref() {
  if (orderref_ != &::google::protobuf::internal::kEmptyString) {
    orderref_->clear();
  }
  clear_has_orderref();
}
inline const ::std::string& CancelOrderParam::orderref() const {
  return *orderref_;
}
inline void CancelOrderParam::set_orderref(const ::std::string& value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void CancelOrderParam::set_orderref(const char* value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void CancelOrderParam::set_orderref(const char* value, size_t size) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelOrderParam::mutable_orderref() {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  return orderref_;
}
inline ::std::string* CancelOrderParam::release_orderref() {
  clear_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderref_;
    orderref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeId = 2;
inline bool CancelOrderParam::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelOrderParam::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelOrderParam::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelOrderParam::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& CancelOrderParam::exchangeid() const {
  return *exchangeid_;
}
inline void CancelOrderParam::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void CancelOrderParam::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void CancelOrderParam::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelOrderParam::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* CancelOrderParam::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrdSysId = 3;
inline bool CancelOrderParam::has_ordsysid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelOrderParam::set_has_ordsysid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelOrderParam::clear_has_ordsysid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelOrderParam::clear_ordsysid() {
  if (ordsysid_ != &::google::protobuf::internal::kEmptyString) {
    ordsysid_->clear();
  }
  clear_has_ordsysid();
}
inline const ::std::string& CancelOrderParam::ordsysid() const {
  return *ordsysid_;
}
inline void CancelOrderParam::set_ordsysid(const ::std::string& value) {
  set_has_ordsysid();
  if (ordsysid_ == &::google::protobuf::internal::kEmptyString) {
    ordsysid_ = new ::std::string;
  }
  ordsysid_->assign(value);
}
inline void CancelOrderParam::set_ordsysid(const char* value) {
  set_has_ordsysid();
  if (ordsysid_ == &::google::protobuf::internal::kEmptyString) {
    ordsysid_ = new ::std::string;
  }
  ordsysid_->assign(value);
}
inline void CancelOrderParam::set_ordsysid(const char* value, size_t size) {
  set_has_ordsysid();
  if (ordsysid_ == &::google::protobuf::internal::kEmptyString) {
    ordsysid_ = new ::std::string;
  }
  ordsysid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelOrderParam::mutable_ordsysid() {
  set_has_ordsysid();
  if (ordsysid_ == &::google::protobuf::internal::kEmptyString) {
    ordsysid_ = new ::std::string;
  }
  return ordsysid_;
}
inline ::std::string* CancelOrderParam::release_ordsysid() {
  clear_has_ordsysid();
  if (ordsysid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordsysid_;
    ordsysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserId = 4;
inline bool CancelOrderParam::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelOrderParam::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelOrderParam::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelOrderParam::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& CancelOrderParam::userid() const {
  return *userid_;
}
inline void CancelOrderParam::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void CancelOrderParam::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void CancelOrderParam::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelOrderParam::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* CancelOrderParam::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Symbol = 5;
inline bool CancelOrderParam::has_symbol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelOrderParam::set_has_symbol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelOrderParam::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelOrderParam::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& CancelOrderParam::symbol() const {
  return *symbol_;
}
inline void CancelOrderParam::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void CancelOrderParam::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void CancelOrderParam::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CancelOrderParam::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* CancelOrderParam::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ManualCloseOrderParam

// required string Symbol = 1;
inline bool ManualCloseOrderParam::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualCloseOrderParam::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualCloseOrderParam::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualCloseOrderParam::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& ManualCloseOrderParam::symbol() const {
  return *symbol_;
}
inline void ManualCloseOrderParam::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ManualCloseOrderParam::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ManualCloseOrderParam::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualCloseOrderParam::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* ManualCloseOrderParam::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .trade.TradeDirectionType Direction = 2;
inline bool ManualCloseOrderParam::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualCloseOrderParam::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualCloseOrderParam::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualCloseOrderParam::clear_direction() {
  direction_ = 48;
  clear_has_direction();
}
inline trade::TradeDirectionType ManualCloseOrderParam::direction() const {
  return static_cast< trade::TradeDirectionType >(direction_);
}
inline void ManualCloseOrderParam::set_direction(trade::TradeDirectionType value) {
  GOOGLE_DCHECK(trade::TradeDirectionType_IsValid(value));
  set_has_direction();
  direction_ = value;
}

// required string OpenDate = 3;
inline bool ManualCloseOrderParam::has_opendate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualCloseOrderParam::set_has_opendate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualCloseOrderParam::clear_has_opendate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualCloseOrderParam::clear_opendate() {
  if (opendate_ != &::google::protobuf::internal::kEmptyString) {
    opendate_->clear();
  }
  clear_has_opendate();
}
inline const ::std::string& ManualCloseOrderParam::opendate() const {
  return *opendate_;
}
inline void ManualCloseOrderParam::set_opendate(const ::std::string& value) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(value);
}
inline void ManualCloseOrderParam::set_opendate(const char* value) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(value);
}
inline void ManualCloseOrderParam::set_opendate(const char* value, size_t size) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManualCloseOrderParam::mutable_opendate() {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  return opendate_;
}
inline ::std::string* ManualCloseOrderParam::release_opendate() {
  clear_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opendate_;
    opendate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 Quantity = 4;
inline bool ManualCloseOrderParam::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualCloseOrderParam::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualCloseOrderParam::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualCloseOrderParam::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 ManualCloseOrderParam::quantity() const {
  return quantity_;
}
inline void ManualCloseOrderParam::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// SymbolInfo

// required string Instrument = 1;
inline bool SymbolInfo::has_instrument() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolInfo::set_has_instrument() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolInfo::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolInfo::clear_instrument() {
  if (instrument_ != &::google::protobuf::internal::kEmptyString) {
    instrument_->clear();
  }
  clear_has_instrument();
}
inline const ::std::string& SymbolInfo::instrument() const {
  return *instrument_;
}
inline void SymbolInfo::set_instrument(const ::std::string& value) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(value);
}
inline void SymbolInfo::set_instrument(const char* value) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(value);
}
inline void SymbolInfo::set_instrument(const char* value, size_t size) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolInfo::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  return instrument_;
}
inline ::std::string* SymbolInfo::release_instrument() {
  clear_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_;
    instrument_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeID = 2;
inline bool SymbolInfo::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolInfo::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolInfo::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolInfo::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& SymbolInfo::exchangeid() const {
  return *exchangeid_;
}
inline void SymbolInfo::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void SymbolInfo::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void SymbolInfo::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolInfo::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* SymbolInfo::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeInstID = 3;
inline bool SymbolInfo::has_exchangeinstid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolInfo::set_has_exchangeinstid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolInfo::clear_has_exchangeinstid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolInfo::clear_exchangeinstid() {
  if (exchangeinstid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_->clear();
  }
  clear_has_exchangeinstid();
}
inline const ::std::string& SymbolInfo::exchangeinstid() const {
  return *exchangeinstid_;
}
inline void SymbolInfo::set_exchangeinstid(const ::std::string& value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void SymbolInfo::set_exchangeinstid(const char* value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void SymbolInfo::set_exchangeinstid(const char* value, size_t size) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolInfo::mutable_exchangeinstid() {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  return exchangeinstid_;
}
inline ::std::string* SymbolInfo::release_exchangeinstid() {
  clear_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeinstid_;
    exchangeinstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ProductID = 4;
inline bool SymbolInfo::has_productid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolInfo::set_has_productid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolInfo::clear_has_productid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolInfo::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& SymbolInfo::productid() const {
  return *productid_;
}
inline void SymbolInfo::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void SymbolInfo::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void SymbolInfo::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolInfo::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* SymbolInfo::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 VolumeMultiple = 5;
inline bool SymbolInfo::has_volumemultiple() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolInfo::set_has_volumemultiple() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolInfo::clear_has_volumemultiple() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolInfo::clear_volumemultiple() {
  volumemultiple_ = 0;
  clear_has_volumemultiple();
}
inline ::google::protobuf::int32 SymbolInfo::volumemultiple() const {
  return volumemultiple_;
}
inline void SymbolInfo::set_volumemultiple(::google::protobuf::int32 value) {
  set_has_volumemultiple();
  volumemultiple_ = value;
}

// required double PriceTick = 6;
inline bool SymbolInfo::has_pricetick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SymbolInfo::set_has_pricetick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SymbolInfo::clear_has_pricetick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SymbolInfo::clear_pricetick() {
  pricetick_ = 0;
  clear_has_pricetick();
}
inline double SymbolInfo::pricetick() const {
  return pricetick_;
}
inline void SymbolInfo::set_pricetick(double value) {
  set_has_pricetick();
  pricetick_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace entity

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::ServerType>() {
  return entity::ServerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::PortfolioSwitchType>() {
  return entity::PortfolioSwitchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::StrategyType>() {
  return entity::StrategyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::SlopeDirection>() {
  return entity::SlopeDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::DirectionDepends>() {
  return entity::DirectionDepends_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< entity::StopLossCloseMethods>() {
  return entity::StopLossCloseMethods_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
