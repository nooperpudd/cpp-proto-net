// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trade.proto

#ifndef PROTOBUF_trade_2eproto__INCLUDED
#define PROTOBUF_trade_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace protoc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trade_2eproto();
void protobuf_AssignDesc_trade_2eproto();
void protobuf_ShutdownFile_trade_2eproto();

class AccountInfo;
class PositionInfo;

// ===================================================================

class AccountInfo : public ::google::protobuf::Message {
 public:
  AccountInfo();
  virtual ~AccountInfo();
  
  AccountInfo(const AccountInfo& from);
  
  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountInfo& default_instance();
  
  void Swap(AccountInfo* other);
  
  // implements Message ----------------------------------------------
  
  AccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountInfo& from);
  void MergeFrom(const AccountInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerID = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIDFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string AccountID = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIDFieldNumber = 2;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  
  // required double PreMortgage = 3;
  inline bool has_premortgage() const;
  inline void clear_premortgage();
  static const int kPreMortgageFieldNumber = 3;
  inline double premortgage() const;
  inline void set_premortgage(double value);
  
  // required double PreCredit = 4;
  inline bool has_precredit() const;
  inline void clear_precredit();
  static const int kPreCreditFieldNumber = 4;
  inline double precredit() const;
  inline void set_precredit(double value);
  
  // required double PreDeposit = 5;
  inline bool has_predeposit() const;
  inline void clear_predeposit();
  static const int kPreDepositFieldNumber = 5;
  inline double predeposit() const;
  inline void set_predeposit(double value);
  
  // required double PreBalance = 6;
  inline bool has_prebalance() const;
  inline void clear_prebalance();
  static const int kPreBalanceFieldNumber = 6;
  inline double prebalance() const;
  inline void set_prebalance(double value);
  
  // required double PreMargin = 7;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPreMarginFieldNumber = 7;
  inline double premargin() const;
  inline void set_premargin(double value);
  
  // required double InterestBase = 8;
  inline bool has_interestbase() const;
  inline void clear_interestbase();
  static const int kInterestBaseFieldNumber = 8;
  inline double interestbase() const;
  inline void set_interestbase(double value);
  
  // required double Interest = 9;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 9;
  inline double interest() const;
  inline void set_interest(double value);
  
  // required double Deposit = 10;
  inline bool has_deposit() const;
  inline void clear_deposit();
  static const int kDepositFieldNumber = 10;
  inline double deposit() const;
  inline void set_deposit(double value);
  
  // required double Withdraw = 11;
  inline bool has_withdraw() const;
  inline void clear_withdraw();
  static const int kWithdrawFieldNumber = 11;
  inline double withdraw() const;
  inline void set_withdraw(double value);
  
  // required double FrozenMargin = 12;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenMarginFieldNumber = 12;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);
  
  // required double FrozenCash = 13;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozenCashFieldNumber = 13;
  inline double frozencash() const;
  inline void set_frozencash(double value);
  
  // required double FrozenCommission = 14;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozenCommissionFieldNumber = 14;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);
  
  // required double CurrMargin = 15;
  inline bool has_currmargin() const;
  inline void clear_currmargin();
  static const int kCurrMarginFieldNumber = 15;
  inline double currmargin() const;
  inline void set_currmargin(double value);
  
  // required double CashIn = 16;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashInFieldNumber = 16;
  inline double cashin() const;
  inline void set_cashin(double value);
  
  // required double Commission = 17;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 17;
  inline double commission() const;
  inline void set_commission(double value);
  
  // required double CloseProfit = 18;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseProfitFieldNumber = 18;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);
  
  // required double PositionProfit = 19;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionProfitFieldNumber = 19;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);
  
  // required double Balance = 20;
  inline bool has_balance() const;
  inline void clear_balance();
  static const int kBalanceFieldNumber = 20;
  inline double balance() const;
  inline void set_balance(double value);
  
  // required double Available = 21;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 21;
  inline double available() const;
  inline void set_available(double value);
  
  // required double WithdrawQuota = 22;
  inline bool has_withdrawquota() const;
  inline void clear_withdrawquota();
  static const int kWithdrawQuotaFieldNumber = 22;
  inline double withdrawquota() const;
  inline void set_withdrawquota(double value);
  
  // required double Reserve = 23;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 23;
  inline double reserve() const;
  inline void set_reserve(double value);
  
  // required string TradingDay = 24;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 24;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 25;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 25;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required double Credit = 26;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 26;
  inline double credit() const;
  inline void set_credit(double value);
  
  // required double Mortgage = 27;
  inline bool has_mortgage() const;
  inline void clear_mortgage();
  static const int kMortgageFieldNumber = 27;
  inline double mortgage() const;
  inline void set_mortgage(double value);
  
  // required double ExchangeMargin = 28;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangeMarginFieldNumber = 28;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);
  
  // required double DeliveryMargin = 29;
  inline bool has_deliverymargin() const;
  inline void clear_deliverymargin();
  static const int kDeliveryMarginFieldNumber = 29;
  inline double deliverymargin() const;
  inline void set_deliverymargin(double value);
  
  // required double ExchangeDeliveryMargin = 30;
  inline bool has_exchangedeliverymargin() const;
  inline void clear_exchangedeliverymargin();
  static const int kExchangeDeliveryMarginFieldNumber = 30;
  inline double exchangedeliverymargin() const;
  inline void set_exchangedeliverymargin(double value);
  
  // @@protoc_insertion_point(class_scope:protoc.AccountInfo)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_premortgage();
  inline void clear_has_premortgage();
  inline void set_has_precredit();
  inline void clear_has_precredit();
  inline void set_has_predeposit();
  inline void clear_has_predeposit();
  inline void set_has_prebalance();
  inline void clear_has_prebalance();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_interestbase();
  inline void clear_has_interestbase();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_deposit();
  inline void clear_has_deposit();
  inline void set_has_withdraw();
  inline void clear_has_withdraw();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_currmargin();
  inline void clear_has_currmargin();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_balance();
  inline void clear_has_balance();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_withdrawquota();
  inline void clear_has_withdrawquota();
  inline void set_has_reserve();
  inline void clear_has_reserve();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_mortgage();
  inline void clear_has_mortgage();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();
  inline void set_has_deliverymargin();
  inline void clear_has_deliverymargin();
  inline void set_has_exchangedeliverymargin();
  inline void clear_has_exchangedeliverymargin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* accountid_;
  double premortgage_;
  double precredit_;
  double predeposit_;
  double prebalance_;
  double premargin_;
  double interestbase_;
  double interest_;
  double deposit_;
  double withdraw_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  double currmargin_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double balance_;
  double available_;
  double withdrawquota_;
  double reserve_;
  ::std::string* tradingday_;
  double credit_;
  double mortgage_;
  double exchangemargin_;
  double deliverymargin_;
  double exchangedeliverymargin_;
  ::google::protobuf::int32 settlementid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];
  
  friend void  protobuf_AddDesc_trade_2eproto();
  friend void protobuf_AssignDesc_trade_2eproto();
  friend void protobuf_ShutdownFile_trade_2eproto();
  
  void InitAsDefaultInstance();
  static AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class PositionInfo : public ::google::protobuf::Message {
 public:
  PositionInfo();
  virtual ~PositionInfo();
  
  PositionInfo(const PositionInfo& from);
  
  inline PositionInfo& operator=(const PositionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionInfo& default_instance();
  
  void Swap(PositionInfo* other);
  
  // implements Message ----------------------------------------------
  
  PositionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionInfo& from);
  void MergeFrom(const PositionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string InstrumentID = 1;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string BrokerID = 2;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIDFieldNumber = 2;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string InvestorID = 3;
  inline bool has_investorid() const;
  inline void clear_investorid();
  static const int kInvestorIDFieldNumber = 3;
  inline const ::std::string& investorid() const;
  inline void set_investorid(const ::std::string& value);
  inline void set_investorid(const char* value);
  inline void set_investorid(const char* value, size_t size);
  inline ::std::string* mutable_investorid();
  inline ::std::string* release_investorid();
  
  // required string PosiDirection = 4;
  inline bool has_posidirection() const;
  inline void clear_posidirection();
  static const int kPosiDirectionFieldNumber = 4;
  inline const ::std::string& posidirection() const;
  inline void set_posidirection(const ::std::string& value);
  inline void set_posidirection(const char* value);
  inline void set_posidirection(const char* value, size_t size);
  inline ::std::string* mutable_posidirection();
  inline ::std::string* release_posidirection();
  
  // required string HedgeFlag = 5;
  inline bool has_hedgeflag() const;
  inline void clear_hedgeflag();
  static const int kHedgeFlagFieldNumber = 5;
  inline const ::std::string& hedgeflag() const;
  inline void set_hedgeflag(const ::std::string& value);
  inline void set_hedgeflag(const char* value);
  inline void set_hedgeflag(const char* value, size_t size);
  inline ::std::string* mutable_hedgeflag();
  inline ::std::string* release_hedgeflag();
  
  // required string PositionDate = 6;
  inline bool has_positiondate() const;
  inline void clear_positiondate();
  static const int kPositionDateFieldNumber = 6;
  inline const ::std::string& positiondate() const;
  inline void set_positiondate(const ::std::string& value);
  inline void set_positiondate(const char* value);
  inline void set_positiondate(const char* value, size_t size);
  inline ::std::string* mutable_positiondate();
  inline ::std::string* release_positiondate();
  
  // required int32 YdPosition = 7;
  inline bool has_ydposition() const;
  inline void clear_ydposition();
  static const int kYdPositionFieldNumber = 7;
  inline ::google::protobuf::int32 ydposition() const;
  inline void set_ydposition(::google::protobuf::int32 value);
  
  // required int32 Position = 8;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);
  
  // required int32 LongFrozen = 9;
  inline bool has_longfrozen() const;
  inline void clear_longfrozen();
  static const int kLongFrozenFieldNumber = 9;
  inline ::google::protobuf::int32 longfrozen() const;
  inline void set_longfrozen(::google::protobuf::int32 value);
  
  // required int32 ShortFrozen = 10;
  inline bool has_shortfrozen() const;
  inline void clear_shortfrozen();
  static const int kShortFrozenFieldNumber = 10;
  inline ::google::protobuf::int32 shortfrozen() const;
  inline void set_shortfrozen(::google::protobuf::int32 value);
  
  // required double LongFrozenAmount = 11;
  inline bool has_longfrozenamount() const;
  inline void clear_longfrozenamount();
  static const int kLongFrozenAmountFieldNumber = 11;
  inline double longfrozenamount() const;
  inline void set_longfrozenamount(double value);
  
  // required double ShortFrozenAmount = 12;
  inline bool has_shortfrozenamount() const;
  inline void clear_shortfrozenamount();
  static const int kShortFrozenAmountFieldNumber = 12;
  inline double shortfrozenamount() const;
  inline void set_shortfrozenamount(double value);
  
  // required int32 OpenVolume = 13;
  inline bool has_openvolume() const;
  inline void clear_openvolume();
  static const int kOpenVolumeFieldNumber = 13;
  inline ::google::protobuf::int32 openvolume() const;
  inline void set_openvolume(::google::protobuf::int32 value);
  
  // required int32 CloseVolume = 14;
  inline bool has_closevolume() const;
  inline void clear_closevolume();
  static const int kCloseVolumeFieldNumber = 14;
  inline ::google::protobuf::int32 closevolume() const;
  inline void set_closevolume(::google::protobuf::int32 value);
  
  // required double OpenAmount = 15;
  inline bool has_openamount() const;
  inline void clear_openamount();
  static const int kOpenAmountFieldNumber = 15;
  inline double openamount() const;
  inline void set_openamount(double value);
  
  // required double CloseAmount = 16;
  inline bool has_closeamount() const;
  inline void clear_closeamount();
  static const int kCloseAmountFieldNumber = 16;
  inline double closeamount() const;
  inline void set_closeamount(double value);
  
  // required double PositionCost = 17;
  inline bool has_positioncost() const;
  inline void clear_positioncost();
  static const int kPositionCostFieldNumber = 17;
  inline double positioncost() const;
  inline void set_positioncost(double value);
  
  // required double PreMargin = 18;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPreMarginFieldNumber = 18;
  inline double premargin() const;
  inline void set_premargin(double value);
  
  // required double UseMargin = 19;
  inline bool has_usemargin() const;
  inline void clear_usemargin();
  static const int kUseMarginFieldNumber = 19;
  inline double usemargin() const;
  inline void set_usemargin(double value);
  
  // required double FrozenMargin = 20;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenMarginFieldNumber = 20;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);
  
  // required double FrozenCash = 21;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozenCashFieldNumber = 21;
  inline double frozencash() const;
  inline void set_frozencash(double value);
  
  // required double FrozenCommission = 22;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozenCommissionFieldNumber = 22;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);
  
  // required double CashIn = 23;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashInFieldNumber = 23;
  inline double cashin() const;
  inline void set_cashin(double value);
  
  // required double Commission = 24;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 24;
  inline double commission() const;
  inline void set_commission(double value);
  
  // required double CloseProfit = 25;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseProfitFieldNumber = 25;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);
  
  // required double PositionProfit = 26;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionProfitFieldNumber = 26;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);
  
  // required double PreSettlementPrice = 27;
  inline bool has_presettlementprice() const;
  inline void clear_presettlementprice();
  static const int kPreSettlementPriceFieldNumber = 27;
  inline double presettlementprice() const;
  inline void set_presettlementprice(double value);
  
  // required double SettlementPrice = 28;
  inline bool has_settlementprice() const;
  inline void clear_settlementprice();
  static const int kSettlementPriceFieldNumber = 28;
  inline double settlementprice() const;
  inline void set_settlementprice(double value);
  
  // required string TradingDay = 29;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 29;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 30;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 30;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required double OpenCost = 31;
  inline bool has_opencost() const;
  inline void clear_opencost();
  static const int kOpenCostFieldNumber = 31;
  inline double opencost() const;
  inline void set_opencost(double value);
  
  // required double ExchangeMargin = 32;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangeMarginFieldNumber = 32;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);
  
  // required int32 CombPosition = 33;
  inline bool has_combposition() const;
  inline void clear_combposition();
  static const int kCombPositionFieldNumber = 33;
  inline ::google::protobuf::int32 combposition() const;
  inline void set_combposition(::google::protobuf::int32 value);
  
  // required int32 CombLongFrozen = 34;
  inline bool has_comblongfrozen() const;
  inline void clear_comblongfrozen();
  static const int kCombLongFrozenFieldNumber = 34;
  inline ::google::protobuf::int32 comblongfrozen() const;
  inline void set_comblongfrozen(::google::protobuf::int32 value);
  
  // required int32 CombShortFrozen = 35;
  inline bool has_combshortfrozen() const;
  inline void clear_combshortfrozen();
  static const int kCombShortFrozenFieldNumber = 35;
  inline ::google::protobuf::int32 combshortfrozen() const;
  inline void set_combshortfrozen(::google::protobuf::int32 value);
  
  // required double CloseProfitByDate = 36;
  inline bool has_closeprofitbydate() const;
  inline void clear_closeprofitbydate();
  static const int kCloseProfitByDateFieldNumber = 36;
  inline double closeprofitbydate() const;
  inline void set_closeprofitbydate(double value);
  
  // required double CloseProfitByTrade = 37;
  inline bool has_closeprofitbytrade() const;
  inline void clear_closeprofitbytrade();
  static const int kCloseProfitByTradeFieldNumber = 37;
  inline double closeprofitbytrade() const;
  inline void set_closeprofitbytrade(double value);
  
  // required int32 TodayPosition = 38;
  inline bool has_todayposition() const;
  inline void clear_todayposition();
  static const int kTodayPositionFieldNumber = 38;
  inline ::google::protobuf::int32 todayposition() const;
  inline void set_todayposition(::google::protobuf::int32 value);
  
  // required double MarginRateByMoney = 39;
  inline bool has_marginratebymoney() const;
  inline void clear_marginratebymoney();
  static const int kMarginRateByMoneyFieldNumber = 39;
  inline double marginratebymoney() const;
  inline void set_marginratebymoney(double value);
  
  // required double MarginRateByVolume = 40;
  inline bool has_marginratebyvolume() const;
  inline void clear_marginratebyvolume();
  static const int kMarginRateByVolumeFieldNumber = 40;
  inline double marginratebyvolume() const;
  inline void set_marginratebyvolume(double value);
  
  // @@protoc_insertion_point(class_scope:protoc.PositionInfo)
 private:
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_investorid();
  inline void clear_has_investorid();
  inline void set_has_posidirection();
  inline void clear_has_posidirection();
  inline void set_has_hedgeflag();
  inline void clear_has_hedgeflag();
  inline void set_has_positiondate();
  inline void clear_has_positiondate();
  inline void set_has_ydposition();
  inline void clear_has_ydposition();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_longfrozen();
  inline void clear_has_longfrozen();
  inline void set_has_shortfrozen();
  inline void clear_has_shortfrozen();
  inline void set_has_longfrozenamount();
  inline void clear_has_longfrozenamount();
  inline void set_has_shortfrozenamount();
  inline void clear_has_shortfrozenamount();
  inline void set_has_openvolume();
  inline void clear_has_openvolume();
  inline void set_has_closevolume();
  inline void clear_has_closevolume();
  inline void set_has_openamount();
  inline void clear_has_openamount();
  inline void set_has_closeamount();
  inline void clear_has_closeamount();
  inline void set_has_positioncost();
  inline void clear_has_positioncost();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_usemargin();
  inline void clear_has_usemargin();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_presettlementprice();
  inline void clear_has_presettlementprice();
  inline void set_has_settlementprice();
  inline void clear_has_settlementprice();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_opencost();
  inline void clear_has_opencost();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();
  inline void set_has_combposition();
  inline void clear_has_combposition();
  inline void set_has_comblongfrozen();
  inline void clear_has_comblongfrozen();
  inline void set_has_combshortfrozen();
  inline void clear_has_combshortfrozen();
  inline void set_has_closeprofitbydate();
  inline void clear_has_closeprofitbydate();
  inline void set_has_closeprofitbytrade();
  inline void clear_has_closeprofitbytrade();
  inline void set_has_todayposition();
  inline void clear_has_todayposition();
  inline void set_has_marginratebymoney();
  inline void clear_has_marginratebymoney();
  inline void set_has_marginratebyvolume();
  inline void clear_has_marginratebyvolume();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* brokerid_;
  ::std::string* investorid_;
  ::std::string* posidirection_;
  ::std::string* hedgeflag_;
  ::std::string* positiondate_;
  ::google::protobuf::int32 ydposition_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::int32 longfrozen_;
  ::google::protobuf::int32 shortfrozen_;
  double longfrozenamount_;
  double shortfrozenamount_;
  ::google::protobuf::int32 openvolume_;
  ::google::protobuf::int32 closevolume_;
  double openamount_;
  double closeamount_;
  double positioncost_;
  double premargin_;
  double usemargin_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double presettlementprice_;
  double settlementprice_;
  ::std::string* tradingday_;
  double opencost_;
  ::google::protobuf::int32 settlementid_;
  ::google::protobuf::int32 combposition_;
  double exchangemargin_;
  ::google::protobuf::int32 comblongfrozen_;
  ::google::protobuf::int32 combshortfrozen_;
  double closeprofitbydate_;
  double closeprofitbytrade_;
  double marginratebymoney_;
  double marginratebyvolume_;
  ::google::protobuf::int32 todayposition_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];
  
  friend void  protobuf_AddDesc_trade_2eproto();
  friend void protobuf_AssignDesc_trade_2eproto();
  friend void protobuf_ShutdownFile_trade_2eproto();
  
  void InitAsDefaultInstance();
  static PositionInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountInfo

// required string BrokerID = 1;
inline bool AccountInfo::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountInfo::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountInfo::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountInfo::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& AccountInfo::brokerid() const {
  return *brokerid_;
}
inline void AccountInfo::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void AccountInfo::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void AccountInfo::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* AccountInfo::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string AccountID = 2;
inline bool AccountInfo::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountInfo::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountInfo::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountInfo::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& AccountInfo::accountid() const {
  return *accountid_;
}
inline void AccountInfo::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void AccountInfo::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void AccountInfo::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* AccountInfo::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double PreMortgage = 3;
inline bool AccountInfo::has_premortgage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountInfo::set_has_premortgage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountInfo::clear_has_premortgage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountInfo::clear_premortgage() {
  premortgage_ = 0;
  clear_has_premortgage();
}
inline double AccountInfo::premortgage() const {
  return premortgage_;
}
inline void AccountInfo::set_premortgage(double value) {
  set_has_premortgage();
  premortgage_ = value;
}

// required double PreCredit = 4;
inline bool AccountInfo::has_precredit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountInfo::set_has_precredit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountInfo::clear_has_precredit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountInfo::clear_precredit() {
  precredit_ = 0;
  clear_has_precredit();
}
inline double AccountInfo::precredit() const {
  return precredit_;
}
inline void AccountInfo::set_precredit(double value) {
  set_has_precredit();
  precredit_ = value;
}

// required double PreDeposit = 5;
inline bool AccountInfo::has_predeposit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountInfo::set_has_predeposit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountInfo::clear_has_predeposit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountInfo::clear_predeposit() {
  predeposit_ = 0;
  clear_has_predeposit();
}
inline double AccountInfo::predeposit() const {
  return predeposit_;
}
inline void AccountInfo::set_predeposit(double value) {
  set_has_predeposit();
  predeposit_ = value;
}

// required double PreBalance = 6;
inline bool AccountInfo::has_prebalance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountInfo::set_has_prebalance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountInfo::clear_has_prebalance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountInfo::clear_prebalance() {
  prebalance_ = 0;
  clear_has_prebalance();
}
inline double AccountInfo::prebalance() const {
  return prebalance_;
}
inline void AccountInfo::set_prebalance(double value) {
  set_has_prebalance();
  prebalance_ = value;
}

// required double PreMargin = 7;
inline bool AccountInfo::has_premargin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountInfo::set_has_premargin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountInfo::clear_has_premargin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountInfo::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double AccountInfo::premargin() const {
  return premargin_;
}
inline void AccountInfo::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double InterestBase = 8;
inline bool AccountInfo::has_interestbase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountInfo::set_has_interestbase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountInfo::clear_has_interestbase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountInfo::clear_interestbase() {
  interestbase_ = 0;
  clear_has_interestbase();
}
inline double AccountInfo::interestbase() const {
  return interestbase_;
}
inline void AccountInfo::set_interestbase(double value) {
  set_has_interestbase();
  interestbase_ = value;
}

// required double Interest = 9;
inline bool AccountInfo::has_interest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountInfo::set_has_interest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountInfo::clear_has_interest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountInfo::clear_interest() {
  interest_ = 0;
  clear_has_interest();
}
inline double AccountInfo::interest() const {
  return interest_;
}
inline void AccountInfo::set_interest(double value) {
  set_has_interest();
  interest_ = value;
}

// required double Deposit = 10;
inline bool AccountInfo::has_deposit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountInfo::set_has_deposit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountInfo::clear_has_deposit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountInfo::clear_deposit() {
  deposit_ = 0;
  clear_has_deposit();
}
inline double AccountInfo::deposit() const {
  return deposit_;
}
inline void AccountInfo::set_deposit(double value) {
  set_has_deposit();
  deposit_ = value;
}

// required double Withdraw = 11;
inline bool AccountInfo::has_withdraw() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountInfo::set_has_withdraw() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountInfo::clear_has_withdraw() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountInfo::clear_withdraw() {
  withdraw_ = 0;
  clear_has_withdraw();
}
inline double AccountInfo::withdraw() const {
  return withdraw_;
}
inline void AccountInfo::set_withdraw(double value) {
  set_has_withdraw();
  withdraw_ = value;
}

// required double FrozenMargin = 12;
inline bool AccountInfo::has_frozenmargin() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountInfo::set_has_frozenmargin() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountInfo::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountInfo::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double AccountInfo::frozenmargin() const {
  return frozenmargin_;
}
inline void AccountInfo::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double FrozenCash = 13;
inline bool AccountInfo::has_frozencash() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AccountInfo::set_has_frozencash() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AccountInfo::clear_has_frozencash() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AccountInfo::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double AccountInfo::frozencash() const {
  return frozencash_;
}
inline void AccountInfo::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double FrozenCommission = 14;
inline bool AccountInfo::has_frozencommission() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AccountInfo::set_has_frozencommission() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AccountInfo::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AccountInfo::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double AccountInfo::frozencommission() const {
  return frozencommission_;
}
inline void AccountInfo::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double CurrMargin = 15;
inline bool AccountInfo::has_currmargin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AccountInfo::set_has_currmargin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AccountInfo::clear_has_currmargin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AccountInfo::clear_currmargin() {
  currmargin_ = 0;
  clear_has_currmargin();
}
inline double AccountInfo::currmargin() const {
  return currmargin_;
}
inline void AccountInfo::set_currmargin(double value) {
  set_has_currmargin();
  currmargin_ = value;
}

// required double CashIn = 16;
inline bool AccountInfo::has_cashin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AccountInfo::set_has_cashin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AccountInfo::clear_has_cashin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AccountInfo::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double AccountInfo::cashin() const {
  return cashin_;
}
inline void AccountInfo::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double Commission = 17;
inline bool AccountInfo::has_commission() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AccountInfo::set_has_commission() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AccountInfo::clear_has_commission() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AccountInfo::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double AccountInfo::commission() const {
  return commission_;
}
inline void AccountInfo::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double CloseProfit = 18;
inline bool AccountInfo::has_closeprofit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AccountInfo::set_has_closeprofit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AccountInfo::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AccountInfo::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double AccountInfo::closeprofit() const {
  return closeprofit_;
}
inline void AccountInfo::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double PositionProfit = 19;
inline bool AccountInfo::has_positionprofit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AccountInfo::set_has_positionprofit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AccountInfo::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AccountInfo::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double AccountInfo::positionprofit() const {
  return positionprofit_;
}
inline void AccountInfo::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double Balance = 20;
inline bool AccountInfo::has_balance() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AccountInfo::set_has_balance() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AccountInfo::clear_has_balance() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AccountInfo::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline double AccountInfo::balance() const {
  return balance_;
}
inline void AccountInfo::set_balance(double value) {
  set_has_balance();
  balance_ = value;
}

// required double Available = 21;
inline bool AccountInfo::has_available() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AccountInfo::set_has_available() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AccountInfo::clear_has_available() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AccountInfo::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline double AccountInfo::available() const {
  return available_;
}
inline void AccountInfo::set_available(double value) {
  set_has_available();
  available_ = value;
}

// required double WithdrawQuota = 22;
inline bool AccountInfo::has_withdrawquota() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AccountInfo::set_has_withdrawquota() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AccountInfo::clear_has_withdrawquota() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AccountInfo::clear_withdrawquota() {
  withdrawquota_ = 0;
  clear_has_withdrawquota();
}
inline double AccountInfo::withdrawquota() const {
  return withdrawquota_;
}
inline void AccountInfo::set_withdrawquota(double value) {
  set_has_withdrawquota();
  withdrawquota_ = value;
}

// required double Reserve = 23;
inline bool AccountInfo::has_reserve() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AccountInfo::set_has_reserve() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AccountInfo::clear_has_reserve() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AccountInfo::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline double AccountInfo::reserve() const {
  return reserve_;
}
inline void AccountInfo::set_reserve(double value) {
  set_has_reserve();
  reserve_ = value;
}

// required string TradingDay = 24;
inline bool AccountInfo::has_tradingday() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AccountInfo::set_has_tradingday() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AccountInfo::clear_has_tradingday() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AccountInfo::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& AccountInfo::tradingday() const {
  return *tradingday_;
}
inline void AccountInfo::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void AccountInfo::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void AccountInfo::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* AccountInfo::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 25;
inline bool AccountInfo::has_settlementid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AccountInfo::set_has_settlementid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AccountInfo::clear_has_settlementid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AccountInfo::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 AccountInfo::settlementid() const {
  return settlementid_;
}
inline void AccountInfo::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double Credit = 26;
inline bool AccountInfo::has_credit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AccountInfo::set_has_credit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AccountInfo::clear_has_credit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AccountInfo::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline double AccountInfo::credit() const {
  return credit_;
}
inline void AccountInfo::set_credit(double value) {
  set_has_credit();
  credit_ = value;
}

// required double Mortgage = 27;
inline bool AccountInfo::has_mortgage() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AccountInfo::set_has_mortgage() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AccountInfo::clear_has_mortgage() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AccountInfo::clear_mortgage() {
  mortgage_ = 0;
  clear_has_mortgage();
}
inline double AccountInfo::mortgage() const {
  return mortgage_;
}
inline void AccountInfo::set_mortgage(double value) {
  set_has_mortgage();
  mortgage_ = value;
}

// required double ExchangeMargin = 28;
inline bool AccountInfo::has_exchangemargin() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AccountInfo::set_has_exchangemargin() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AccountInfo::clear_has_exchangemargin() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AccountInfo::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double AccountInfo::exchangemargin() const {
  return exchangemargin_;
}
inline void AccountInfo::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// required double DeliveryMargin = 29;
inline bool AccountInfo::has_deliverymargin() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AccountInfo::set_has_deliverymargin() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AccountInfo::clear_has_deliverymargin() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AccountInfo::clear_deliverymargin() {
  deliverymargin_ = 0;
  clear_has_deliverymargin();
}
inline double AccountInfo::deliverymargin() const {
  return deliverymargin_;
}
inline void AccountInfo::set_deliverymargin(double value) {
  set_has_deliverymargin();
  deliverymargin_ = value;
}

// required double ExchangeDeliveryMargin = 30;
inline bool AccountInfo::has_exchangedeliverymargin() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AccountInfo::set_has_exchangedeliverymargin() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AccountInfo::clear_has_exchangedeliverymargin() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AccountInfo::clear_exchangedeliverymargin() {
  exchangedeliverymargin_ = 0;
  clear_has_exchangedeliverymargin();
}
inline double AccountInfo::exchangedeliverymargin() const {
  return exchangedeliverymargin_;
}
inline void AccountInfo::set_exchangedeliverymargin(double value) {
  set_has_exchangedeliverymargin();
  exchangedeliverymargin_ = value;
}

// -------------------------------------------------------------------

// PositionInfo

// required string InstrumentID = 1;
inline bool PositionInfo::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionInfo::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionInfo::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionInfo::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& PositionInfo::instrumentid() const {
  return *instrumentid_;
}
inline void PositionInfo::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void PositionInfo::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void PositionInfo::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* PositionInfo::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BrokerID = 2;
inline bool PositionInfo::has_brokerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionInfo::set_has_brokerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionInfo::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionInfo::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& PositionInfo::brokerid() const {
  return *brokerid_;
}
inline void PositionInfo::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void PositionInfo::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void PositionInfo::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* PositionInfo::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InvestorID = 3;
inline bool PositionInfo::has_investorid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionInfo::set_has_investorid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionInfo::clear_has_investorid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionInfo::clear_investorid() {
  if (investorid_ != &::google::protobuf::internal::kEmptyString) {
    investorid_->clear();
  }
  clear_has_investorid();
}
inline const ::std::string& PositionInfo::investorid() const {
  return *investorid_;
}
inline void PositionInfo::set_investorid(const ::std::string& value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void PositionInfo::set_investorid(const char* value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void PositionInfo::set_investorid(const char* value, size_t size) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_investorid() {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  return investorid_;
}
inline ::std::string* PositionInfo::release_investorid() {
  clear_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investorid_;
    investorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PosiDirection = 4;
inline bool PositionInfo::has_posidirection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionInfo::set_has_posidirection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionInfo::clear_has_posidirection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionInfo::clear_posidirection() {
  if (posidirection_ != &::google::protobuf::internal::kEmptyString) {
    posidirection_->clear();
  }
  clear_has_posidirection();
}
inline const ::std::string& PositionInfo::posidirection() const {
  return *posidirection_;
}
inline void PositionInfo::set_posidirection(const ::std::string& value) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(value);
}
inline void PositionInfo::set_posidirection(const char* value) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(value);
}
inline void PositionInfo::set_posidirection(const char* value, size_t size) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_posidirection() {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  return posidirection_;
}
inline ::std::string* PositionInfo::release_posidirection() {
  clear_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posidirection_;
    posidirection_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string HedgeFlag = 5;
inline bool PositionInfo::has_hedgeflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionInfo::set_has_hedgeflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionInfo::clear_has_hedgeflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionInfo::clear_hedgeflag() {
  if (hedgeflag_ != &::google::protobuf::internal::kEmptyString) {
    hedgeflag_->clear();
  }
  clear_has_hedgeflag();
}
inline const ::std::string& PositionInfo::hedgeflag() const {
  return *hedgeflag_;
}
inline void PositionInfo::set_hedgeflag(const ::std::string& value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void PositionInfo::set_hedgeflag(const char* value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void PositionInfo::set_hedgeflag(const char* value, size_t size) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_hedgeflag() {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  return hedgeflag_;
}
inline ::std::string* PositionInfo::release_hedgeflag() {
  clear_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hedgeflag_;
    hedgeflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PositionDate = 6;
inline bool PositionInfo::has_positiondate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionInfo::set_has_positiondate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionInfo::clear_has_positiondate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionInfo::clear_positiondate() {
  if (positiondate_ != &::google::protobuf::internal::kEmptyString) {
    positiondate_->clear();
  }
  clear_has_positiondate();
}
inline const ::std::string& PositionInfo::positiondate() const {
  return *positiondate_;
}
inline void PositionInfo::set_positiondate(const ::std::string& value) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(value);
}
inline void PositionInfo::set_positiondate(const char* value) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(value);
}
inline void PositionInfo::set_positiondate(const char* value, size_t size) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_positiondate() {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  return positiondate_;
}
inline ::std::string* PositionInfo::release_positiondate() {
  clear_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positiondate_;
    positiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 YdPosition = 7;
inline bool PositionInfo::has_ydposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionInfo::set_has_ydposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionInfo::clear_has_ydposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionInfo::clear_ydposition() {
  ydposition_ = 0;
  clear_has_ydposition();
}
inline ::google::protobuf::int32 PositionInfo::ydposition() const {
  return ydposition_;
}
inline void PositionInfo::set_ydposition(::google::protobuf::int32 value) {
  set_has_ydposition();
  ydposition_ = value;
}

// required int32 Position = 8;
inline bool PositionInfo::has_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionInfo::set_has_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionInfo::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 PositionInfo::position() const {
  return position_;
}
inline void PositionInfo::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// required int32 LongFrozen = 9;
inline bool PositionInfo::has_longfrozen() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionInfo::set_has_longfrozen() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionInfo::clear_has_longfrozen() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionInfo::clear_longfrozen() {
  longfrozen_ = 0;
  clear_has_longfrozen();
}
inline ::google::protobuf::int32 PositionInfo::longfrozen() const {
  return longfrozen_;
}
inline void PositionInfo::set_longfrozen(::google::protobuf::int32 value) {
  set_has_longfrozen();
  longfrozen_ = value;
}

// required int32 ShortFrozen = 10;
inline bool PositionInfo::has_shortfrozen() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PositionInfo::set_has_shortfrozen() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PositionInfo::clear_has_shortfrozen() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PositionInfo::clear_shortfrozen() {
  shortfrozen_ = 0;
  clear_has_shortfrozen();
}
inline ::google::protobuf::int32 PositionInfo::shortfrozen() const {
  return shortfrozen_;
}
inline void PositionInfo::set_shortfrozen(::google::protobuf::int32 value) {
  set_has_shortfrozen();
  shortfrozen_ = value;
}

// required double LongFrozenAmount = 11;
inline bool PositionInfo::has_longfrozenamount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PositionInfo::set_has_longfrozenamount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PositionInfo::clear_has_longfrozenamount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PositionInfo::clear_longfrozenamount() {
  longfrozenamount_ = 0;
  clear_has_longfrozenamount();
}
inline double PositionInfo::longfrozenamount() const {
  return longfrozenamount_;
}
inline void PositionInfo::set_longfrozenamount(double value) {
  set_has_longfrozenamount();
  longfrozenamount_ = value;
}

// required double ShortFrozenAmount = 12;
inline bool PositionInfo::has_shortfrozenamount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PositionInfo::set_has_shortfrozenamount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PositionInfo::clear_has_shortfrozenamount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PositionInfo::clear_shortfrozenamount() {
  shortfrozenamount_ = 0;
  clear_has_shortfrozenamount();
}
inline double PositionInfo::shortfrozenamount() const {
  return shortfrozenamount_;
}
inline void PositionInfo::set_shortfrozenamount(double value) {
  set_has_shortfrozenamount();
  shortfrozenamount_ = value;
}

// required int32 OpenVolume = 13;
inline bool PositionInfo::has_openvolume() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PositionInfo::set_has_openvolume() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PositionInfo::clear_has_openvolume() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PositionInfo::clear_openvolume() {
  openvolume_ = 0;
  clear_has_openvolume();
}
inline ::google::protobuf::int32 PositionInfo::openvolume() const {
  return openvolume_;
}
inline void PositionInfo::set_openvolume(::google::protobuf::int32 value) {
  set_has_openvolume();
  openvolume_ = value;
}

// required int32 CloseVolume = 14;
inline bool PositionInfo::has_closevolume() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PositionInfo::set_has_closevolume() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PositionInfo::clear_has_closevolume() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PositionInfo::clear_closevolume() {
  closevolume_ = 0;
  clear_has_closevolume();
}
inline ::google::protobuf::int32 PositionInfo::closevolume() const {
  return closevolume_;
}
inline void PositionInfo::set_closevolume(::google::protobuf::int32 value) {
  set_has_closevolume();
  closevolume_ = value;
}

// required double OpenAmount = 15;
inline bool PositionInfo::has_openamount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PositionInfo::set_has_openamount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PositionInfo::clear_has_openamount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PositionInfo::clear_openamount() {
  openamount_ = 0;
  clear_has_openamount();
}
inline double PositionInfo::openamount() const {
  return openamount_;
}
inline void PositionInfo::set_openamount(double value) {
  set_has_openamount();
  openamount_ = value;
}

// required double CloseAmount = 16;
inline bool PositionInfo::has_closeamount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PositionInfo::set_has_closeamount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PositionInfo::clear_has_closeamount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PositionInfo::clear_closeamount() {
  closeamount_ = 0;
  clear_has_closeamount();
}
inline double PositionInfo::closeamount() const {
  return closeamount_;
}
inline void PositionInfo::set_closeamount(double value) {
  set_has_closeamount();
  closeamount_ = value;
}

// required double PositionCost = 17;
inline bool PositionInfo::has_positioncost() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PositionInfo::set_has_positioncost() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PositionInfo::clear_has_positioncost() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PositionInfo::clear_positioncost() {
  positioncost_ = 0;
  clear_has_positioncost();
}
inline double PositionInfo::positioncost() const {
  return positioncost_;
}
inline void PositionInfo::set_positioncost(double value) {
  set_has_positioncost();
  positioncost_ = value;
}

// required double PreMargin = 18;
inline bool PositionInfo::has_premargin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PositionInfo::set_has_premargin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PositionInfo::clear_has_premargin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PositionInfo::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double PositionInfo::premargin() const {
  return premargin_;
}
inline void PositionInfo::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double UseMargin = 19;
inline bool PositionInfo::has_usemargin() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PositionInfo::set_has_usemargin() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PositionInfo::clear_has_usemargin() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PositionInfo::clear_usemargin() {
  usemargin_ = 0;
  clear_has_usemargin();
}
inline double PositionInfo::usemargin() const {
  return usemargin_;
}
inline void PositionInfo::set_usemargin(double value) {
  set_has_usemargin();
  usemargin_ = value;
}

// required double FrozenMargin = 20;
inline bool PositionInfo::has_frozenmargin() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PositionInfo::set_has_frozenmargin() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PositionInfo::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PositionInfo::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double PositionInfo::frozenmargin() const {
  return frozenmargin_;
}
inline void PositionInfo::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double FrozenCash = 21;
inline bool PositionInfo::has_frozencash() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PositionInfo::set_has_frozencash() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PositionInfo::clear_has_frozencash() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PositionInfo::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double PositionInfo::frozencash() const {
  return frozencash_;
}
inline void PositionInfo::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double FrozenCommission = 22;
inline bool PositionInfo::has_frozencommission() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PositionInfo::set_has_frozencommission() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PositionInfo::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PositionInfo::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double PositionInfo::frozencommission() const {
  return frozencommission_;
}
inline void PositionInfo::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double CashIn = 23;
inline bool PositionInfo::has_cashin() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PositionInfo::set_has_cashin() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PositionInfo::clear_has_cashin() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PositionInfo::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double PositionInfo::cashin() const {
  return cashin_;
}
inline void PositionInfo::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double Commission = 24;
inline bool PositionInfo::has_commission() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PositionInfo::set_has_commission() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PositionInfo::clear_has_commission() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PositionInfo::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double PositionInfo::commission() const {
  return commission_;
}
inline void PositionInfo::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double CloseProfit = 25;
inline bool PositionInfo::has_closeprofit() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PositionInfo::set_has_closeprofit() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PositionInfo::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PositionInfo::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double PositionInfo::closeprofit() const {
  return closeprofit_;
}
inline void PositionInfo::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double PositionProfit = 26;
inline bool PositionInfo::has_positionprofit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PositionInfo::set_has_positionprofit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PositionInfo::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PositionInfo::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double PositionInfo::positionprofit() const {
  return positionprofit_;
}
inline void PositionInfo::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double PreSettlementPrice = 27;
inline bool PositionInfo::has_presettlementprice() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PositionInfo::set_has_presettlementprice() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PositionInfo::clear_has_presettlementprice() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PositionInfo::clear_presettlementprice() {
  presettlementprice_ = 0;
  clear_has_presettlementprice();
}
inline double PositionInfo::presettlementprice() const {
  return presettlementprice_;
}
inline void PositionInfo::set_presettlementprice(double value) {
  set_has_presettlementprice();
  presettlementprice_ = value;
}

// required double SettlementPrice = 28;
inline bool PositionInfo::has_settlementprice() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PositionInfo::set_has_settlementprice() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PositionInfo::clear_has_settlementprice() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PositionInfo::clear_settlementprice() {
  settlementprice_ = 0;
  clear_has_settlementprice();
}
inline double PositionInfo::settlementprice() const {
  return settlementprice_;
}
inline void PositionInfo::set_settlementprice(double value) {
  set_has_settlementprice();
  settlementprice_ = value;
}

// required string TradingDay = 29;
inline bool PositionInfo::has_tradingday() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PositionInfo::set_has_tradingday() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PositionInfo::clear_has_tradingday() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PositionInfo::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& PositionInfo::tradingday() const {
  return *tradingday_;
}
inline void PositionInfo::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void PositionInfo::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void PositionInfo::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionInfo::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* PositionInfo::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 30;
inline bool PositionInfo::has_settlementid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PositionInfo::set_has_settlementid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PositionInfo::clear_has_settlementid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PositionInfo::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 PositionInfo::settlementid() const {
  return settlementid_;
}
inline void PositionInfo::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double OpenCost = 31;
inline bool PositionInfo::has_opencost() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PositionInfo::set_has_opencost() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PositionInfo::clear_has_opencost() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PositionInfo::clear_opencost() {
  opencost_ = 0;
  clear_has_opencost();
}
inline double PositionInfo::opencost() const {
  return opencost_;
}
inline void PositionInfo::set_opencost(double value) {
  set_has_opencost();
  opencost_ = value;
}

// required double ExchangeMargin = 32;
inline bool PositionInfo::has_exchangemargin() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PositionInfo::set_has_exchangemargin() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PositionInfo::clear_has_exchangemargin() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PositionInfo::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double PositionInfo::exchangemargin() const {
  return exchangemargin_;
}
inline void PositionInfo::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// required int32 CombPosition = 33;
inline bool PositionInfo::has_combposition() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PositionInfo::set_has_combposition() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PositionInfo::clear_has_combposition() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PositionInfo::clear_combposition() {
  combposition_ = 0;
  clear_has_combposition();
}
inline ::google::protobuf::int32 PositionInfo::combposition() const {
  return combposition_;
}
inline void PositionInfo::set_combposition(::google::protobuf::int32 value) {
  set_has_combposition();
  combposition_ = value;
}

// required int32 CombLongFrozen = 34;
inline bool PositionInfo::has_comblongfrozen() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PositionInfo::set_has_comblongfrozen() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PositionInfo::clear_has_comblongfrozen() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PositionInfo::clear_comblongfrozen() {
  comblongfrozen_ = 0;
  clear_has_comblongfrozen();
}
inline ::google::protobuf::int32 PositionInfo::comblongfrozen() const {
  return comblongfrozen_;
}
inline void PositionInfo::set_comblongfrozen(::google::protobuf::int32 value) {
  set_has_comblongfrozen();
  comblongfrozen_ = value;
}

// required int32 CombShortFrozen = 35;
inline bool PositionInfo::has_combshortfrozen() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PositionInfo::set_has_combshortfrozen() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PositionInfo::clear_has_combshortfrozen() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PositionInfo::clear_combshortfrozen() {
  combshortfrozen_ = 0;
  clear_has_combshortfrozen();
}
inline ::google::protobuf::int32 PositionInfo::combshortfrozen() const {
  return combshortfrozen_;
}
inline void PositionInfo::set_combshortfrozen(::google::protobuf::int32 value) {
  set_has_combshortfrozen();
  combshortfrozen_ = value;
}

// required double CloseProfitByDate = 36;
inline bool PositionInfo::has_closeprofitbydate() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PositionInfo::set_has_closeprofitbydate() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PositionInfo::clear_has_closeprofitbydate() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PositionInfo::clear_closeprofitbydate() {
  closeprofitbydate_ = 0;
  clear_has_closeprofitbydate();
}
inline double PositionInfo::closeprofitbydate() const {
  return closeprofitbydate_;
}
inline void PositionInfo::set_closeprofitbydate(double value) {
  set_has_closeprofitbydate();
  closeprofitbydate_ = value;
}

// required double CloseProfitByTrade = 37;
inline bool PositionInfo::has_closeprofitbytrade() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PositionInfo::set_has_closeprofitbytrade() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PositionInfo::clear_has_closeprofitbytrade() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PositionInfo::clear_closeprofitbytrade() {
  closeprofitbytrade_ = 0;
  clear_has_closeprofitbytrade();
}
inline double PositionInfo::closeprofitbytrade() const {
  return closeprofitbytrade_;
}
inline void PositionInfo::set_closeprofitbytrade(double value) {
  set_has_closeprofitbytrade();
  closeprofitbytrade_ = value;
}

// required int32 TodayPosition = 38;
inline bool PositionInfo::has_todayposition() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PositionInfo::set_has_todayposition() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PositionInfo::clear_has_todayposition() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PositionInfo::clear_todayposition() {
  todayposition_ = 0;
  clear_has_todayposition();
}
inline ::google::protobuf::int32 PositionInfo::todayposition() const {
  return todayposition_;
}
inline void PositionInfo::set_todayposition(::google::protobuf::int32 value) {
  set_has_todayposition();
  todayposition_ = value;
}

// required double MarginRateByMoney = 39;
inline bool PositionInfo::has_marginratebymoney() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PositionInfo::set_has_marginratebymoney() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PositionInfo::clear_has_marginratebymoney() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PositionInfo::clear_marginratebymoney() {
  marginratebymoney_ = 0;
  clear_has_marginratebymoney();
}
inline double PositionInfo::marginratebymoney() const {
  return marginratebymoney_;
}
inline void PositionInfo::set_marginratebymoney(double value) {
  set_has_marginratebymoney();
  marginratebymoney_ = value;
}

// required double MarginRateByVolume = 40;
inline bool PositionInfo::has_marginratebyvolume() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PositionInfo::set_has_marginratebyvolume() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PositionInfo::clear_has_marginratebyvolume() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PositionInfo::clear_marginratebyvolume() {
  marginratebyvolume_ = 0;
  clear_has_marginratebyvolume();
}
inline double PositionInfo::marginratebyvolume() const {
  return marginratebyvolume_;
}
inline void PositionInfo::set_marginratebyvolume(double value) {
  set_has_marginratebyvolume();
  marginratebyvolume_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protoc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trade_2eproto__INCLUDED
